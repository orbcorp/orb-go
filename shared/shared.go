// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

package shared

import (
	"reflect"
	"time"

	"github.com/orbcorp/orb-go/internal/apijson"
	"github.com/orbcorp/orb-go/internal/param"
	"github.com/tidwall/gjson"
)

type Address struct {
	City       string      `json:"city,required,nullable"`
	Country    string      `json:"country,required,nullable"`
	Line1      string      `json:"line1,required,nullable"`
	Line2      string      `json:"line2,required,nullable"`
	PostalCode string      `json:"postal_code,required,nullable"`
	State      string      `json:"state,required,nullable"`
	JSON       addressJSON `json:"-"`
}

// addressJSON contains the JSON metadata for the struct [Address]
type addressJSON struct {
	City        apijson.Field
	Country     apijson.Field
	Line1       apijson.Field
	Line2       apijson.Field
	PostalCode  apijson.Field
	State       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *Address) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r addressJSON) RawJSON() string {
	return r.raw
}

type AdjustmentInterval struct {
	ID         string                       `json:"id,required"`
	Adjustment AdjustmentIntervalAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time              `json:"start_date,required" format:"date-time"`
	JSON      adjustmentIntervalJSON `json:"-"`
}

// adjustmentIntervalJSON contains the JSON metadata for the struct
// [AdjustmentInterval]
type adjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *AdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r adjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type AdjustmentIntervalAdjustment struct {
	ID             string                                     `json:"id,required"`
	AdjustmentType AdjustmentIntervalAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]TransformPriceFilter].
	Filters interface{} `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                          `json:"usage_discount"`
	JSON          adjustmentIntervalAdjustmentJSON `json:"-"`
	union         AdjustmentIntervalAdjustmentUnion
}

// adjustmentIntervalAdjustmentJSON contains the JSON metadata for the struct
// [AdjustmentIntervalAdjustment]
type adjustmentIntervalAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	Filters            apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r adjustmentIntervalAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *AdjustmentIntervalAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = AdjustmentIntervalAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [AdjustmentIntervalAdjustmentUnion] interface which you can
// cast to the specific types for more type safety.
//
// Possible runtime types of the union are [PlanPhaseUsageDiscountAdjustment],
// [PlanPhaseAmountDiscountAdjustment], [PlanPhasePercentageDiscountAdjustment],
// [PlanPhaseMinimumAdjustment], [PlanPhaseMaximumAdjustment].
func (r AdjustmentIntervalAdjustment) AsUnion() AdjustmentIntervalAdjustmentUnion {
	return r.union
}

// Union satisfied by [PlanPhaseUsageDiscountAdjustment],
// [PlanPhaseAmountDiscountAdjustment], [PlanPhasePercentageDiscountAdjustment],
// [PlanPhaseMinimumAdjustment] or [PlanPhaseMaximumAdjustment].
type AdjustmentIntervalAdjustmentUnion interface {
	ImplementsAdjustmentIntervalAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*AdjustmentIntervalAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type AdjustmentIntervalAdjustmentAdjustmentType string

const (
	AdjustmentIntervalAdjustmentAdjustmentTypeUsageDiscount      AdjustmentIntervalAdjustmentAdjustmentType = "usage_discount"
	AdjustmentIntervalAdjustmentAdjustmentTypeAmountDiscount     AdjustmentIntervalAdjustmentAdjustmentType = "amount_discount"
	AdjustmentIntervalAdjustmentAdjustmentTypePercentageDiscount AdjustmentIntervalAdjustmentAdjustmentType = "percentage_discount"
	AdjustmentIntervalAdjustmentAdjustmentTypeMinimum            AdjustmentIntervalAdjustmentAdjustmentType = "minimum"
	AdjustmentIntervalAdjustmentAdjustmentTypeMaximum            AdjustmentIntervalAdjustmentAdjustmentType = "maximum"
)

func (r AdjustmentIntervalAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case AdjustmentIntervalAdjustmentAdjustmentTypeUsageDiscount, AdjustmentIntervalAdjustmentAdjustmentTypeAmountDiscount, AdjustmentIntervalAdjustmentAdjustmentTypePercentageDiscount, AdjustmentIntervalAdjustmentAdjustmentTypeMinimum, AdjustmentIntervalAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type AggregatedCost struct {
	PerPriceCosts []PerPriceCost `json:"per_price_costs,required"`
	// Total costs for the timeframe, excluding any minimums and discounts.
	Subtotal       string    `json:"subtotal,required"`
	TimeframeEnd   time.Time `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time `json:"timeframe_start,required" format:"date-time"`
	// Total costs for the timeframe, including any minimums and discounts.
	Total string             `json:"total,required"`
	JSON  aggregatedCostJSON `json:"-"`
}

// aggregatedCostJSON contains the JSON metadata for the struct [AggregatedCost]
type aggregatedCostJSON struct {
	PerPriceCosts  apijson.Field
	Subtotal       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	Total          apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *AggregatedCost) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r aggregatedCostJSON) RawJSON() string {
	return r.raw
}

type Allocation struct {
	AllowsRollover   bool             `json:"allows_rollover,required"`
	Currency         string           `json:"currency,required"`
	CustomExpiration CustomExpiration `json:"custom_expiration,required,nullable"`
	JSON             allocationJSON   `json:"-"`
}

// allocationJSON contains the JSON metadata for the struct [Allocation]
type allocationJSON struct {
	AllowsRollover   apijson.Field
	Currency         apijson.Field
	CustomExpiration apijson.Field
	raw              string
	ExtraFields      map[string]apijson.Field
}

func (r *Allocation) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r allocationJSON) RawJSON() string {
	return r.raw
}

type AmountDiscount struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string                     `json:"amount_discount,required"`
	DiscountType   AmountDiscountDiscountType `json:"discount_type,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,nullable"`
	// The filters that determine which prices to apply this discount to.
	Filters []TransformPriceFilter `json:"filters,nullable"`
	Reason  string                 `json:"reason,nullable"`
	JSON    amountDiscountJSON     `json:"-"`
}

// amountDiscountJSON contains the JSON metadata for the struct [AmountDiscount]
type amountDiscountJSON struct {
	AmountDiscount    apijson.Field
	DiscountType      apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *AmountDiscount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r amountDiscountJSON) RawJSON() string {
	return r.raw
}

func (r AmountDiscount) ImplementsDiscount() {}

func (r AmountDiscount) ImplementsInvoiceLevelDiscount() {}

func (r AmountDiscount) ImplementsCouponDiscount() {}

type AmountDiscountDiscountType string

const (
	AmountDiscountDiscountTypeAmount AmountDiscountDiscountType = "amount"
)

func (r AmountDiscountDiscountType) IsKnown() bool {
	switch r {
	case AmountDiscountDiscountTypeAmount:
		return true
	}
	return false
}

type AmountDiscountParam struct {
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[string]                     `json:"amount_discount,required"`
	DiscountType   param.Field[AmountDiscountDiscountType] `json:"discount_type,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// The filters that determine which prices to apply this discount to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	Reason  param.Field[string]                      `json:"reason"`
}

func (r AmountDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r AmountDiscountParam) ImplementsDiscountUnionParam() {}

type AmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              AmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The filters that determine which prices this discount interval applies to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// The start date of the discount interval.
	StartDate time.Time                  `json:"start_date,required" format:"date-time"`
	JSON      amountDiscountIntervalJSON `json:"-"`
}

// amountDiscountIntervalJSON contains the JSON metadata for the struct
// [AmountDiscountInterval]
type amountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	Filters                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *AmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r amountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r AmountDiscountInterval) ImplementsSubscriptionDiscountInterval() {}

func (r AmountDiscountInterval) ImplementsMutatedSubscriptionDiscountInterval() {}

type AmountDiscountIntervalDiscountType string

const (
	AmountDiscountIntervalDiscountTypeAmount AmountDiscountIntervalDiscountType = "amount"
)

func (r AmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case AmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type BillableMetricTiny struct {
	ID   string                 `json:"id,required"`
	JSON billableMetricTinyJSON `json:"-"`
}

// billableMetricTinyJSON contains the JSON metadata for the struct
// [BillableMetricTiny]
type billableMetricTinyJSON struct {
	ID          apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *BillableMetricTiny) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r billableMetricTinyJSON) RawJSON() string {
	return r.raw
}

type BillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                               `json:"year,nullable"`
	JSON billingCycleAnchorConfigurationJSON `json:"-"`
}

// billingCycleAnchorConfigurationJSON contains the JSON metadata for the struct
// [BillingCycleAnchorConfiguration]
type billingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *BillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r billingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type BillingCycleAnchorConfigurationParam struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day param.Field[int64] `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month param.Field[int64] `json:"month"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year param.Field[int64] `json:"year"`
}

func (r BillingCycleAnchorConfigurationParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type BillingCycleConfiguration struct {
	Duration     int64                                 `json:"duration,required"`
	DurationUnit BillingCycleConfigurationDurationUnit `json:"duration_unit,required"`
	JSON         billingCycleConfigurationJSON         `json:"-"`
}

// billingCycleConfigurationJSON contains the JSON metadata for the struct
// [BillingCycleConfiguration]
type billingCycleConfigurationJSON struct {
	Duration     apijson.Field
	DurationUnit apijson.Field
	raw          string
	ExtraFields  map[string]apijson.Field
}

func (r *BillingCycleConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r billingCycleConfigurationJSON) RawJSON() string {
	return r.raw
}

type BillingCycleConfigurationDurationUnit string

const (
	BillingCycleConfigurationDurationUnitDay   BillingCycleConfigurationDurationUnit = "day"
	BillingCycleConfigurationDurationUnitMonth BillingCycleConfigurationDurationUnit = "month"
)

func (r BillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case BillingCycleConfigurationDurationUnitDay, BillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type BillingCycleRelativeDate string

const (
	BillingCycleRelativeDateStartOfTerm BillingCycleRelativeDate = "start_of_term"
	BillingCycleRelativeDateEndOfTerm   BillingCycleRelativeDate = "end_of_term"
)

func (r BillingCycleRelativeDate) IsKnown() bool {
	switch r {
	case BillingCycleRelativeDateStartOfTerm, BillingCycleRelativeDateEndOfTerm:
		return true
	}
	return false
}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsAddStartDateUnion() {}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsAddEndDateUnion() {}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion() {
}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion() {
}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsEditEndDateUnion() {}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsEditStartDateUnion() {}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion() {
}

func (r BillingCycleRelativeDate) ImplementsSubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion() {
}

type BPSConfig struct {
	// Basis point take rate per event
	BPS float64 `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum string        `json:"per_unit_maximum,nullable"`
	JSON           bpsConfigJSON `json:"-"`
}

// bpsConfigJSON contains the JSON metadata for the struct [BPSConfig]
type bpsConfigJSON struct {
	BPS            apijson.Field
	PerUnitMaximum apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *BPSConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r bpsConfigJSON) RawJSON() string {
	return r.raw
}

type BPSConfigParam struct {
	// Basis point take rate per event
	BPS param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r BPSConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type BPSTier struct {
	// Per-event basis point rate
	BPS float64 `json:"bps,required"`
	// Exclusive tier starting value
	MinimumAmount string `json:"minimum_amount,required"`
	// Inclusive tier ending value
	MaximumAmount string `json:"maximum_amount,nullable"`
	// Per unit maximum to charge
	PerUnitMaximum string      `json:"per_unit_maximum,nullable"`
	JSON           bpsTierJSON `json:"-"`
}

// bpsTierJSON contains the JSON metadata for the struct [BPSTier]
type bpsTierJSON struct {
	BPS            apijson.Field
	MinimumAmount  apijson.Field
	MaximumAmount  apijson.Field
	PerUnitMaximum apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *BPSTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r bpsTierJSON) RawJSON() string {
	return r.raw
}

type BPSTierParam struct {
	// Per-event basis point rate
	BPS param.Field[float64] `json:"bps,required"`
	// Exclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Inclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r BPSTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type BulkBPSConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers []BulkBPSTier     `json:"tiers,required"`
	JSON  bulkBPSConfigJSON `json:"-"`
}

// bulkBPSConfigJSON contains the JSON metadata for the struct [BulkBPSConfig]
type bulkBPSConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *BulkBPSConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r bulkBPSConfigJSON) RawJSON() string {
	return r.raw
}

type BulkBPSConfigParam struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]BulkBPSTierParam] `json:"tiers,required"`
}

func (r BulkBPSConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type BulkBPSTier struct {
	// Basis points to rate on
	BPS float64 `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount string `json:"maximum_amount,nullable"`
	// The maximum amount to charge for any one event
	PerUnitMaximum string          `json:"per_unit_maximum,nullable"`
	JSON           bulkBPSTierJSON `json:"-"`
}

// bulkBPSTierJSON contains the JSON metadata for the struct [BulkBPSTier]
type bulkBPSTierJSON struct {
	BPS            apijson.Field
	MaximumAmount  apijson.Field
	PerUnitMaximum apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *BulkBPSTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r bulkBPSTierJSON) RawJSON() string {
	return r.raw
}

type BulkBPSTierParam struct {
	// Basis points to rate on
	BPS param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r BulkBPSTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type BulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers []BulkTier     `json:"tiers,required"`
	JSON  bulkConfigJSON `json:"-"`
}

// bulkConfigJSON contains the JSON metadata for the struct [BulkConfig]
type bulkConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *BulkConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r bulkConfigJSON) RawJSON() string {
	return r.raw
}

type BulkConfigParam struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]BulkTierParam] `json:"tiers,required"`
}

func (r BulkConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type BulkTier struct {
	// Amount per unit
	UnitAmount string `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits float64      `json:"maximum_units,nullable"`
	JSON         bulkTierJSON `json:"-"`
}

// bulkTierJSON contains the JSON metadata for the struct [BulkTier]
type bulkTierJSON struct {
	UnitAmount   apijson.Field
	MaximumUnits apijson.Field
	raw          string
	ExtraFields  map[string]apijson.Field
}

func (r *BulkTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r bulkTierJSON) RawJSON() string {
	return r.raw
}

type BulkTierParam struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r BulkTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type ChangedSubscriptionResources struct {
	// The credit notes that were created as part of this operation.
	CreatedCreditNotes []CreditNote `json:"created_credit_notes,required"`
	// The invoices that were created as part of this operation.
	CreatedInvoices []Invoice `json:"created_invoices,required"`
	// The credit notes that were voided as part of this operation.
	VoidedCreditNotes []CreditNote `json:"voided_credit_notes,required"`
	// The invoices that were voided as part of this operation.
	VoidedInvoices []Invoice                        `json:"voided_invoices,required"`
	JSON           changedSubscriptionResourcesJSON `json:"-"`
}

// changedSubscriptionResourcesJSON contains the JSON metadata for the struct
// [ChangedSubscriptionResources]
type changedSubscriptionResourcesJSON struct {
	CreatedCreditNotes apijson.Field
	CreatedInvoices    apijson.Field
	VoidedCreditNotes  apijson.Field
	VoidedInvoices     apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *ChangedSubscriptionResources) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r changedSubscriptionResourcesJSON) RawJSON() string {
	return r.raw
}

type CouponRedemption struct {
	CouponID  string               `json:"coupon_id,required"`
	EndDate   time.Time            `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time            `json:"start_date,required" format:"date-time"`
	JSON      couponRedemptionJSON `json:"-"`
}

// couponRedemptionJSON contains the JSON metadata for the struct
// [CouponRedemption]
type couponRedemptionJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *CouponRedemption) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r couponRedemptionJSON) RawJSON() string {
	return r.raw
}

// The [Credit Note](/invoicing/credit-notes) resource represents a credit that has
// been applied to a particular invoice.
type CreditNote struct {
	// The Orb id of this credit note.
	ID string `json:"id,required"`
	// The creation time of the resource in Orb.
	CreatedAt time.Time `json:"created_at,required" format:"date-time"`
	// The unique identifier for credit notes.
	CreditNoteNumber string `json:"credit_note_number,required"`
	// A URL to a PDF of the credit note.
	CreditNotePdf string           `json:"credit_note_pdf,required,nullable"`
	Customer      CustomerMinified `json:"customer,required"`
	// The id of the invoice resource that this credit note is applied to.
	InvoiceID string `json:"invoice_id,required"`
	// All of the line items associated with this credit note.
	LineItems []CreditNoteLineItem `json:"line_items,required"`
	// The maximum amount applied on the original invoice
	MaximumAmountAdjustment CreditNoteMaximumAmountAdjustment `json:"maximum_amount_adjustment,required,nullable"`
	// An optional memo supplied on the credit note.
	Memo string `json:"memo,required,nullable"`
	// Any credited amount from the applied minimum on the invoice.
	MinimumAmountRefunded string           `json:"minimum_amount_refunded,required,nullable"`
	Reason                CreditNoteReason `json:"reason,required,nullable"`
	// The total prior to any creditable invoice-level discounts or minimums.
	Subtotal string `json:"subtotal,required"`
	// The total including creditable invoice-level discounts or minimums, and tax.
	Total string         `json:"total,required"`
	Type  CreditNoteType `json:"type,required"`
	// The time at which the credit note was voided in Orb, if applicable.
	VoidedAt time.Time `json:"voided_at,required,nullable" format:"date-time"`
	// Any discounts applied on the original invoice.
	Discounts []CreditNoteDiscount `json:"discounts"`
	JSON      creditNoteJSON       `json:"-"`
}

// creditNoteJSON contains the JSON metadata for the struct [CreditNote]
type creditNoteJSON struct {
	ID                      apijson.Field
	CreatedAt               apijson.Field
	CreditNoteNumber        apijson.Field
	CreditNotePdf           apijson.Field
	Customer                apijson.Field
	InvoiceID               apijson.Field
	LineItems               apijson.Field
	MaximumAmountAdjustment apijson.Field
	Memo                    apijson.Field
	MinimumAmountRefunded   apijson.Field
	Reason                  apijson.Field
	Subtotal                apijson.Field
	Total                   apijson.Field
	Type                    apijson.Field
	VoidedAt                apijson.Field
	Discounts               apijson.Field
	raw                     string
	ExtraFields             map[string]apijson.Field
}

func (r *CreditNote) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteJSON) RawJSON() string {
	return r.raw
}

type CreditNoteLineItem struct {
	// The Orb id of this resource.
	ID string `json:"id,required"`
	// The amount of the line item, including any line item minimums and discounts.
	Amount string `json:"amount,required"`
	// The id of the item associated with this line item.
	ItemID string `json:"item_id,required"`
	// The name of the corresponding invoice line item.
	Name string `json:"name,required"`
	// An optional quantity credited.
	Quantity float64 `json:"quantity,required,nullable"`
	// The amount of the line item, excluding any line item minimums and discounts.
	Subtotal string `json:"subtotal,required"`
	// Any tax amounts applied onto the line item.
	TaxAmounts []TaxAmount `json:"tax_amounts,required"`
	// Any line item discounts from the invoice's line item.
	Discounts []CreditNoteLineItemsDiscount `json:"discounts"`
	JSON      creditNoteLineItemJSON        `json:"-"`
}

// creditNoteLineItemJSON contains the JSON metadata for the struct
// [CreditNoteLineItem]
type creditNoteLineItemJSON struct {
	ID          apijson.Field
	Amount      apijson.Field
	ItemID      apijson.Field
	Name        apijson.Field
	Quantity    apijson.Field
	Subtotal    apijson.Field
	TaxAmounts  apijson.Field
	Discounts   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *CreditNoteLineItem) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteLineItemJSON) RawJSON() string {
	return r.raw
}

type CreditNoteLineItemsDiscount struct {
	ID                 string                                   `json:"id,required"`
	AmountApplied      string                                   `json:"amount_applied,required"`
	AppliesToPriceIDs  []string                                 `json:"applies_to_price_ids,required"`
	DiscountType       CreditNoteLineItemsDiscountsDiscountType `json:"discount_type,required"`
	PercentageDiscount float64                                  `json:"percentage_discount,required"`
	AmountDiscount     string                                   `json:"amount_discount,nullable"`
	Reason             string                                   `json:"reason,nullable"`
	JSON               creditNoteLineItemsDiscountJSON          `json:"-"`
}

// creditNoteLineItemsDiscountJSON contains the JSON metadata for the struct
// [CreditNoteLineItemsDiscount]
type creditNoteLineItemsDiscountJSON struct {
	ID                 apijson.Field
	AmountApplied      apijson.Field
	AppliesToPriceIDs  apijson.Field
	DiscountType       apijson.Field
	PercentageDiscount apijson.Field
	AmountDiscount     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *CreditNoteLineItemsDiscount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteLineItemsDiscountJSON) RawJSON() string {
	return r.raw
}

type CreditNoteLineItemsDiscountsDiscountType string

const (
	CreditNoteLineItemsDiscountsDiscountTypePercentage CreditNoteLineItemsDiscountsDiscountType = "percentage"
	CreditNoteLineItemsDiscountsDiscountTypeAmount     CreditNoteLineItemsDiscountsDiscountType = "amount"
)

func (r CreditNoteLineItemsDiscountsDiscountType) IsKnown() bool {
	switch r {
	case CreditNoteLineItemsDiscountsDiscountTypePercentage, CreditNoteLineItemsDiscountsDiscountTypeAmount:
		return true
	}
	return false
}

// The maximum amount applied on the original invoice
type CreditNoteMaximumAmountAdjustment struct {
	AmountApplied      string                                            `json:"amount_applied,required"`
	DiscountType       CreditNoteMaximumAmountAdjustmentDiscountType     `json:"discount_type,required"`
	PercentageDiscount float64                                           `json:"percentage_discount,required"`
	AppliesToPrices    []CreditNoteMaximumAmountAdjustmentAppliesToPrice `json:"applies_to_prices,nullable"`
	Reason             string                                            `json:"reason,nullable"`
	JSON               creditNoteMaximumAmountAdjustmentJSON             `json:"-"`
}

// creditNoteMaximumAmountAdjustmentJSON contains the JSON metadata for the struct
// [CreditNoteMaximumAmountAdjustment]
type creditNoteMaximumAmountAdjustmentJSON struct {
	AmountApplied      apijson.Field
	DiscountType       apijson.Field
	PercentageDiscount apijson.Field
	AppliesToPrices    apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *CreditNoteMaximumAmountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteMaximumAmountAdjustmentJSON) RawJSON() string {
	return r.raw
}

type CreditNoteMaximumAmountAdjustmentDiscountType string

const (
	CreditNoteMaximumAmountAdjustmentDiscountTypePercentage CreditNoteMaximumAmountAdjustmentDiscountType = "percentage"
)

func (r CreditNoteMaximumAmountAdjustmentDiscountType) IsKnown() bool {
	switch r {
	case CreditNoteMaximumAmountAdjustmentDiscountTypePercentage:
		return true
	}
	return false
}

type CreditNoteMaximumAmountAdjustmentAppliesToPrice struct {
	ID   string                                              `json:"id,required"`
	Name string                                              `json:"name,required"`
	JSON creditNoteMaximumAmountAdjustmentAppliesToPriceJSON `json:"-"`
}

// creditNoteMaximumAmountAdjustmentAppliesToPriceJSON contains the JSON metadata
// for the struct [CreditNoteMaximumAmountAdjustmentAppliesToPrice]
type creditNoteMaximumAmountAdjustmentAppliesToPriceJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *CreditNoteMaximumAmountAdjustmentAppliesToPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteMaximumAmountAdjustmentAppliesToPriceJSON) RawJSON() string {
	return r.raw
}

type CreditNoteReason string

const (
	CreditNoteReasonDuplicate             CreditNoteReason = "Duplicate"
	CreditNoteReasonFraudulent            CreditNoteReason = "Fraudulent"
	CreditNoteReasonOrderChange           CreditNoteReason = "Order change"
	CreditNoteReasonProductUnsatisfactory CreditNoteReason = "Product unsatisfactory"
)

func (r CreditNoteReason) IsKnown() bool {
	switch r {
	case CreditNoteReasonDuplicate, CreditNoteReasonFraudulent, CreditNoteReasonOrderChange, CreditNoteReasonProductUnsatisfactory:
		return true
	}
	return false
}

type CreditNoteType string

const (
	CreditNoteTypeRefund     CreditNoteType = "refund"
	CreditNoteTypeAdjustment CreditNoteType = "adjustment"
)

func (r CreditNoteType) IsKnown() bool {
	switch r {
	case CreditNoteTypeRefund, CreditNoteTypeAdjustment:
		return true
	}
	return false
}

type CreditNoteDiscount struct {
	AmountApplied      string                              `json:"amount_applied,required"`
	DiscountType       CreditNoteDiscountsDiscountType     `json:"discount_type,required"`
	PercentageDiscount float64                             `json:"percentage_discount,required"`
	AppliesToPrices    []CreditNoteDiscountsAppliesToPrice `json:"applies_to_prices,nullable"`
	Reason             string                              `json:"reason,nullable"`
	JSON               creditNoteDiscountJSON              `json:"-"`
}

// creditNoteDiscountJSON contains the JSON metadata for the struct
// [CreditNoteDiscount]
type creditNoteDiscountJSON struct {
	AmountApplied      apijson.Field
	DiscountType       apijson.Field
	PercentageDiscount apijson.Field
	AppliesToPrices    apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *CreditNoteDiscount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteDiscountJSON) RawJSON() string {
	return r.raw
}

type CreditNoteDiscountsDiscountType string

const (
	CreditNoteDiscountsDiscountTypePercentage CreditNoteDiscountsDiscountType = "percentage"
)

func (r CreditNoteDiscountsDiscountType) IsKnown() bool {
	switch r {
	case CreditNoteDiscountsDiscountTypePercentage:
		return true
	}
	return false
}

type CreditNoteDiscountsAppliesToPrice struct {
	ID   string                                `json:"id,required"`
	Name string                                `json:"name,required"`
	JSON creditNoteDiscountsAppliesToPriceJSON `json:"-"`
}

// creditNoteDiscountsAppliesToPriceJSON contains the JSON metadata for the struct
// [CreditNoteDiscountsAppliesToPrice]
type creditNoteDiscountsAppliesToPriceJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *CreditNoteDiscountsAppliesToPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteDiscountsAppliesToPriceJSON) RawJSON() string {
	return r.raw
}

type CreditNoteTiny struct {
	// The id of the Credit note
	ID   string             `json:"id,required"`
	JSON creditNoteTinyJSON `json:"-"`
}

// creditNoteTinyJSON contains the JSON metadata for the struct [CreditNoteTiny]
type creditNoteTinyJSON struct {
	ID          apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *CreditNoteTiny) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r creditNoteTinyJSON) RawJSON() string {
	return r.raw
}

type CustomExpiration struct {
	Duration     int64                        `json:"duration,required"`
	DurationUnit CustomExpirationDurationUnit `json:"duration_unit,required"`
	JSON         customExpirationJSON         `json:"-"`
}

// customExpirationJSON contains the JSON metadata for the struct
// [CustomExpiration]
type customExpirationJSON struct {
	Duration     apijson.Field
	DurationUnit apijson.Field
	raw          string
	ExtraFields  map[string]apijson.Field
}

func (r *CustomExpiration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r customExpirationJSON) RawJSON() string {
	return r.raw
}

type CustomExpirationDurationUnit string

const (
	CustomExpirationDurationUnitDay   CustomExpirationDurationUnit = "day"
	CustomExpirationDurationUnitMonth CustomExpirationDurationUnit = "month"
)

func (r CustomExpirationDurationUnit) IsKnown() bool {
	switch r {
	case CustomExpirationDurationUnitDay, CustomExpirationDurationUnitMonth:
		return true
	}
	return false
}

type CustomExpirationParam struct {
	Duration     param.Field[int64]                        `json:"duration,required"`
	DurationUnit param.Field[CustomExpirationDurationUnit] `json:"duration_unit,required"`
}

func (r CustomExpirationParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type CustomerMinified struct {
	ID                 string               `json:"id,required"`
	ExternalCustomerID string               `json:"external_customer_id,required,nullable"`
	JSON               customerMinifiedJSON `json:"-"`
}

// customerMinifiedJSON contains the JSON metadata for the struct
// [CustomerMinified]
type customerMinifiedJSON struct {
	ID                 apijson.Field
	ExternalCustomerID apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *CustomerMinified) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r customerMinifiedJSON) RawJSON() string {
	return r.raw
}

// Tax IDs are commonly required to be displayed on customer invoices, which are
// added to the headers of invoices.
//
// ### Supported Tax ID Countries and Types
//
// | Country              | Type         | Description                                                                                             |
// | -------------------- | ------------ | ------------------------------------------------------------------------------------------------------- |
// | Andorra              | `ad_nrt`     | Andorran NRT Number                                                                                     |
// | Argentina            | `ar_cuit`    | Argentinian Tax ID Number                                                                               |
// | Australia            | `au_abn`     | Australian Business Number (AU ABN)                                                                     |
// | Australia            | `au_arn`     | Australian Taxation Office Reference Number                                                             |
// | Austria              | `eu_vat`     | European VAT Number                                                                                     |
// | Bahrain              | `bh_vat`     | Bahraini VAT Number                                                                                     |
// | Belgium              | `eu_vat`     | European VAT Number                                                                                     |
// | Bolivia              | `bo_tin`     | Bolivian Tax ID                                                                                         |
// | Brazil               | `br_cnpj`    | Brazilian CNPJ Number                                                                                   |
// | Brazil               | `br_cpf`     | Brazilian CPF Number                                                                                    |
// | Bulgaria             | `bg_uic`     | Bulgaria Unified Identification Code                                                                    |
// | Bulgaria             | `eu_vat`     | European VAT Number                                                                                     |
// | Canada               | `ca_bn`      | Canadian BN                                                                                             |
// | Canada               | `ca_gst_hst` | Canadian GST/HST Number                                                                                 |
// | Canada               | `ca_pst_bc`  | Canadian PST Number (British Columbia)                                                                  |
// | Canada               | `ca_pst_mb`  | Canadian PST Number (Manitoba)                                                                          |
// | Canada               | `ca_pst_sk`  | Canadian PST Number (Saskatchewan)                                                                      |
// | Canada               | `ca_qst`     | Canadian QST Number (Québec)                                                                            |
// | Chile                | `cl_tin`     | Chilean TIN                                                                                             |
// | China                | `cn_tin`     | Chinese Tax ID                                                                                          |
// | Colombia             | `co_nit`     | Colombian NIT Number                                                                                    |
// | Costa Rica           | `cr_tin`     | Costa Rican Tax ID                                                                                      |
// | Croatia              | `eu_vat`     | European VAT Number                                                                                     |
// | Cyprus               | `eu_vat`     | European VAT Number                                                                                     |
// | Czech Republic       | `eu_vat`     | European VAT Number                                                                                     |
// | Denmark              | `eu_vat`     | European VAT Number                                                                                     |
// | Dominican Republic   | `do_rcn`     | Dominican RCN Number                                                                                    |
// | Ecuador              | `ec_ruc`     | Ecuadorian RUC Number                                                                                   |
// | Egypt                | `eg_tin`     | Egyptian Tax Identification Number                                                                      |
// | El Salvador          | `sv_nit`     | El Salvadorian NIT Number                                                                               |
// | Estonia              | `eu_vat`     | European VAT Number                                                                                     |
// | EU                   | `eu_oss_vat` | European One Stop Shop VAT Number for non-Union scheme                                                  |
// | Finland              | `eu_vat`     | European VAT Number                                                                                     |
// | France               | `eu_vat`     | European VAT Number                                                                                     |
// | Georgia              | `ge_vat`     | Georgian VAT                                                                                            |
// | Germany              | `eu_vat`     | European VAT Number                                                                                     |
// | Greece               | `eu_vat`     | European VAT Number                                                                                     |
// | Hong Kong            | `hk_br`      | Hong Kong BR Number                                                                                     |
// | Hungary              | `eu_vat`     | European VAT Number                                                                                     |
// | Hungary              | `hu_tin`     | Hungary Tax Number (adószám)                                                                            |
// | Iceland              | `is_vat`     | Icelandic VAT                                                                                           |
// | India                | `in_gst`     | Indian GST Number                                                                                       |
// | Indonesia            | `id_npwp`    | Indonesian NPWP Number                                                                                  |
// | Ireland              | `eu_vat`     | European VAT Number                                                                                     |
// | Israel               | `il_vat`     | Israel VAT                                                                                              |
// | Italy                | `eu_vat`     | European VAT Number                                                                                     |
// | Japan                | `jp_cn`      | Japanese Corporate Number (_Hōjin Bangō_)                                                               |
// | Japan                | `jp_rn`      | Japanese Registered Foreign Businesses' Registration Number (_Tōroku Kokugai Jigyōsha no Tōroku Bangō_) |
// | Japan                | `jp_trn`     | Japanese Tax Registration Number (_Tōroku Bangō_)                                                       |
// | Kazakhstan           | `kz_bin`     | Kazakhstani Business Identification Number                                                              |
// | Kenya                | `ke_pin`     | Kenya Revenue Authority Personal Identification Number                                                  |
// | Latvia               | `eu_vat`     | European VAT Number                                                                                     |
// | Liechtenstein        | `li_uid`     | Liechtensteinian UID Number                                                                             |
// | Lithuania            | `eu_vat`     | European VAT Number                                                                                     |
// | Luxembourg           | `eu_vat`     | European VAT Number                                                                                     |
// | Malaysia             | `my_frp`     | Malaysian FRP Number                                                                                    |
// | Malaysia             | `my_itn`     | Malaysian ITN                                                                                           |
// | Malaysia             | `my_sst`     | Malaysian SST Number                                                                                    |
// | Malta                | `eu_vat `    | European VAT Number                                                                                     |
// | Mexico               | `mx_rfc`     | Mexican RFC Number                                                                                      |
// | Netherlands          | `eu_vat`     | European VAT Number                                                                                     |
// | New Zealand          | `nz_gst`     | New Zealand GST Number                                                                                  |
// | Nigeria              | `ng_tin`     | Nigerian Tax Identification Number                                                                      |
// | Norway               | `no_vat`     | Norwegian VAT Number                                                                                    |
// | Norway               | `no_voec`    | Norwegian VAT on e-commerce Number                                                                      |
// | Oman                 | `om_vat`     | Omani VAT Number                                                                                        |
// | Peru                 | `pe_ruc`     | Peruvian RUC Number                                                                                     |
// | Philippines          | `ph_tin `    | Philippines Tax Identification Number                                                                   |
// | Poland               | `eu_vat`     | European VAT Number                                                                                     |
// | Portugal             | `eu_vat`     | European VAT Number                                                                                     |
// | Romania              | `eu_vat`     | European VAT Number                                                                                     |
// | Romania              | `ro_tin`     | Romanian Tax ID Number                                                                                  |
// | Russia               | `ru_inn`     | Russian INN                                                                                             |
// | Russia               | `ru_kpp`     | Russian KPP                                                                                             |
// | Saudi Arabia         | `sa_vat`     | Saudi Arabia VAT                                                                                        |
// | Serbia               | `rs_pib`     | Serbian PIB Number                                                                                      |
// | Singapore            | `sg_gst`     | Singaporean GST                                                                                         |
// | Singapore            | `sg_uen`     | Singaporean UEN                                                                                         |
// | Slovakia             | `eu_vat`     | European VAT Number                                                                                     |
// | Slovenia             | `eu_vat`     | European VAT Number                                                                                     |
// | Slovenia             | `si_tin`     | Slovenia Tax Number (davčna številka)                                                                   |
// | South Africa         | `za_vat`     | South African VAT Number                                                                                |
// | South Korea          | `kr_brn`     | Korean BRN                                                                                              |
// | Spain                | `es_cif`     | Spanish NIF Number (previously Spanish CIF Number)                                                      |
// | Spain                | `eu_vat`     | European VAT Number                                                                                     |
// | Sweden               | `eu_vat`     | European VAT Number                                                                                     |
// | Switzerland          | `ch_vat`     | Switzerland VAT Number                                                                                  |
// | Taiwan               | `tw_vat`     | Taiwanese VAT                                                                                           |
// | Thailand             | `th_vat`     | Thai VAT                                                                                                |
// | Turkey               | `tr_tin`     | Turkish Tax Identification Number                                                                       |
// | Ukraine              | `ua_vat`     | Ukrainian VAT                                                                                           |
// | United Arab Emirates | `ae_trn`     | United Arab Emirates TRN                                                                                |
// | United Kingdom       | `eu_vat`     | Northern Ireland VAT Number                                                                             |
// | United Kingdom       | `gb_vat`     | United Kingdom VAT Number                                                                               |
// | United States        | `us_ein`     | United States EIN                                                                                       |
// | Uruguay              | `uy_ruc`     | Uruguayan RUC Number                                                                                    |
// | Venezuela            | `ve_rif`     | Venezuelan RIF Number                                                                                   |
// | Vietnam              | `vn_tin`     | Vietnamese Tax ID Number                                                                                |
type CustomerTaxID struct {
	Country CustomerTaxIDCountry `json:"country,required"`
	Type    CustomerTaxIDType    `json:"type,required"`
	Value   string               `json:"value,required"`
	JSON    customerTaxIDJSON    `json:"-"`
}

// customerTaxIDJSON contains the JSON metadata for the struct [CustomerTaxID]
type customerTaxIDJSON struct {
	Country     apijson.Field
	Type        apijson.Field
	Value       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *CustomerTaxID) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r customerTaxIDJSON) RawJSON() string {
	return r.raw
}

type CustomerTaxIDCountry string

const (
	CustomerTaxIDCountryAd CustomerTaxIDCountry = "AD"
	CustomerTaxIDCountryAe CustomerTaxIDCountry = "AE"
	CustomerTaxIDCountryAr CustomerTaxIDCountry = "AR"
	CustomerTaxIDCountryAt CustomerTaxIDCountry = "AT"
	CustomerTaxIDCountryAu CustomerTaxIDCountry = "AU"
	CustomerTaxIDCountryBe CustomerTaxIDCountry = "BE"
	CustomerTaxIDCountryBg CustomerTaxIDCountry = "BG"
	CustomerTaxIDCountryBh CustomerTaxIDCountry = "BH"
	CustomerTaxIDCountryBo CustomerTaxIDCountry = "BO"
	CustomerTaxIDCountryBr CustomerTaxIDCountry = "BR"
	CustomerTaxIDCountryCa CustomerTaxIDCountry = "CA"
	CustomerTaxIDCountryCh CustomerTaxIDCountry = "CH"
	CustomerTaxIDCountryCl CustomerTaxIDCountry = "CL"
	CustomerTaxIDCountryCn CustomerTaxIDCountry = "CN"
	CustomerTaxIDCountryCo CustomerTaxIDCountry = "CO"
	CustomerTaxIDCountryCr CustomerTaxIDCountry = "CR"
	CustomerTaxIDCountryCy CustomerTaxIDCountry = "CY"
	CustomerTaxIDCountryCz CustomerTaxIDCountry = "CZ"
	CustomerTaxIDCountryDe CustomerTaxIDCountry = "DE"
	CustomerTaxIDCountryDk CustomerTaxIDCountry = "DK"
	CustomerTaxIDCountryEe CustomerTaxIDCountry = "EE"
	CustomerTaxIDCountryDo CustomerTaxIDCountry = "DO"
	CustomerTaxIDCountryEc CustomerTaxIDCountry = "EC"
	CustomerTaxIDCountryEg CustomerTaxIDCountry = "EG"
	CustomerTaxIDCountryEs CustomerTaxIDCountry = "ES"
	CustomerTaxIDCountryEu CustomerTaxIDCountry = "EU"
	CustomerTaxIDCountryFi CustomerTaxIDCountry = "FI"
	CustomerTaxIDCountryFr CustomerTaxIDCountry = "FR"
	CustomerTaxIDCountryGB CustomerTaxIDCountry = "GB"
	CustomerTaxIDCountryGe CustomerTaxIDCountry = "GE"
	CustomerTaxIDCountryGr CustomerTaxIDCountry = "GR"
	CustomerTaxIDCountryHk CustomerTaxIDCountry = "HK"
	CustomerTaxIDCountryHr CustomerTaxIDCountry = "HR"
	CustomerTaxIDCountryHu CustomerTaxIDCountry = "HU"
	CustomerTaxIDCountryID CustomerTaxIDCountry = "ID"
	CustomerTaxIDCountryIe CustomerTaxIDCountry = "IE"
	CustomerTaxIDCountryIl CustomerTaxIDCountry = "IL"
	CustomerTaxIDCountryIn CustomerTaxIDCountry = "IN"
	CustomerTaxIDCountryIs CustomerTaxIDCountry = "IS"
	CustomerTaxIDCountryIt CustomerTaxIDCountry = "IT"
	CustomerTaxIDCountryJp CustomerTaxIDCountry = "JP"
	CustomerTaxIDCountryKe CustomerTaxIDCountry = "KE"
	CustomerTaxIDCountryKr CustomerTaxIDCountry = "KR"
	CustomerTaxIDCountryKz CustomerTaxIDCountry = "KZ"
	CustomerTaxIDCountryLi CustomerTaxIDCountry = "LI"
	CustomerTaxIDCountryLt CustomerTaxIDCountry = "LT"
	CustomerTaxIDCountryLu CustomerTaxIDCountry = "LU"
	CustomerTaxIDCountryLv CustomerTaxIDCountry = "LV"
	CustomerTaxIDCountryMt CustomerTaxIDCountry = "MT"
	CustomerTaxIDCountryMx CustomerTaxIDCountry = "MX"
	CustomerTaxIDCountryMy CustomerTaxIDCountry = "MY"
	CustomerTaxIDCountryNg CustomerTaxIDCountry = "NG"
	CustomerTaxIDCountryNl CustomerTaxIDCountry = "NL"
	CustomerTaxIDCountryNo CustomerTaxIDCountry = "NO"
	CustomerTaxIDCountryNz CustomerTaxIDCountry = "NZ"
	CustomerTaxIDCountryOm CustomerTaxIDCountry = "OM"
	CustomerTaxIDCountryPe CustomerTaxIDCountry = "PE"
	CustomerTaxIDCountryPh CustomerTaxIDCountry = "PH"
	CustomerTaxIDCountryPl CustomerTaxIDCountry = "PL"
	CustomerTaxIDCountryPt CustomerTaxIDCountry = "PT"
	CustomerTaxIDCountryRo CustomerTaxIDCountry = "RO"
	CustomerTaxIDCountryRs CustomerTaxIDCountry = "RS"
	CustomerTaxIDCountryRu CustomerTaxIDCountry = "RU"
	CustomerTaxIDCountrySa CustomerTaxIDCountry = "SA"
	CustomerTaxIDCountrySe CustomerTaxIDCountry = "SE"
	CustomerTaxIDCountrySg CustomerTaxIDCountry = "SG"
	CustomerTaxIDCountrySi CustomerTaxIDCountry = "SI"
	CustomerTaxIDCountrySk CustomerTaxIDCountry = "SK"
	CustomerTaxIDCountrySv CustomerTaxIDCountry = "SV"
	CustomerTaxIDCountryTh CustomerTaxIDCountry = "TH"
	CustomerTaxIDCountryTr CustomerTaxIDCountry = "TR"
	CustomerTaxIDCountryTw CustomerTaxIDCountry = "TW"
	CustomerTaxIDCountryUa CustomerTaxIDCountry = "UA"
	CustomerTaxIDCountryUs CustomerTaxIDCountry = "US"
	CustomerTaxIDCountryUy CustomerTaxIDCountry = "UY"
	CustomerTaxIDCountryVe CustomerTaxIDCountry = "VE"
	CustomerTaxIDCountryVn CustomerTaxIDCountry = "VN"
	CustomerTaxIDCountryZa CustomerTaxIDCountry = "ZA"
)

func (r CustomerTaxIDCountry) IsKnown() bool {
	switch r {
	case CustomerTaxIDCountryAd, CustomerTaxIDCountryAe, CustomerTaxIDCountryAr, CustomerTaxIDCountryAt, CustomerTaxIDCountryAu, CustomerTaxIDCountryBe, CustomerTaxIDCountryBg, CustomerTaxIDCountryBh, CustomerTaxIDCountryBo, CustomerTaxIDCountryBr, CustomerTaxIDCountryCa, CustomerTaxIDCountryCh, CustomerTaxIDCountryCl, CustomerTaxIDCountryCn, CustomerTaxIDCountryCo, CustomerTaxIDCountryCr, CustomerTaxIDCountryCy, CustomerTaxIDCountryCz, CustomerTaxIDCountryDe, CustomerTaxIDCountryDk, CustomerTaxIDCountryEe, CustomerTaxIDCountryDo, CustomerTaxIDCountryEc, CustomerTaxIDCountryEg, CustomerTaxIDCountryEs, CustomerTaxIDCountryEu, CustomerTaxIDCountryFi, CustomerTaxIDCountryFr, CustomerTaxIDCountryGB, CustomerTaxIDCountryGe, CustomerTaxIDCountryGr, CustomerTaxIDCountryHk, CustomerTaxIDCountryHr, CustomerTaxIDCountryHu, CustomerTaxIDCountryID, CustomerTaxIDCountryIe, CustomerTaxIDCountryIl, CustomerTaxIDCountryIn, CustomerTaxIDCountryIs, CustomerTaxIDCountryIt, CustomerTaxIDCountryJp, CustomerTaxIDCountryKe, CustomerTaxIDCountryKr, CustomerTaxIDCountryKz, CustomerTaxIDCountryLi, CustomerTaxIDCountryLt, CustomerTaxIDCountryLu, CustomerTaxIDCountryLv, CustomerTaxIDCountryMt, CustomerTaxIDCountryMx, CustomerTaxIDCountryMy, CustomerTaxIDCountryNg, CustomerTaxIDCountryNl, CustomerTaxIDCountryNo, CustomerTaxIDCountryNz, CustomerTaxIDCountryOm, CustomerTaxIDCountryPe, CustomerTaxIDCountryPh, CustomerTaxIDCountryPl, CustomerTaxIDCountryPt, CustomerTaxIDCountryRo, CustomerTaxIDCountryRs, CustomerTaxIDCountryRu, CustomerTaxIDCountrySa, CustomerTaxIDCountrySe, CustomerTaxIDCountrySg, CustomerTaxIDCountrySi, CustomerTaxIDCountrySk, CustomerTaxIDCountrySv, CustomerTaxIDCountryTh, CustomerTaxIDCountryTr, CustomerTaxIDCountryTw, CustomerTaxIDCountryUa, CustomerTaxIDCountryUs, CustomerTaxIDCountryUy, CustomerTaxIDCountryVe, CustomerTaxIDCountryVn, CustomerTaxIDCountryZa:
		return true
	}
	return false
}

type CustomerTaxIDType string

const (
	CustomerTaxIDTypeAdNrt    CustomerTaxIDType = "ad_nrt"
	CustomerTaxIDTypeAeTrn    CustomerTaxIDType = "ae_trn"
	CustomerTaxIDTypeArCuit   CustomerTaxIDType = "ar_cuit"
	CustomerTaxIDTypeEuVat    CustomerTaxIDType = "eu_vat"
	CustomerTaxIDTypeAuAbn    CustomerTaxIDType = "au_abn"
	CustomerTaxIDTypeAuArn    CustomerTaxIDType = "au_arn"
	CustomerTaxIDTypeBgUic    CustomerTaxIDType = "bg_uic"
	CustomerTaxIDTypeBhVat    CustomerTaxIDType = "bh_vat"
	CustomerTaxIDTypeBoTin    CustomerTaxIDType = "bo_tin"
	CustomerTaxIDTypeBrCnpj   CustomerTaxIDType = "br_cnpj"
	CustomerTaxIDTypeBrCpf    CustomerTaxIDType = "br_cpf"
	CustomerTaxIDTypeCaBn     CustomerTaxIDType = "ca_bn"
	CustomerTaxIDTypeCaGstHst CustomerTaxIDType = "ca_gst_hst"
	CustomerTaxIDTypeCaPstBc  CustomerTaxIDType = "ca_pst_bc"
	CustomerTaxIDTypeCaPstMB  CustomerTaxIDType = "ca_pst_mb"
	CustomerTaxIDTypeCaPstSk  CustomerTaxIDType = "ca_pst_sk"
	CustomerTaxIDTypeCaQst    CustomerTaxIDType = "ca_qst"
	CustomerTaxIDTypeChVat    CustomerTaxIDType = "ch_vat"
	CustomerTaxIDTypeClTin    CustomerTaxIDType = "cl_tin"
	CustomerTaxIDTypeCnTin    CustomerTaxIDType = "cn_tin"
	CustomerTaxIDTypeCoNit    CustomerTaxIDType = "co_nit"
	CustomerTaxIDTypeCrTin    CustomerTaxIDType = "cr_tin"
	CustomerTaxIDTypeDoRcn    CustomerTaxIDType = "do_rcn"
	CustomerTaxIDTypeEcRuc    CustomerTaxIDType = "ec_ruc"
	CustomerTaxIDTypeEgTin    CustomerTaxIDType = "eg_tin"
	CustomerTaxIDTypeEsCif    CustomerTaxIDType = "es_cif"
	CustomerTaxIDTypeEuOssVat CustomerTaxIDType = "eu_oss_vat"
	CustomerTaxIDTypeGBVat    CustomerTaxIDType = "gb_vat"
	CustomerTaxIDTypeGeVat    CustomerTaxIDType = "ge_vat"
	CustomerTaxIDTypeHkBr     CustomerTaxIDType = "hk_br"
	CustomerTaxIDTypeHuTin    CustomerTaxIDType = "hu_tin"
	CustomerTaxIDTypeIDNpwp   CustomerTaxIDType = "id_npwp"
	CustomerTaxIDTypeIlVat    CustomerTaxIDType = "il_vat"
	CustomerTaxIDTypeInGst    CustomerTaxIDType = "in_gst"
	CustomerTaxIDTypeIsVat    CustomerTaxIDType = "is_vat"
	CustomerTaxIDTypeJpCn     CustomerTaxIDType = "jp_cn"
	CustomerTaxIDTypeJpRn     CustomerTaxIDType = "jp_rn"
	CustomerTaxIDTypeJpTrn    CustomerTaxIDType = "jp_trn"
	CustomerTaxIDTypeKePin    CustomerTaxIDType = "ke_pin"
	CustomerTaxIDTypeKrBrn    CustomerTaxIDType = "kr_brn"
	CustomerTaxIDTypeKzBin    CustomerTaxIDType = "kz_bin"
	CustomerTaxIDTypeLiUid    CustomerTaxIDType = "li_uid"
	CustomerTaxIDTypeMxRfc    CustomerTaxIDType = "mx_rfc"
	CustomerTaxIDTypeMyFrp    CustomerTaxIDType = "my_frp"
	CustomerTaxIDTypeMyItn    CustomerTaxIDType = "my_itn"
	CustomerTaxIDTypeMySst    CustomerTaxIDType = "my_sst"
	CustomerTaxIDTypeNgTin    CustomerTaxIDType = "ng_tin"
	CustomerTaxIDTypeNoVat    CustomerTaxIDType = "no_vat"
	CustomerTaxIDTypeNoVoec   CustomerTaxIDType = "no_voec"
	CustomerTaxIDTypeNzGst    CustomerTaxIDType = "nz_gst"
	CustomerTaxIDTypeOmVat    CustomerTaxIDType = "om_vat"
	CustomerTaxIDTypePeRuc    CustomerTaxIDType = "pe_ruc"
	CustomerTaxIDTypePhTin    CustomerTaxIDType = "ph_tin"
	CustomerTaxIDTypeRoTin    CustomerTaxIDType = "ro_tin"
	CustomerTaxIDTypeRsPib    CustomerTaxIDType = "rs_pib"
	CustomerTaxIDTypeRuInn    CustomerTaxIDType = "ru_inn"
	CustomerTaxIDTypeRuKpp    CustomerTaxIDType = "ru_kpp"
	CustomerTaxIDTypeSaVat    CustomerTaxIDType = "sa_vat"
	CustomerTaxIDTypeSgGst    CustomerTaxIDType = "sg_gst"
	CustomerTaxIDTypeSgUen    CustomerTaxIDType = "sg_uen"
	CustomerTaxIDTypeSiTin    CustomerTaxIDType = "si_tin"
	CustomerTaxIDTypeSvNit    CustomerTaxIDType = "sv_nit"
	CustomerTaxIDTypeThVat    CustomerTaxIDType = "th_vat"
	CustomerTaxIDTypeTrTin    CustomerTaxIDType = "tr_tin"
	CustomerTaxIDTypeTwVat    CustomerTaxIDType = "tw_vat"
	CustomerTaxIDTypeUaVat    CustomerTaxIDType = "ua_vat"
	CustomerTaxIDTypeUsEin    CustomerTaxIDType = "us_ein"
	CustomerTaxIDTypeUyRuc    CustomerTaxIDType = "uy_ruc"
	CustomerTaxIDTypeVeRif    CustomerTaxIDType = "ve_rif"
	CustomerTaxIDTypeVnTin    CustomerTaxIDType = "vn_tin"
	CustomerTaxIDTypeZaVat    CustomerTaxIDType = "za_vat"
)

func (r CustomerTaxIDType) IsKnown() bool {
	switch r {
	case CustomerTaxIDTypeAdNrt, CustomerTaxIDTypeAeTrn, CustomerTaxIDTypeArCuit, CustomerTaxIDTypeEuVat, CustomerTaxIDTypeAuAbn, CustomerTaxIDTypeAuArn, CustomerTaxIDTypeBgUic, CustomerTaxIDTypeBhVat, CustomerTaxIDTypeBoTin, CustomerTaxIDTypeBrCnpj, CustomerTaxIDTypeBrCpf, CustomerTaxIDTypeCaBn, CustomerTaxIDTypeCaGstHst, CustomerTaxIDTypeCaPstBc, CustomerTaxIDTypeCaPstMB, CustomerTaxIDTypeCaPstSk, CustomerTaxIDTypeCaQst, CustomerTaxIDTypeChVat, CustomerTaxIDTypeClTin, CustomerTaxIDTypeCnTin, CustomerTaxIDTypeCoNit, CustomerTaxIDTypeCrTin, CustomerTaxIDTypeDoRcn, CustomerTaxIDTypeEcRuc, CustomerTaxIDTypeEgTin, CustomerTaxIDTypeEsCif, CustomerTaxIDTypeEuOssVat, CustomerTaxIDTypeGBVat, CustomerTaxIDTypeGeVat, CustomerTaxIDTypeHkBr, CustomerTaxIDTypeHuTin, CustomerTaxIDTypeIDNpwp, CustomerTaxIDTypeIlVat, CustomerTaxIDTypeInGst, CustomerTaxIDTypeIsVat, CustomerTaxIDTypeJpCn, CustomerTaxIDTypeJpRn, CustomerTaxIDTypeJpTrn, CustomerTaxIDTypeKePin, CustomerTaxIDTypeKrBrn, CustomerTaxIDTypeKzBin, CustomerTaxIDTypeLiUid, CustomerTaxIDTypeMxRfc, CustomerTaxIDTypeMyFrp, CustomerTaxIDTypeMyItn, CustomerTaxIDTypeMySst, CustomerTaxIDTypeNgTin, CustomerTaxIDTypeNoVat, CustomerTaxIDTypeNoVoec, CustomerTaxIDTypeNzGst, CustomerTaxIDTypeOmVat, CustomerTaxIDTypePeRuc, CustomerTaxIDTypePhTin, CustomerTaxIDTypeRoTin, CustomerTaxIDTypeRsPib, CustomerTaxIDTypeRuInn, CustomerTaxIDTypeRuKpp, CustomerTaxIDTypeSaVat, CustomerTaxIDTypeSgGst, CustomerTaxIDTypeSgUen, CustomerTaxIDTypeSiTin, CustomerTaxIDTypeSvNit, CustomerTaxIDTypeThVat, CustomerTaxIDTypeTrTin, CustomerTaxIDTypeTwVat, CustomerTaxIDTypeUaVat, CustomerTaxIDTypeUsEin, CustomerTaxIDTypeUyRuc, CustomerTaxIDTypeVeRif, CustomerTaxIDTypeVnTin, CustomerTaxIDTypeZaVat:
		return true
	}
	return false
}

// Tax IDs are commonly required to be displayed on customer invoices, which are
// added to the headers of invoices.
//
// ### Supported Tax ID Countries and Types
//
// | Country              | Type         | Description                                                                                             |
// | -------------------- | ------------ | ------------------------------------------------------------------------------------------------------- |
// | Andorra              | `ad_nrt`     | Andorran NRT Number                                                                                     |
// | Argentina            | `ar_cuit`    | Argentinian Tax ID Number                                                                               |
// | Australia            | `au_abn`     | Australian Business Number (AU ABN)                                                                     |
// | Australia            | `au_arn`     | Australian Taxation Office Reference Number                                                             |
// | Austria              | `eu_vat`     | European VAT Number                                                                                     |
// | Bahrain              | `bh_vat`     | Bahraini VAT Number                                                                                     |
// | Belgium              | `eu_vat`     | European VAT Number                                                                                     |
// | Bolivia              | `bo_tin`     | Bolivian Tax ID                                                                                         |
// | Brazil               | `br_cnpj`    | Brazilian CNPJ Number                                                                                   |
// | Brazil               | `br_cpf`     | Brazilian CPF Number                                                                                    |
// | Bulgaria             | `bg_uic`     | Bulgaria Unified Identification Code                                                                    |
// | Bulgaria             | `eu_vat`     | European VAT Number                                                                                     |
// | Canada               | `ca_bn`      | Canadian BN                                                                                             |
// | Canada               | `ca_gst_hst` | Canadian GST/HST Number                                                                                 |
// | Canada               | `ca_pst_bc`  | Canadian PST Number (British Columbia)                                                                  |
// | Canada               | `ca_pst_mb`  | Canadian PST Number (Manitoba)                                                                          |
// | Canada               | `ca_pst_sk`  | Canadian PST Number (Saskatchewan)                                                                      |
// | Canada               | `ca_qst`     | Canadian QST Number (Québec)                                                                            |
// | Chile                | `cl_tin`     | Chilean TIN                                                                                             |
// | China                | `cn_tin`     | Chinese Tax ID                                                                                          |
// | Colombia             | `co_nit`     | Colombian NIT Number                                                                                    |
// | Costa Rica           | `cr_tin`     | Costa Rican Tax ID                                                                                      |
// | Croatia              | `eu_vat`     | European VAT Number                                                                                     |
// | Cyprus               | `eu_vat`     | European VAT Number                                                                                     |
// | Czech Republic       | `eu_vat`     | European VAT Number                                                                                     |
// | Denmark              | `eu_vat`     | European VAT Number                                                                                     |
// | Dominican Republic   | `do_rcn`     | Dominican RCN Number                                                                                    |
// | Ecuador              | `ec_ruc`     | Ecuadorian RUC Number                                                                                   |
// | Egypt                | `eg_tin`     | Egyptian Tax Identification Number                                                                      |
// | El Salvador          | `sv_nit`     | El Salvadorian NIT Number                                                                               |
// | Estonia              | `eu_vat`     | European VAT Number                                                                                     |
// | EU                   | `eu_oss_vat` | European One Stop Shop VAT Number for non-Union scheme                                                  |
// | Finland              | `eu_vat`     | European VAT Number                                                                                     |
// | France               | `eu_vat`     | European VAT Number                                                                                     |
// | Georgia              | `ge_vat`     | Georgian VAT                                                                                            |
// | Germany              | `eu_vat`     | European VAT Number                                                                                     |
// | Greece               | `eu_vat`     | European VAT Number                                                                                     |
// | Hong Kong            | `hk_br`      | Hong Kong BR Number                                                                                     |
// | Hungary              | `eu_vat`     | European VAT Number                                                                                     |
// | Hungary              | `hu_tin`     | Hungary Tax Number (adószám)                                                                            |
// | Iceland              | `is_vat`     | Icelandic VAT                                                                                           |
// | India                | `in_gst`     | Indian GST Number                                                                                       |
// | Indonesia            | `id_npwp`    | Indonesian NPWP Number                                                                                  |
// | Ireland              | `eu_vat`     | European VAT Number                                                                                     |
// | Israel               | `il_vat`     | Israel VAT                                                                                              |
// | Italy                | `eu_vat`     | European VAT Number                                                                                     |
// | Japan                | `jp_cn`      | Japanese Corporate Number (_Hōjin Bangō_)                                                               |
// | Japan                | `jp_rn`      | Japanese Registered Foreign Businesses' Registration Number (_Tōroku Kokugai Jigyōsha no Tōroku Bangō_) |
// | Japan                | `jp_trn`     | Japanese Tax Registration Number (_Tōroku Bangō_)                                                       |
// | Kazakhstan           | `kz_bin`     | Kazakhstani Business Identification Number                                                              |
// | Kenya                | `ke_pin`     | Kenya Revenue Authority Personal Identification Number                                                  |
// | Latvia               | `eu_vat`     | European VAT Number                                                                                     |
// | Liechtenstein        | `li_uid`     | Liechtensteinian UID Number                                                                             |
// | Lithuania            | `eu_vat`     | European VAT Number                                                                                     |
// | Luxembourg           | `eu_vat`     | European VAT Number                                                                                     |
// | Malaysia             | `my_frp`     | Malaysian FRP Number                                                                                    |
// | Malaysia             | `my_itn`     | Malaysian ITN                                                                                           |
// | Malaysia             | `my_sst`     | Malaysian SST Number                                                                                    |
// | Malta                | `eu_vat `    | European VAT Number                                                                                     |
// | Mexico               | `mx_rfc`     | Mexican RFC Number                                                                                      |
// | Netherlands          | `eu_vat`     | European VAT Number                                                                                     |
// | New Zealand          | `nz_gst`     | New Zealand GST Number                                                                                  |
// | Nigeria              | `ng_tin`     | Nigerian Tax Identification Number                                                                      |
// | Norway               | `no_vat`     | Norwegian VAT Number                                                                                    |
// | Norway               | `no_voec`    | Norwegian VAT on e-commerce Number                                                                      |
// | Oman                 | `om_vat`     | Omani VAT Number                                                                                        |
// | Peru                 | `pe_ruc`     | Peruvian RUC Number                                                                                     |
// | Philippines          | `ph_tin `    | Philippines Tax Identification Number                                                                   |
// | Poland               | `eu_vat`     | European VAT Number                                                                                     |
// | Portugal             | `eu_vat`     | European VAT Number                                                                                     |
// | Romania              | `eu_vat`     | European VAT Number                                                                                     |
// | Romania              | `ro_tin`     | Romanian Tax ID Number                                                                                  |
// | Russia               | `ru_inn`     | Russian INN                                                                                             |
// | Russia               | `ru_kpp`     | Russian KPP                                                                                             |
// | Saudi Arabia         | `sa_vat`     | Saudi Arabia VAT                                                                                        |
// | Serbia               | `rs_pib`     | Serbian PIB Number                                                                                      |
// | Singapore            | `sg_gst`     | Singaporean GST                                                                                         |
// | Singapore            | `sg_uen`     | Singaporean UEN                                                                                         |
// | Slovakia             | `eu_vat`     | European VAT Number                                                                                     |
// | Slovenia             | `eu_vat`     | European VAT Number                                                                                     |
// | Slovenia             | `si_tin`     | Slovenia Tax Number (davčna številka)                                                                   |
// | South Africa         | `za_vat`     | South African VAT Number                                                                                |
// | South Korea          | `kr_brn`     | Korean BRN                                                                                              |
// | Spain                | `es_cif`     | Spanish NIF Number (previously Spanish CIF Number)                                                      |
// | Spain                | `eu_vat`     | European VAT Number                                                                                     |
// | Sweden               | `eu_vat`     | European VAT Number                                                                                     |
// | Switzerland          | `ch_vat`     | Switzerland VAT Number                                                                                  |
// | Taiwan               | `tw_vat`     | Taiwanese VAT                                                                                           |
// | Thailand             | `th_vat`     | Thai VAT                                                                                                |
// | Turkey               | `tr_tin`     | Turkish Tax Identification Number                                                                       |
// | Ukraine              | `ua_vat`     | Ukrainian VAT                                                                                           |
// | United Arab Emirates | `ae_trn`     | United Arab Emirates TRN                                                                                |
// | United Kingdom       | `eu_vat`     | Northern Ireland VAT Number                                                                             |
// | United Kingdom       | `gb_vat`     | United Kingdom VAT Number                                                                               |
// | United States        | `us_ein`     | United States EIN                                                                                       |
// | Uruguay              | `uy_ruc`     | Uruguayan RUC Number                                                                                    |
// | Venezuela            | `ve_rif`     | Venezuelan RIF Number                                                                                   |
// | Vietnam              | `vn_tin`     | Vietnamese Tax ID Number                                                                                |
type CustomerTaxIDParam struct {
	Country param.Field[CustomerTaxIDCountry] `json:"country,required"`
	Type    param.Field[CustomerTaxIDType]    `json:"type,required"`
	Value   param.Field[string]               `json:"value,required"`
}

func (r CustomerTaxIDParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type DimensionalPriceConfiguration struct {
	DimensionValues         []string                          `json:"dimension_values,required"`
	DimensionalPriceGroupID string                            `json:"dimensional_price_group_id,required"`
	JSON                    dimensionalPriceConfigurationJSON `json:"-"`
}

// dimensionalPriceConfigurationJSON contains the JSON metadata for the struct
// [DimensionalPriceConfiguration]
type dimensionalPriceConfigurationJSON struct {
	DimensionValues         apijson.Field
	DimensionalPriceGroupID apijson.Field
	raw                     string
	ExtraFields             map[string]apijson.Field
}

func (r *DimensionalPriceConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r dimensionalPriceConfigurationJSON) RawJSON() string {
	return r.raw
}

type Discount struct {
	DiscountType DiscountDiscountType `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids"`
	// This field can have the runtime type of [[]TransformPriceFilter].
	Filters interface{} `json:"filters"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	Reason             string  `json:"reason,nullable"`
	// Only available if discount_type is `trial`
	TrialAmountDiscount string `json:"trial_amount_discount,nullable"`
	// Only available if discount_type is `trial`
	TrialPercentageDiscount float64 `json:"trial_percentage_discount,nullable"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64      `json:"usage_discount"`
	JSON          discountJSON `json:"-"`
	union         DiscountUnion
}

// discountJSON contains the JSON metadata for the struct [Discount]
type discountJSON struct {
	DiscountType            apijson.Field
	AmountDiscount          apijson.Field
	AppliesToPriceIDs       apijson.Field
	Filters                 apijson.Field
	PercentageDiscount      apijson.Field
	Reason                  apijson.Field
	TrialAmountDiscount     apijson.Field
	TrialPercentageDiscount apijson.Field
	UsageDiscount           apijson.Field
	raw                     string
	ExtraFields             map[string]apijson.Field
}

func (r discountJSON) RawJSON() string {
	return r.raw
}

func (r *Discount) UnmarshalJSON(data []byte) (err error) {
	*r = Discount{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [DiscountUnion] interface which you can cast to the specific
// types for more type safety.
//
// Possible runtime types of the union are [PercentageDiscount], [TrialDiscount],
// [UsageDiscount], [AmountDiscount].
func (r Discount) AsUnion() DiscountUnion {
	return r.union
}

// Union satisfied by [PercentageDiscount], [TrialDiscount], [UsageDiscount] or
// [AmountDiscount].
type DiscountUnion interface {
	ImplementsDiscount()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*DiscountUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PercentageDiscount{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(TrialDiscount{}),
			DiscriminatorValue: "trial",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(UsageDiscount{}),
			DiscriminatorValue: "usage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(AmountDiscount{}),
			DiscriminatorValue: "amount",
		},
	)
}

type DiscountDiscountType string

const (
	DiscountDiscountTypePercentage DiscountDiscountType = "percentage"
	DiscountDiscountTypeTrial      DiscountDiscountType = "trial"
	DiscountDiscountTypeUsage      DiscountDiscountType = "usage"
	DiscountDiscountTypeAmount     DiscountDiscountType = "amount"
)

func (r DiscountDiscountType) IsKnown() bool {
	switch r {
	case DiscountDiscountTypePercentage, DiscountDiscountTypeTrial, DiscountDiscountTypeUsage, DiscountDiscountTypeAmount:
		return true
	}
	return false
}

type DiscountParam struct {
	DiscountType param.Field[DiscountDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount    param.Field[string]      `json:"amount_discount"`
	AppliesToPriceIDs param.Field[interface{}] `json:"applies_to_price_ids"`
	Filters           param.Field[interface{}] `json:"filters"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	Reason             param.Field[string]  `json:"reason"`
	// Only available if discount_type is `trial`
	TrialAmountDiscount param.Field[string] `json:"trial_amount_discount"`
	// Only available if discount_type is `trial`
	TrialPercentageDiscount param.Field[float64] `json:"trial_percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r DiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r DiscountParam) ImplementsDiscountUnionParam() {}

// Satisfied by [shared.PercentageDiscountParam], [shared.TrialDiscountParam],
// [shared.UsageDiscountParam], [shared.AmountDiscountParam], [DiscountParam].
type DiscountUnionParam interface {
	ImplementsDiscountUnionParam()
}

type FixedFeeQuantityScheduleEntry struct {
	EndDate   time.Time                         `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                            `json:"price_id,required"`
	Quantity  float64                           `json:"quantity,required"`
	StartDate time.Time                         `json:"start_date,required" format:"date-time"`
	JSON      fixedFeeQuantityScheduleEntryJSON `json:"-"`
}

// fixedFeeQuantityScheduleEntryJSON contains the JSON metadata for the struct
// [FixedFeeQuantityScheduleEntry]
type fixedFeeQuantityScheduleEntryJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *FixedFeeQuantityScheduleEntry) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r fixedFeeQuantityScheduleEntryJSON) RawJSON() string {
	return r.raw
}

type FixedFeeQuantityTransition struct {
	EffectiveDate time.Time                      `json:"effective_date,required" format:"date-time"`
	PriceID       string                         `json:"price_id,required"`
	Quantity      int64                          `json:"quantity,required"`
	JSON          fixedFeeQuantityTransitionJSON `json:"-"`
}

// fixedFeeQuantityTransitionJSON contains the JSON metadata for the struct
// [FixedFeeQuantityTransition]
type fixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *FixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r fixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

// An [`Invoice`](/core-concepts#invoice) is a fundamental billing entity,
// representing the request for payment for a single subscription. This includes a
// set of line items, which correspond to prices in the subscription's plan and can
// represent fixed recurring fees or usage-based fees. They are generated at the
// end of a billing period, or as the result of an action, such as a cancellation.
type Invoice struct {
	ID string `json:"id,required"`
	// This is the final amount required to be charged to the customer and reflects the
	// application of the customer balance to the `total` of the invoice.
	AmountDue      string                `json:"amount_due,required"`
	AutoCollection InvoiceAutoCollection `json:"auto_collection,required"`
	BillingAddress Address               `json:"billing_address,required,nullable"`
	// The creation time of the resource in Orb.
	CreatedAt time.Time `json:"created_at,required" format:"date-time"`
	// A list of credit notes associated with the invoice
	CreditNotes []InvoiceCreditNote `json:"credit_notes,required"`
	// An ISO 4217 currency string or `credits`
	Currency                    string                              `json:"currency,required"`
	Customer                    CustomerMinified                    `json:"customer,required"`
	CustomerBalanceTransactions []InvoiceCustomerBalanceTransaction `json:"customer_balance_transactions,required"`
	// Tax IDs are commonly required to be displayed on customer invoices, which are
	// added to the headers of invoices.
	//
	// ### Supported Tax ID Countries and Types
	//
	// | Country              | Type         | Description                                                                                             |
	// | -------------------- | ------------ | ------------------------------------------------------------------------------------------------------- |
	// | Andorra              | `ad_nrt`     | Andorran NRT Number                                                                                     |
	// | Argentina            | `ar_cuit`    | Argentinian Tax ID Number                                                                               |
	// | Australia            | `au_abn`     | Australian Business Number (AU ABN)                                                                     |
	// | Australia            | `au_arn`     | Australian Taxation Office Reference Number                                                             |
	// | Austria              | `eu_vat`     | European VAT Number                                                                                     |
	// | Bahrain              | `bh_vat`     | Bahraini VAT Number                                                                                     |
	// | Belgium              | `eu_vat`     | European VAT Number                                                                                     |
	// | Bolivia              | `bo_tin`     | Bolivian Tax ID                                                                                         |
	// | Brazil               | `br_cnpj`    | Brazilian CNPJ Number                                                                                   |
	// | Brazil               | `br_cpf`     | Brazilian CPF Number                                                                                    |
	// | Bulgaria             | `bg_uic`     | Bulgaria Unified Identification Code                                                                    |
	// | Bulgaria             | `eu_vat`     | European VAT Number                                                                                     |
	// | Canada               | `ca_bn`      | Canadian BN                                                                                             |
	// | Canada               | `ca_gst_hst` | Canadian GST/HST Number                                                                                 |
	// | Canada               | `ca_pst_bc`  | Canadian PST Number (British Columbia)                                                                  |
	// | Canada               | `ca_pst_mb`  | Canadian PST Number (Manitoba)                                                                          |
	// | Canada               | `ca_pst_sk`  | Canadian PST Number (Saskatchewan)                                                                      |
	// | Canada               | `ca_qst`     | Canadian QST Number (Québec)                                                                            |
	// | Chile                | `cl_tin`     | Chilean TIN                                                                                             |
	// | China                | `cn_tin`     | Chinese Tax ID                                                                                          |
	// | Colombia             | `co_nit`     | Colombian NIT Number                                                                                    |
	// | Costa Rica           | `cr_tin`     | Costa Rican Tax ID                                                                                      |
	// | Croatia              | `eu_vat`     | European VAT Number                                                                                     |
	// | Cyprus               | `eu_vat`     | European VAT Number                                                                                     |
	// | Czech Republic       | `eu_vat`     | European VAT Number                                                                                     |
	// | Denmark              | `eu_vat`     | European VAT Number                                                                                     |
	// | Dominican Republic   | `do_rcn`     | Dominican RCN Number                                                                                    |
	// | Ecuador              | `ec_ruc`     | Ecuadorian RUC Number                                                                                   |
	// | Egypt                | `eg_tin`     | Egyptian Tax Identification Number                                                                      |
	// | El Salvador          | `sv_nit`     | El Salvadorian NIT Number                                                                               |
	// | Estonia              | `eu_vat`     | European VAT Number                                                                                     |
	// | EU                   | `eu_oss_vat` | European One Stop Shop VAT Number for non-Union scheme                                                  |
	// | Finland              | `eu_vat`     | European VAT Number                                                                                     |
	// | France               | `eu_vat`     | European VAT Number                                                                                     |
	// | Georgia              | `ge_vat`     | Georgian VAT                                                                                            |
	// | Germany              | `eu_vat`     | European VAT Number                                                                                     |
	// | Greece               | `eu_vat`     | European VAT Number                                                                                     |
	// | Hong Kong            | `hk_br`      | Hong Kong BR Number                                                                                     |
	// | Hungary              | `eu_vat`     | European VAT Number                                                                                     |
	// | Hungary              | `hu_tin`     | Hungary Tax Number (adószám)                                                                            |
	// | Iceland              | `is_vat`     | Icelandic VAT                                                                                           |
	// | India                | `in_gst`     | Indian GST Number                                                                                       |
	// | Indonesia            | `id_npwp`    | Indonesian NPWP Number                                                                                  |
	// | Ireland              | `eu_vat`     | European VAT Number                                                                                     |
	// | Israel               | `il_vat`     | Israel VAT                                                                                              |
	// | Italy                | `eu_vat`     | European VAT Number                                                                                     |
	// | Japan                | `jp_cn`      | Japanese Corporate Number (_Hōjin Bangō_)                                                               |
	// | Japan                | `jp_rn`      | Japanese Registered Foreign Businesses' Registration Number (_Tōroku Kokugai Jigyōsha no Tōroku Bangō_) |
	// | Japan                | `jp_trn`     | Japanese Tax Registration Number (_Tōroku Bangō_)                                                       |
	// | Kazakhstan           | `kz_bin`     | Kazakhstani Business Identification Number                                                              |
	// | Kenya                | `ke_pin`     | Kenya Revenue Authority Personal Identification Number                                                  |
	// | Latvia               | `eu_vat`     | European VAT Number                                                                                     |
	// | Liechtenstein        | `li_uid`     | Liechtensteinian UID Number                                                                             |
	// | Lithuania            | `eu_vat`     | European VAT Number                                                                                     |
	// | Luxembourg           | `eu_vat`     | European VAT Number                                                                                     |
	// | Malaysia             | `my_frp`     | Malaysian FRP Number                                                                                    |
	// | Malaysia             | `my_itn`     | Malaysian ITN                                                                                           |
	// | Malaysia             | `my_sst`     | Malaysian SST Number                                                                                    |
	// | Malta                | `eu_vat `    | European VAT Number                                                                                     |
	// | Mexico               | `mx_rfc`     | Mexican RFC Number                                                                                      |
	// | Netherlands          | `eu_vat`     | European VAT Number                                                                                     |
	// | New Zealand          | `nz_gst`     | New Zealand GST Number                                                                                  |
	// | Nigeria              | `ng_tin`     | Nigerian Tax Identification Number                                                                      |
	// | Norway               | `no_vat`     | Norwegian VAT Number                                                                                    |
	// | Norway               | `no_voec`    | Norwegian VAT on e-commerce Number                                                                      |
	// | Oman                 | `om_vat`     | Omani VAT Number                                                                                        |
	// | Peru                 | `pe_ruc`     | Peruvian RUC Number                                                                                     |
	// | Philippines          | `ph_tin `    | Philippines Tax Identification Number                                                                   |
	// | Poland               | `eu_vat`     | European VAT Number                                                                                     |
	// | Portugal             | `eu_vat`     | European VAT Number                                                                                     |
	// | Romania              | `eu_vat`     | European VAT Number                                                                                     |
	// | Romania              | `ro_tin`     | Romanian Tax ID Number                                                                                  |
	// | Russia               | `ru_inn`     | Russian INN                                                                                             |
	// | Russia               | `ru_kpp`     | Russian KPP                                                                                             |
	// | Saudi Arabia         | `sa_vat`     | Saudi Arabia VAT                                                                                        |
	// | Serbia               | `rs_pib`     | Serbian PIB Number                                                                                      |
	// | Singapore            | `sg_gst`     | Singaporean GST                                                                                         |
	// | Singapore            | `sg_uen`     | Singaporean UEN                                                                                         |
	// | Slovakia             | `eu_vat`     | European VAT Number                                                                                     |
	// | Slovenia             | `eu_vat`     | European VAT Number                                                                                     |
	// | Slovenia             | `si_tin`     | Slovenia Tax Number (davčna številka)                                                                   |
	// | South Africa         | `za_vat`     | South African VAT Number                                                                                |
	// | South Korea          | `kr_brn`     | Korean BRN                                                                                              |
	// | Spain                | `es_cif`     | Spanish NIF Number (previously Spanish CIF Number)                                                      |
	// | Spain                | `eu_vat`     | European VAT Number                                                                                     |
	// | Sweden               | `eu_vat`     | European VAT Number                                                                                     |
	// | Switzerland          | `ch_vat`     | Switzerland VAT Number                                                                                  |
	// | Taiwan               | `tw_vat`     | Taiwanese VAT                                                                                           |
	// | Thailand             | `th_vat`     | Thai VAT                                                                                                |
	// | Turkey               | `tr_tin`     | Turkish Tax Identification Number                                                                       |
	// | Ukraine              | `ua_vat`     | Ukrainian VAT                                                                                           |
	// | United Arab Emirates | `ae_trn`     | United Arab Emirates TRN                                                                                |
	// | United Kingdom       | `eu_vat`     | Northern Ireland VAT Number                                                                             |
	// | United Kingdom       | `gb_vat`     | United Kingdom VAT Number                                                                               |
	// | United States        | `us_ein`     | United States EIN                                                                                       |
	// | Uruguay              | `uy_ruc`     | Uruguayan RUC Number                                                                                    |
	// | Venezuela            | `ve_rif`     | Venezuelan RIF Number                                                                                   |
	// | Vietnam              | `vn_tin`     | Vietnamese Tax ID Number                                                                                |
	CustomerTaxID CustomerTaxID `json:"customer_tax_id,required,nullable"`
	// This field is deprecated in favor of `discounts`. If a `discounts` list is
	// provided, the first discount in the list will be returned. If the list is empty,
	// `None` will be returned.
	//
	// Deprecated: deprecated
	Discount  interface{}            `json:"discount,required"`
	Discounts []InvoiceLevelDiscount `json:"discounts,required"`
	// When the invoice payment is due. The due date is null if the invoice is not yet
	// finalized.
	DueDate time.Time `json:"due_date,required,nullable" format:"date-time"`
	// If the invoice has a status of `draft`, this will be the time that the invoice
	// will be eligible to be issued, otherwise it will be `null`. If `auto-issue` is
	// true, the invoice will automatically begin issuing at this time.
	EligibleToIssueAt time.Time `json:"eligible_to_issue_at,required,nullable" format:"date-time"`
	// A URL for the customer-facing invoice portal. This URL expires 30 days after the
	// invoice's due date, or 60 days after being re-generated through the UI.
	HostedInvoiceURL string `json:"hosted_invoice_url,required,nullable"`
	// The scheduled date of the invoice
	InvoiceDate time.Time `json:"invoice_date,required" format:"date-time"`
	// Automatically generated invoice number to help track and reconcile invoices.
	// Invoice numbers have a prefix such as `RFOBWG`. These can be sequential per
	// account or customer.
	InvoiceNumber string `json:"invoice_number,required"`
	// The link to download the PDF representation of the `Invoice`.
	InvoicePdf    string               `json:"invoice_pdf,required,nullable"`
	InvoiceSource InvoiceInvoiceSource `json:"invoice_source,required"`
	// If the invoice failed to issue, this will be the last time it failed to issue
	// (even if it is now in a different state.)
	IssueFailedAt time.Time `json:"issue_failed_at,required,nullable" format:"date-time"`
	// If the invoice has been issued, this will be the time it transitioned to
	// `issued` (even if it is now in a different state.)
	IssuedAt time.Time `json:"issued_at,required,nullable" format:"date-time"`
	// The breakdown of prices in this invoice.
	LineItems     []InvoiceLineItem `json:"line_items,required"`
	Maximum       Maximum           `json:"maximum,required,nullable"`
	MaximumAmount string            `json:"maximum_amount,required,nullable"`
	// Free-form text which is available on the invoice PDF and the Orb invoice portal.
	Memo string `json:"memo,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata      map[string]string `json:"metadata,required"`
	Minimum       Minimum           `json:"minimum,required,nullable"`
	MinimumAmount string            `json:"minimum_amount,required,nullable"`
	// If the invoice has a status of `paid`, this gives a timestamp when the invoice
	// was paid.
	PaidAt time.Time `json:"paid_at,required,nullable" format:"date-time"`
	// A list of payment attempts associated with the invoice
	PaymentAttempts []InvoicePaymentAttempt `json:"payment_attempts,required"`
	// If payment was attempted on this invoice but failed, this will be the time of
	// the most recent attempt.
	PaymentFailedAt time.Time `json:"payment_failed_at,required,nullable" format:"date-time"`
	// If payment was attempted on this invoice, this will be the start time of the
	// most recent attempt. This field is especially useful for delayed-notification
	// payment mechanisms (like bank transfers), where payment can take 3 days or more.
	PaymentStartedAt time.Time `json:"payment_started_at,required,nullable" format:"date-time"`
	// If the invoice is in draft, this timestamp will reflect when the invoice is
	// scheduled to be issued.
	ScheduledIssueAt time.Time            `json:"scheduled_issue_at,required,nullable" format:"date-time"`
	ShippingAddress  Address              `json:"shipping_address,required,nullable"`
	Status           InvoiceStatus        `json:"status,required"`
	Subscription     SubscriptionMinified `json:"subscription,required,nullable"`
	// The total before any discounts and minimums are applied.
	Subtotal string `json:"subtotal,required"`
	// If the invoice failed to sync, this will be the last time an external invoicing
	// provider sync was attempted. This field will always be `null` for invoices using
	// Orb Invoicing.
	SyncFailedAt time.Time `json:"sync_failed_at,required,nullable" format:"date-time"`
	// The total after any minimums and discounts have been applied.
	Total string `json:"total,required"`
	// If the invoice has a status of `void`, this gives a timestamp when the invoice
	// was voided.
	VoidedAt time.Time `json:"voided_at,required,nullable" format:"date-time"`
	// This is true if the invoice will be automatically issued in the future, and
	// false otherwise.
	WillAutoIssue bool        `json:"will_auto_issue,required"`
	JSON          invoiceJSON `json:"-"`
}

// invoiceJSON contains the JSON metadata for the struct [Invoice]
type invoiceJSON struct {
	ID                          apijson.Field
	AmountDue                   apijson.Field
	AutoCollection              apijson.Field
	BillingAddress              apijson.Field
	CreatedAt                   apijson.Field
	CreditNotes                 apijson.Field
	Currency                    apijson.Field
	Customer                    apijson.Field
	CustomerBalanceTransactions apijson.Field
	CustomerTaxID               apijson.Field
	Discount                    apijson.Field
	Discounts                   apijson.Field
	DueDate                     apijson.Field
	EligibleToIssueAt           apijson.Field
	HostedInvoiceURL            apijson.Field
	InvoiceDate                 apijson.Field
	InvoiceNumber               apijson.Field
	InvoicePdf                  apijson.Field
	InvoiceSource               apijson.Field
	IssueFailedAt               apijson.Field
	IssuedAt                    apijson.Field
	LineItems                   apijson.Field
	Maximum                     apijson.Field
	MaximumAmount               apijson.Field
	Memo                        apijson.Field
	Metadata                    apijson.Field
	Minimum                     apijson.Field
	MinimumAmount               apijson.Field
	PaidAt                      apijson.Field
	PaymentAttempts             apijson.Field
	PaymentFailedAt             apijson.Field
	PaymentStartedAt            apijson.Field
	ScheduledIssueAt            apijson.Field
	ShippingAddress             apijson.Field
	Status                      apijson.Field
	Subscription                apijson.Field
	Subtotal                    apijson.Field
	SyncFailedAt                apijson.Field
	Total                       apijson.Field
	VoidedAt                    apijson.Field
	WillAutoIssue               apijson.Field
	raw                         string
	ExtraFields                 map[string]apijson.Field
}

func (r *Invoice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoiceJSON) RawJSON() string {
	return r.raw
}

type InvoiceAutoCollection struct {
	// True only if auto-collection is enabled for this invoice.
	Enabled bool `json:"enabled,required,nullable"`
	// If the invoice is scheduled for auto-collection, this field will reflect when
	// the next attempt will occur. If dunning has been exhausted, or auto-collection
	// is not enabled for this invoice, this field will be `null`.
	NextAttemptAt time.Time `json:"next_attempt_at,required,nullable" format:"date-time"`
	// Number of auto-collection payment attempts.
	NumAttempts int64 `json:"num_attempts,required,nullable"`
	// If Orb has ever attempted payment auto-collection for this invoice, this field
	// will reflect when that attempt occurred. In conjunction with `next_attempt_at`,
	// this can be used to tell whether the invoice is currently in dunning (that is,
	// `previously_attempted_at` is non-null, and `next_attempt_time` is non-null), or
	// if dunning has been exhausted (`previously_attempted_at` is non-null, but
	// `next_attempt_time` is null).
	PreviouslyAttemptedAt time.Time                 `json:"previously_attempted_at,required,nullable" format:"date-time"`
	JSON                  invoiceAutoCollectionJSON `json:"-"`
}

// invoiceAutoCollectionJSON contains the JSON metadata for the struct
// [InvoiceAutoCollection]
type invoiceAutoCollectionJSON struct {
	Enabled               apijson.Field
	NextAttemptAt         apijson.Field
	NumAttempts           apijson.Field
	PreviouslyAttemptedAt apijson.Field
	raw                   string
	ExtraFields           map[string]apijson.Field
}

func (r *InvoiceAutoCollection) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoiceAutoCollectionJSON) RawJSON() string {
	return r.raw
}

type InvoiceCreditNote struct {
	ID               string `json:"id,required"`
	CreditNoteNumber string `json:"credit_note_number,required"`
	// An optional memo supplied on the credit note.
	Memo   string `json:"memo,required,nullable"`
	Reason string `json:"reason,required"`
	Total  string `json:"total,required"`
	Type   string `json:"type,required"`
	// If the credit note has a status of `void`, this gives a timestamp when the
	// credit note was voided.
	VoidedAt time.Time             `json:"voided_at,required,nullable" format:"date-time"`
	JSON     invoiceCreditNoteJSON `json:"-"`
}

// invoiceCreditNoteJSON contains the JSON metadata for the struct
// [InvoiceCreditNote]
type invoiceCreditNoteJSON struct {
	ID               apijson.Field
	CreditNoteNumber apijson.Field
	Memo             apijson.Field
	Reason           apijson.Field
	Total            apijson.Field
	Type             apijson.Field
	VoidedAt         apijson.Field
	raw              string
	ExtraFields      map[string]apijson.Field
}

func (r *InvoiceCreditNote) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoiceCreditNoteJSON) RawJSON() string {
	return r.raw
}

type InvoiceCustomerBalanceTransaction struct {
	// A unique id for this transaction.
	ID     string                                   `json:"id,required"`
	Action InvoiceCustomerBalanceTransactionsAction `json:"action,required"`
	// The value of the amount changed in the transaction.
	Amount string `json:"amount,required"`
	// The creation time of this transaction.
	CreatedAt  time.Time      `json:"created_at,required" format:"date-time"`
	CreditNote CreditNoteTiny `json:"credit_note,required,nullable"`
	// An optional description provided for manual customer balance adjustments.
	Description string `json:"description,required,nullable"`
	// The new value of the customer's balance prior to the transaction, in the
	// customer's currency.
	EndingBalance string      `json:"ending_balance,required"`
	Invoice       InvoiceTiny `json:"invoice,required,nullable"`
	// The original value of the customer's balance prior to the transaction, in the
	// customer's currency.
	StartingBalance string                                 `json:"starting_balance,required"`
	Type            InvoiceCustomerBalanceTransactionsType `json:"type,required"`
	JSON            invoiceCustomerBalanceTransactionJSON  `json:"-"`
}

// invoiceCustomerBalanceTransactionJSON contains the JSON metadata for the struct
// [InvoiceCustomerBalanceTransaction]
type invoiceCustomerBalanceTransactionJSON struct {
	ID              apijson.Field
	Action          apijson.Field
	Amount          apijson.Field
	CreatedAt       apijson.Field
	CreditNote      apijson.Field
	Description     apijson.Field
	EndingBalance   apijson.Field
	Invoice         apijson.Field
	StartingBalance apijson.Field
	Type            apijson.Field
	raw             string
	ExtraFields     map[string]apijson.Field
}

func (r *InvoiceCustomerBalanceTransaction) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoiceCustomerBalanceTransactionJSON) RawJSON() string {
	return r.raw
}

type InvoiceCustomerBalanceTransactionsAction string

const (
	InvoiceCustomerBalanceTransactionsActionAppliedToInvoice     InvoiceCustomerBalanceTransactionsAction = "applied_to_invoice"
	InvoiceCustomerBalanceTransactionsActionManualAdjustment     InvoiceCustomerBalanceTransactionsAction = "manual_adjustment"
	InvoiceCustomerBalanceTransactionsActionProratedRefund       InvoiceCustomerBalanceTransactionsAction = "prorated_refund"
	InvoiceCustomerBalanceTransactionsActionRevertProratedRefund InvoiceCustomerBalanceTransactionsAction = "revert_prorated_refund"
	InvoiceCustomerBalanceTransactionsActionReturnFromVoiding    InvoiceCustomerBalanceTransactionsAction = "return_from_voiding"
	InvoiceCustomerBalanceTransactionsActionCreditNoteApplied    InvoiceCustomerBalanceTransactionsAction = "credit_note_applied"
	InvoiceCustomerBalanceTransactionsActionCreditNoteVoided     InvoiceCustomerBalanceTransactionsAction = "credit_note_voided"
	InvoiceCustomerBalanceTransactionsActionOverpaymentRefund    InvoiceCustomerBalanceTransactionsAction = "overpayment_refund"
	InvoiceCustomerBalanceTransactionsActionExternalPayment      InvoiceCustomerBalanceTransactionsAction = "external_payment"
)

func (r InvoiceCustomerBalanceTransactionsAction) IsKnown() bool {
	switch r {
	case InvoiceCustomerBalanceTransactionsActionAppliedToInvoice, InvoiceCustomerBalanceTransactionsActionManualAdjustment, InvoiceCustomerBalanceTransactionsActionProratedRefund, InvoiceCustomerBalanceTransactionsActionRevertProratedRefund, InvoiceCustomerBalanceTransactionsActionReturnFromVoiding, InvoiceCustomerBalanceTransactionsActionCreditNoteApplied, InvoiceCustomerBalanceTransactionsActionCreditNoteVoided, InvoiceCustomerBalanceTransactionsActionOverpaymentRefund, InvoiceCustomerBalanceTransactionsActionExternalPayment:
		return true
	}
	return false
}

type InvoiceCustomerBalanceTransactionsType string

const (
	InvoiceCustomerBalanceTransactionsTypeIncrement InvoiceCustomerBalanceTransactionsType = "increment"
	InvoiceCustomerBalanceTransactionsTypeDecrement InvoiceCustomerBalanceTransactionsType = "decrement"
)

func (r InvoiceCustomerBalanceTransactionsType) IsKnown() bool {
	switch r {
	case InvoiceCustomerBalanceTransactionsTypeIncrement, InvoiceCustomerBalanceTransactionsTypeDecrement:
		return true
	}
	return false
}

type InvoiceInvoiceSource string

const (
	InvoiceInvoiceSourceSubscription InvoiceInvoiceSource = "subscription"
	InvoiceInvoiceSourcePartial      InvoiceInvoiceSource = "partial"
	InvoiceInvoiceSourceOneOff       InvoiceInvoiceSource = "one_off"
)

func (r InvoiceInvoiceSource) IsKnown() bool {
	switch r {
	case InvoiceInvoiceSourceSubscription, InvoiceInvoiceSourcePartial, InvoiceInvoiceSourceOneOff:
		return true
	}
	return false
}

type InvoiceLineItem struct {
	// A unique ID for this line item.
	ID string `json:"id,required"`
	// The line amount after any adjustments and before overage conversion, credits and
	// partial invoicing.
	AdjustedSubtotal string `json:"adjusted_subtotal,required"`
	// All adjustments applied to the line item in the order they were applied based on
	// invoice calculations (ie. usage discounts -> amount discounts -> percentage
	// discounts -> minimums -> maximums).
	Adjustments []InvoiceLineItemsAdjustment `json:"adjustments,required"`
	// The final amount for a line item after all adjustments and pre paid credits have
	// been applied.
	Amount string `json:"amount,required"`
	// The number of prepaid credits applied.
	CreditsApplied string   `json:"credits_applied,required"`
	Discount       Discount `json:"discount,required,nullable"`
	// The end date of the range of time applied for this line item's price.
	EndDate time.Time `json:"end_date,required" format:"date-time"`
	// An additional filter that was used to calculate the usage for this line item.
	Filter string `json:"filter,required,nullable"`
	// [DEPRECATED] For configured prices that are split by a grouping key, this will
	// be populated with the key and a value. The `amount` and `subtotal` will be the
	// values for this particular grouping.
	Grouping string `json:"grouping,required,nullable"`
	// This field is deprecated in favor of `adjustments`.
	//
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// This field is deprecated in favor of `adjustments`.
	//
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// This field is deprecated in favor of `adjustments`.
	//
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// This field is deprecated in favor of `adjustments`.
	//
	// Deprecated: deprecated
	MinimumAmount string `json:"minimum_amount,required,nullable"`
	// The name of the price associated with this line item.
	Name string `json:"name,required"`
	// Any amount applied from a partial invoice
	PartiallyInvoicedAmount string `json:"partially_invoiced_amount,required"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// Either the fixed fee quantity or the usage during the service period.
	Quantity float64 `json:"quantity,required"`
	// The start date of the range of time applied for this line item's price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// For complex pricing structures, the line item can be broken down further in
	// `sub_line_items`.
	SubLineItems []InvoiceLineItemsSubLineItem `json:"sub_line_items,required"`
	// The line amount before before any adjustments.
	Subtotal string `json:"subtotal,required"`
	// An array of tax rates and their incurred tax amounts. Empty if no tax
	// integration is configured.
	TaxAmounts []TaxAmount `json:"tax_amounts,required"`
	// A list of customer ids that were used to calculate the usage for this line item.
	UsageCustomerIDs []string            `json:"usage_customer_ids,required,nullable"`
	JSON             invoiceLineItemJSON `json:"-"`
}

// invoiceLineItemJSON contains the JSON metadata for the struct [InvoiceLineItem]
type invoiceLineItemJSON struct {
	ID                      apijson.Field
	AdjustedSubtotal        apijson.Field
	Adjustments             apijson.Field
	Amount                  apijson.Field
	CreditsApplied          apijson.Field
	Discount                apijson.Field
	EndDate                 apijson.Field
	Filter                  apijson.Field
	Grouping                apijson.Field
	Maximum                 apijson.Field
	MaximumAmount           apijson.Field
	Minimum                 apijson.Field
	MinimumAmount           apijson.Field
	Name                    apijson.Field
	PartiallyInvoicedAmount apijson.Field
	Price                   apijson.Field
	Quantity                apijson.Field
	StartDate               apijson.Field
	SubLineItems            apijson.Field
	Subtotal                apijson.Field
	TaxAmounts              apijson.Field
	UsageCustomerIDs        apijson.Field
	raw                     string
	ExtraFields             map[string]apijson.Field
}

func (r *InvoiceLineItem) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoiceLineItemJSON) RawJSON() string {
	return r.raw
}

type InvoiceLineItemsAdjustment struct {
	ID             string                                    `json:"id,required"`
	AdjustmentType InvoiceLineItemsAdjustmentsAdjustmentType `json:"adjustment_type,required"`
	// The value applied by an adjustment.
	Amount string `json:"amount,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]TransformPriceFilter].
	Filters interface{} `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                        `json:"usage_discount"`
	JSON          invoiceLineItemsAdjustmentJSON `json:"-"`
	union         InvoiceLineItemsAdjustmentsUnion
}

// invoiceLineItemsAdjustmentJSON contains the JSON metadata for the struct
// [InvoiceLineItemsAdjustment]
type invoiceLineItemsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	Amount             apijson.Field
	AppliesToPriceIDs  apijson.Field
	Filters            apijson.Field
	IsInvoiceLevel     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r invoiceLineItemsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *InvoiceLineItemsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = InvoiceLineItemsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [InvoiceLineItemsAdjustmentsUnion] interface which you can
// cast to the specific types for more type safety.
//
// Possible runtime types of the union are [MonetaryUsageDiscountAdjustment],
// [MonetaryAmountDiscountAdjustment], [MonetaryPercentageDiscountAdjustment],
// [MonetaryMinimumAdjustment], [MonetaryMaximumAdjustment].
func (r InvoiceLineItemsAdjustment) AsUnion() InvoiceLineItemsAdjustmentsUnion {
	return r.union
}

// Union satisfied by [MonetaryUsageDiscountAdjustment],
// [MonetaryAmountDiscountAdjustment], [MonetaryPercentageDiscountAdjustment],
// [MonetaryMinimumAdjustment] or [MonetaryMaximumAdjustment].
type InvoiceLineItemsAdjustmentsUnion interface {
	ImplementsInvoiceLineItemsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*InvoiceLineItemsAdjustmentsUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(MonetaryUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(MonetaryAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(MonetaryPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(MonetaryMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(MonetaryMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type InvoiceLineItemsAdjustmentsAdjustmentType string

const (
	InvoiceLineItemsAdjustmentsAdjustmentTypeUsageDiscount      InvoiceLineItemsAdjustmentsAdjustmentType = "usage_discount"
	InvoiceLineItemsAdjustmentsAdjustmentTypeAmountDiscount     InvoiceLineItemsAdjustmentsAdjustmentType = "amount_discount"
	InvoiceLineItemsAdjustmentsAdjustmentTypePercentageDiscount InvoiceLineItemsAdjustmentsAdjustmentType = "percentage_discount"
	InvoiceLineItemsAdjustmentsAdjustmentTypeMinimum            InvoiceLineItemsAdjustmentsAdjustmentType = "minimum"
	InvoiceLineItemsAdjustmentsAdjustmentTypeMaximum            InvoiceLineItemsAdjustmentsAdjustmentType = "maximum"
)

func (r InvoiceLineItemsAdjustmentsAdjustmentType) IsKnown() bool {
	switch r {
	case InvoiceLineItemsAdjustmentsAdjustmentTypeUsageDiscount, InvoiceLineItemsAdjustmentsAdjustmentTypeAmountDiscount, InvoiceLineItemsAdjustmentsAdjustmentTypePercentageDiscount, InvoiceLineItemsAdjustmentsAdjustmentTypeMinimum, InvoiceLineItemsAdjustmentsAdjustmentTypeMaximum:
		return true
	}
	return false
}

type InvoiceLineItemsSubLineItem struct {
	// The total amount for this sub line item.
	Amount       string                           `json:"amount,required"`
	Grouping     SubLineItemGrouping              `json:"grouping,required,nullable"`
	Name         string                           `json:"name,required"`
	Quantity     float64                          `json:"quantity,required"`
	Type         InvoiceLineItemsSubLineItemsType `json:"type,required"`
	MatrixConfig SubLineItemMatrixConfig          `json:"matrix_config"`
	TierConfig   TierConfig                       `json:"tier_config"`
	JSON         invoiceLineItemsSubLineItemJSON  `json:"-"`
	union        InvoiceLineItemsSubLineItemsUnion
}

// invoiceLineItemsSubLineItemJSON contains the JSON metadata for the struct
// [InvoiceLineItemsSubLineItem]
type invoiceLineItemsSubLineItemJSON struct {
	Amount       apijson.Field
	Grouping     apijson.Field
	Name         apijson.Field
	Quantity     apijson.Field
	Type         apijson.Field
	MatrixConfig apijson.Field
	TierConfig   apijson.Field
	raw          string
	ExtraFields  map[string]apijson.Field
}

func (r invoiceLineItemsSubLineItemJSON) RawJSON() string {
	return r.raw
}

func (r *InvoiceLineItemsSubLineItem) UnmarshalJSON(data []byte) (err error) {
	*r = InvoiceLineItemsSubLineItem{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [InvoiceLineItemsSubLineItemsUnion] interface which you can
// cast to the specific types for more type safety.
//
// Possible runtime types of the union are [MatrixSubLineItem], [TierSubLineItem],
// [OtherSubLineItem].
func (r InvoiceLineItemsSubLineItem) AsUnion() InvoiceLineItemsSubLineItemsUnion {
	return r.union
}

// Union satisfied by [MatrixSubLineItem], [TierSubLineItem] or [OtherSubLineItem].
type InvoiceLineItemsSubLineItemsUnion interface {
	ImplementsInvoiceLineItemsSubLineItem()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*InvoiceLineItemsSubLineItemsUnion)(nil)).Elem(),
		"type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(MatrixSubLineItem{}),
			DiscriminatorValue: "matrix",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(TierSubLineItem{}),
			DiscriminatorValue: "tier",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(OtherSubLineItem{}),
			DiscriminatorValue: "'null'",
		},
	)
}

type InvoiceLineItemsSubLineItemsType string

const (
	InvoiceLineItemsSubLineItemsTypeMatrix InvoiceLineItemsSubLineItemsType = "matrix"
	InvoiceLineItemsSubLineItemsTypeTier   InvoiceLineItemsSubLineItemsType = "tier"
	InvoiceLineItemsSubLineItemsTypeNull   InvoiceLineItemsSubLineItemsType = "'null'"
)

func (r InvoiceLineItemsSubLineItemsType) IsKnown() bool {
	switch r {
	case InvoiceLineItemsSubLineItemsTypeMatrix, InvoiceLineItemsSubLineItemsTypeTier, InvoiceLineItemsSubLineItemsTypeNull:
		return true
	}
	return false
}

type InvoicePaymentAttempt struct {
	// The ID of the payment attempt.
	ID string `json:"id,required"`
	// The amount of the payment attempt.
	Amount string `json:"amount,required"`
	// The time at which the payment attempt was created.
	CreatedAt time.Time `json:"created_at,required" format:"date-time"`
	// The payment provider that attempted to collect the payment.
	PaymentProvider InvoicePaymentAttemptsPaymentProvider `json:"payment_provider,required,nullable"`
	// The ID of the payment attempt in the payment provider.
	PaymentProviderID string `json:"payment_provider_id,required,nullable"`
	// Whether the payment attempt succeeded.
	Succeeded bool                      `json:"succeeded,required"`
	JSON      invoicePaymentAttemptJSON `json:"-"`
}

// invoicePaymentAttemptJSON contains the JSON metadata for the struct
// [InvoicePaymentAttempt]
type invoicePaymentAttemptJSON struct {
	ID                apijson.Field
	Amount            apijson.Field
	CreatedAt         apijson.Field
	PaymentProvider   apijson.Field
	PaymentProviderID apijson.Field
	Succeeded         apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *InvoicePaymentAttempt) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoicePaymentAttemptJSON) RawJSON() string {
	return r.raw
}

// The payment provider that attempted to collect the payment.
type InvoicePaymentAttemptsPaymentProvider string

const (
	InvoicePaymentAttemptsPaymentProviderStripe InvoicePaymentAttemptsPaymentProvider = "stripe"
)

func (r InvoicePaymentAttemptsPaymentProvider) IsKnown() bool {
	switch r {
	case InvoicePaymentAttemptsPaymentProviderStripe:
		return true
	}
	return false
}

type InvoiceStatus string

const (
	InvoiceStatusIssued InvoiceStatus = "issued"
	InvoiceStatusPaid   InvoiceStatus = "paid"
	InvoiceStatusSynced InvoiceStatus = "synced"
	InvoiceStatusVoid   InvoiceStatus = "void"
	InvoiceStatusDraft  InvoiceStatus = "draft"
)

func (r InvoiceStatus) IsKnown() bool {
	switch r {
	case InvoiceStatusIssued, InvoiceStatusPaid, InvoiceStatusSynced, InvoiceStatusVoid, InvoiceStatusDraft:
		return true
	}
	return false
}

type InvoiceLevelDiscount struct {
	DiscountType InvoiceLevelDiscountDiscountType `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids"`
	// This field can have the runtime type of [[]TransformPriceFilter].
	Filters interface{} `json:"filters"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	Reason             string  `json:"reason,nullable"`
	// Only available if discount_type is `trial`
	TrialAmountDiscount string `json:"trial_amount_discount,nullable"`
	// Only available if discount_type is `trial`
	TrialPercentageDiscount float64                  `json:"trial_percentage_discount,nullable"`
	JSON                    invoiceLevelDiscountJSON `json:"-"`
	union                   InvoiceLevelDiscountUnion
}

// invoiceLevelDiscountJSON contains the JSON metadata for the struct
// [InvoiceLevelDiscount]
type invoiceLevelDiscountJSON struct {
	DiscountType            apijson.Field
	AmountDiscount          apijson.Field
	AppliesToPriceIDs       apijson.Field
	Filters                 apijson.Field
	PercentageDiscount      apijson.Field
	Reason                  apijson.Field
	TrialAmountDiscount     apijson.Field
	TrialPercentageDiscount apijson.Field
	raw                     string
	ExtraFields             map[string]apijson.Field
}

func (r invoiceLevelDiscountJSON) RawJSON() string {
	return r.raw
}

func (r *InvoiceLevelDiscount) UnmarshalJSON(data []byte) (err error) {
	*r = InvoiceLevelDiscount{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [InvoiceLevelDiscountUnion] interface which you can cast to
// the specific types for more type safety.
//
// Possible runtime types of the union are [PercentageDiscount], [AmountDiscount],
// [TrialDiscount].
func (r InvoiceLevelDiscount) AsUnion() InvoiceLevelDiscountUnion {
	return r.union
}

// Union satisfied by [PercentageDiscount], [AmountDiscount] or [TrialDiscount].
type InvoiceLevelDiscountUnion interface {
	ImplementsInvoiceLevelDiscount()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*InvoiceLevelDiscountUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PercentageDiscount{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(AmountDiscount{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(TrialDiscount{}),
			DiscriminatorValue: "trial",
		},
	)
}

type InvoiceLevelDiscountDiscountType string

const (
	InvoiceLevelDiscountDiscountTypePercentage InvoiceLevelDiscountDiscountType = "percentage"
	InvoiceLevelDiscountDiscountTypeAmount     InvoiceLevelDiscountDiscountType = "amount"
	InvoiceLevelDiscountDiscountTypeTrial      InvoiceLevelDiscountDiscountType = "trial"
)

func (r InvoiceLevelDiscountDiscountType) IsKnown() bool {
	switch r {
	case InvoiceLevelDiscountDiscountTypePercentage, InvoiceLevelDiscountDiscountTypeAmount, InvoiceLevelDiscountDiscountTypeTrial:
		return true
	}
	return false
}

type InvoiceTiny struct {
	// The Invoice id
	ID   string          `json:"id,required"`
	JSON invoiceTinyJSON `json:"-"`
}

// invoiceTinyJSON contains the JSON metadata for the struct [InvoiceTiny]
type invoiceTinyJSON struct {
	ID          apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *InvoiceTiny) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r invoiceTinyJSON) RawJSON() string {
	return r.raw
}

type ItemSlim struct {
	ID   string       `json:"id,required"`
	Name string       `json:"name,required"`
	JSON itemSlimJSON `json:"-"`
}

// itemSlimJSON contains the JSON metadata for the struct [ItemSlim]
type itemSlimJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *ItemSlim) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r itemSlimJSON) RawJSON() string {
	return r.raw
}

type MatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount string `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions []string `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues []MatrixValue    `json:"matrix_values,required"`
	JSON         matrixConfigJSON `json:"-"`
}

// matrixConfigJSON contains the JSON metadata for the struct [MatrixConfig]
type matrixConfigJSON struct {
	DefaultUnitAmount apijson.Field
	Dimensions        apijson.Field
	MatrixValues      apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *MatrixConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r matrixConfigJSON) RawJSON() string {
	return r.raw
}

type MatrixConfigParam struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]MatrixValueParam] `json:"matrix_values,required"`
}

func (r MatrixConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type MatrixSubLineItem struct {
	// The total amount for this sub line item.
	Amount       string                  `json:"amount,required"`
	Grouping     SubLineItemGrouping     `json:"grouping,required,nullable"`
	MatrixConfig SubLineItemMatrixConfig `json:"matrix_config,required"`
	Name         string                  `json:"name,required"`
	Quantity     float64                 `json:"quantity,required"`
	Type         MatrixSubLineItemType   `json:"type,required"`
	JSON         matrixSubLineItemJSON   `json:"-"`
}

// matrixSubLineItemJSON contains the JSON metadata for the struct
// [MatrixSubLineItem]
type matrixSubLineItemJSON struct {
	Amount       apijson.Field
	Grouping     apijson.Field
	MatrixConfig apijson.Field
	Name         apijson.Field
	Quantity     apijson.Field
	Type         apijson.Field
	raw          string
	ExtraFields  map[string]apijson.Field
}

func (r *MatrixSubLineItem) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r matrixSubLineItemJSON) RawJSON() string {
	return r.raw
}

func (r MatrixSubLineItem) ImplementsInvoiceLineItemsSubLineItem() {}

func (r MatrixSubLineItem) ImplementsInvoiceLineItemNewResponseSubLineItem() {}

func (r MatrixSubLineItem) ImplementsInvoiceFetchUpcomingResponseLineItemsSubLineItem() {}

type MatrixSubLineItemType string

const (
	MatrixSubLineItemTypeMatrix MatrixSubLineItemType = "matrix"
)

func (r MatrixSubLineItemType) IsKnown() bool {
	switch r {
	case MatrixSubLineItemTypeMatrix:
		return true
	}
	return false
}

type MatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues []string `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount string          `json:"unit_amount,required"`
	JSON       matrixValueJSON `json:"-"`
}

// matrixValueJSON contains the JSON metadata for the struct [MatrixValue]
type matrixValueJSON struct {
	DimensionValues apijson.Field
	UnitAmount      apijson.Field
	raw             string
	ExtraFields     map[string]apijson.Field
}

func (r *MatrixValue) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r matrixValueJSON) RawJSON() string {
	return r.raw
}

type MatrixValueParam struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r MatrixValueParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type MatrixWithAllocationConfig struct {
	// Allocation to be used to calculate the price
	Allocation float64 `json:"allocation,required"`
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount string `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions []string `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues []MatrixValue                  `json:"matrix_values,required"`
	JSON         matrixWithAllocationConfigJSON `json:"-"`
}

// matrixWithAllocationConfigJSON contains the JSON metadata for the struct
// [MatrixWithAllocationConfig]
type matrixWithAllocationConfigJSON struct {
	Allocation        apijson.Field
	DefaultUnitAmount apijson.Field
	Dimensions        apijson.Field
	MatrixValues      apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *MatrixWithAllocationConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r matrixWithAllocationConfigJSON) RawJSON() string {
	return r.raw
}

type MatrixWithAllocationConfigParam struct {
	// Allocation to be used to calculate the price
	Allocation param.Field[float64] `json:"allocation,required"`
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]MatrixValueParam] `json:"matrix_values,required"`
}

func (r MatrixWithAllocationConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type Maximum struct {
	// List of price_ids that this maximum amount applies to. For plan/plan phase
	// maximums, this can be a subset of prices.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this maximum to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// Maximum amount applied
	MaximumAmount string      `json:"maximum_amount,required"`
	JSON          maximumJSON `json:"-"`
}

// maximumJSON contains the JSON metadata for the struct [Maximum]
type maximumJSON struct {
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	MaximumAmount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *Maximum) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r maximumJSON) RawJSON() string {
	return r.raw
}

type MaximumInterval struct {
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The filters that determine which prices this maximum interval applies to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time           `json:"start_date,required" format:"date-time"`
	JSON      maximumIntervalJSON `json:"-"`
}

// maximumIntervalJSON contains the JSON metadata for the struct [MaximumInterval]
type maximumIntervalJSON struct {
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	Filters                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *MaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r maximumIntervalJSON) RawJSON() string {
	return r.raw
}

type Minimum struct {
	// List of price_ids that this minimum amount applies to. For plan/plan phase
	// minimums, this can be a subset of prices.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this minimum to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// Minimum amount applied
	MinimumAmount string      `json:"minimum_amount,required"`
	JSON          minimumJSON `json:"-"`
}

// minimumJSON contains the JSON metadata for the struct [Minimum]
type minimumJSON struct {
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	MinimumAmount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *Minimum) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r minimumJSON) RawJSON() string {
	return r.raw
}

type MinimumInterval struct {
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The filters that determine which prices this minimum interval applies to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time           `json:"start_date,required" format:"date-time"`
	JSON      minimumIntervalJSON `json:"-"`
}

// minimumIntervalJSON contains the JSON metadata for the struct [MinimumInterval]
type minimumIntervalJSON struct {
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	Filters                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *MinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r minimumIntervalJSON) RawJSON() string {
	return r.raw
}

type MonetaryAmountDiscountAdjustment struct {
	ID             string                                         `json:"id,required"`
	AdjustmentType MonetaryAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The value applied by an adjustment.
	Amount string `json:"amount,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The reason for the adjustment.
	Reason string                               `json:"reason,required,nullable"`
	JSON   monetaryAmountDiscountAdjustmentJSON `json:"-"`
}

// monetaryAmountDiscountAdjustmentJSON contains the JSON metadata for the struct
// [MonetaryAmountDiscountAdjustment]
type monetaryAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	Amount            apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *MonetaryAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r monetaryAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r MonetaryAmountDiscountAdjustment) ImplementsInvoiceLineItemsAdjustment() {}

func (r MonetaryAmountDiscountAdjustment) ImplementsInvoiceLineItemNewResponseAdjustment() {}

func (r MonetaryAmountDiscountAdjustment) ImplementsInvoiceFetchUpcomingResponseLineItemsAdjustment() {
}

type MonetaryAmountDiscountAdjustmentAdjustmentType string

const (
	MonetaryAmountDiscountAdjustmentAdjustmentTypeAmountDiscount MonetaryAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r MonetaryAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case MonetaryAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type MonetaryMaximumAdjustment struct {
	ID             string                                  `json:"id,required"`
	AdjustmentType MonetaryMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The value applied by an adjustment.
	Amount string `json:"amount,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The reason for the adjustment.
	Reason string                        `json:"reason,required,nullable"`
	JSON   monetaryMaximumAdjustmentJSON `json:"-"`
}

// monetaryMaximumAdjustmentJSON contains the JSON metadata for the struct
// [MonetaryMaximumAdjustment]
type monetaryMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	Amount            apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *MonetaryMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r monetaryMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r MonetaryMaximumAdjustment) ImplementsInvoiceLineItemsAdjustment() {}

func (r MonetaryMaximumAdjustment) ImplementsInvoiceLineItemNewResponseAdjustment() {}

func (r MonetaryMaximumAdjustment) ImplementsInvoiceFetchUpcomingResponseLineItemsAdjustment() {}

type MonetaryMaximumAdjustmentAdjustmentType string

const (
	MonetaryMaximumAdjustmentAdjustmentTypeMaximum MonetaryMaximumAdjustmentAdjustmentType = "maximum"
)

func (r MonetaryMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case MonetaryMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type MonetaryMinimumAdjustment struct {
	ID             string                                  `json:"id,required"`
	AdjustmentType MonetaryMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The value applied by an adjustment.
	Amount string `json:"amount,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The reason for the adjustment.
	Reason string                        `json:"reason,required,nullable"`
	JSON   monetaryMinimumAdjustmentJSON `json:"-"`
}

// monetaryMinimumAdjustmentJSON contains the JSON metadata for the struct
// [MonetaryMinimumAdjustment]
type monetaryMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	Amount            apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *MonetaryMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r monetaryMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r MonetaryMinimumAdjustment) ImplementsInvoiceLineItemsAdjustment() {}

func (r MonetaryMinimumAdjustment) ImplementsInvoiceLineItemNewResponseAdjustment() {}

func (r MonetaryMinimumAdjustment) ImplementsInvoiceFetchUpcomingResponseLineItemsAdjustment() {}

type MonetaryMinimumAdjustmentAdjustmentType string

const (
	MonetaryMinimumAdjustmentAdjustmentTypeMinimum MonetaryMinimumAdjustmentAdjustmentType = "minimum"
)

func (r MonetaryMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case MonetaryMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type MonetaryPercentageDiscountAdjustment struct {
	ID             string                                             `json:"id,required"`
	AdjustmentType MonetaryPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The value applied by an adjustment.
	Amount string `json:"amount,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The reason for the adjustment.
	Reason string                                   `json:"reason,required,nullable"`
	JSON   monetaryPercentageDiscountAdjustmentJSON `json:"-"`
}

// monetaryPercentageDiscountAdjustmentJSON contains the JSON metadata for the
// struct [MonetaryPercentageDiscountAdjustment]
type monetaryPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	Amount             apijson.Field
	AppliesToPriceIDs  apijson.Field
	Filters            apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *MonetaryPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r monetaryPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r MonetaryPercentageDiscountAdjustment) ImplementsInvoiceLineItemsAdjustment() {}

func (r MonetaryPercentageDiscountAdjustment) ImplementsInvoiceLineItemNewResponseAdjustment() {}

func (r MonetaryPercentageDiscountAdjustment) ImplementsInvoiceFetchUpcomingResponseLineItemsAdjustment() {
}

type MonetaryPercentageDiscountAdjustmentAdjustmentType string

const (
	MonetaryPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount MonetaryPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r MonetaryPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case MonetaryPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type MonetaryUsageDiscountAdjustment struct {
	ID             string                                        `json:"id,required"`
	AdjustmentType MonetaryUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The value applied by an adjustment.
	Amount string `json:"amount,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                             `json:"usage_discount,required"`
	JSON          monetaryUsageDiscountAdjustmentJSON `json:"-"`
}

// monetaryUsageDiscountAdjustmentJSON contains the JSON metadata for the struct
// [MonetaryUsageDiscountAdjustment]
type monetaryUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	Amount            apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *MonetaryUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r monetaryUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r MonetaryUsageDiscountAdjustment) ImplementsInvoiceLineItemsAdjustment() {}

func (r MonetaryUsageDiscountAdjustment) ImplementsInvoiceLineItemNewResponseAdjustment() {}

func (r MonetaryUsageDiscountAdjustment) ImplementsInvoiceFetchUpcomingResponseLineItemsAdjustment() {
}

type MonetaryUsageDiscountAdjustmentAdjustmentType string

const (
	MonetaryUsageDiscountAdjustmentAdjustmentTypeUsageDiscount MonetaryUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r MonetaryUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case MonetaryUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type NewAllocationPriceParam struct {
	// An amount of the currency to allocate to the customer at the specified cadence.
	Amount param.Field[string] `json:"amount,required"`
	// The cadence at which to allocate the amount to the customer.
	Cadence param.Field[NewAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string or a custom pricing unit identifier in which to bill
	// this price.
	Currency param.Field[string] `json:"currency,required"`
	// The custom expiration for the allocation.
	CustomExpiration param.Field[CustomExpirationParam] `json:"custom_expiration"`
	// Whether the allocated amount should expire at the end of the cadence or roll
	// over to the next period. Set to null if using custom_expiration.
	ExpiresAtEndOfCadence param.Field[bool] `json:"expires_at_end_of_cadence"`
}

func (r NewAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence at which to allocate the amount to the customer.
type NewAllocationPriceCadence string

const (
	NewAllocationPriceCadenceOneTime    NewAllocationPriceCadence = "one_time"
	NewAllocationPriceCadenceMonthly    NewAllocationPriceCadence = "monthly"
	NewAllocationPriceCadenceQuarterly  NewAllocationPriceCadence = "quarterly"
	NewAllocationPriceCadenceSemiAnnual NewAllocationPriceCadence = "semi_annual"
	NewAllocationPriceCadenceAnnual     NewAllocationPriceCadence = "annual"
	NewAllocationPriceCadenceCustom     NewAllocationPriceCadence = "custom"
)

func (r NewAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewAllocationPriceCadenceOneTime, NewAllocationPriceCadenceMonthly, NewAllocationPriceCadenceQuarterly, NewAllocationPriceCadenceSemiAnnual, NewAllocationPriceCadenceAnnual, NewAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewAmountDiscountParam struct {
	AdjustmentType param.Field[NewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                          `json:"amount_discount,required"`
	// If set, the adjustment will apply to every price on the subscription.
	AppliesToAll param.Field[NewAmountDiscountAppliesToAll] `json:"applies_to_all"`
	// The set of item IDs to which this adjustment applies.
	AppliesToItemIDs param.Field[[]string] `json:"applies_to_item_ids"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// If set, only prices in the specified currency will have the adjustment applied.
	Currency param.Field[string] `json:"currency"`
	// A list of filters that determine which prices this adjustment will apply to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// If set, only prices of the specified type will have the adjustment applied.
	PriceType param.Field[NewAmountDiscountPriceType] `json:"price_type"`
}

func (r NewAmountDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewAmountDiscountParam) ImplementsBetaNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewAmountDiscountParam) ImplementsBetaNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewAmountDiscountParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewAmountDiscountParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewAmountDiscountParam) ImplementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewAmountDiscountParam) ImplementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {}

func (r NewAmountDiscountParam) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewAmountDiscountParam) ImplementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewAmountDiscountParam) ImplementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type NewAmountDiscountAdjustmentType string

const (
	NewAmountDiscountAdjustmentTypeAmountDiscount NewAmountDiscountAdjustmentType = "amount_discount"
)

func (r NewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case NewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

// If set, the adjustment will apply to every price on the subscription.
type NewAmountDiscountAppliesToAll bool

const (
	NewAmountDiscountAppliesToAllTrue NewAmountDiscountAppliesToAll = true
)

func (r NewAmountDiscountAppliesToAll) IsKnown() bool {
	switch r {
	case NewAmountDiscountAppliesToAllTrue:
		return true
	}
	return false
}

// If set, only prices of the specified type will have the adjustment applied.
type NewAmountDiscountPriceType string

const (
	NewAmountDiscountPriceTypeUsage          NewAmountDiscountPriceType = "usage"
	NewAmountDiscountPriceTypeFixedInAdvance NewAmountDiscountPriceType = "fixed_in_advance"
	NewAmountDiscountPriceTypeFixedInArrears NewAmountDiscountPriceType = "fixed_in_arrears"
	NewAmountDiscountPriceTypeFixed          NewAmountDiscountPriceType = "fixed"
	NewAmountDiscountPriceTypeInArrears      NewAmountDiscountPriceType = "in_arrears"
)

func (r NewAmountDiscountPriceType) IsKnown() bool {
	switch r {
	case NewAmountDiscountPriceTypeUsage, NewAmountDiscountPriceTypeFixedInAdvance, NewAmountDiscountPriceTypeFixedInArrears, NewAmountDiscountPriceTypeFixed, NewAmountDiscountPriceTypeInArrears:
		return true
	}
	return false
}

type NewBillingCycleConfigurationParam struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[NewBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r NewBillingCycleConfigurationParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type NewBillingCycleConfigurationDurationUnit string

const (
	NewBillingCycleConfigurationDurationUnitDay   NewBillingCycleConfigurationDurationUnit = "day"
	NewBillingCycleConfigurationDurationUnitMonth NewBillingCycleConfigurationDurationUnit = "month"
)

func (r NewBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case NewBillingCycleConfigurationDurationUnitDay, NewBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type NewDimensionalPriceConfigurationParam struct {
	// The list of dimension values matching (in order) the dimensions of the price
	// group
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// The id of the dimensional price group to include this price in
	DimensionalPriceGroupID param.Field[string] `json:"dimensional_price_group_id"`
	// The external id of the dimensional price group to include this price in
	ExternalDimensionalPriceGroupID param.Field[string] `json:"external_dimensional_price_group_id"`
}

func (r NewDimensionalPriceConfigurationParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBPSPriceParam struct {
	BPSConfig param.Field[BPSConfigParam] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingBPSPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                       `json:"item_id,required"`
	ModelType param.Field[NewFloatingBPSPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingBPSPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingBPSPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBPSPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {}

func (r NewFloatingBPSPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBPSPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingBPSPriceCadence string

const (
	NewFloatingBPSPriceCadenceAnnual     NewFloatingBPSPriceCadence = "annual"
	NewFloatingBPSPriceCadenceSemiAnnual NewFloatingBPSPriceCadence = "semi_annual"
	NewFloatingBPSPriceCadenceMonthly    NewFloatingBPSPriceCadence = "monthly"
	NewFloatingBPSPriceCadenceQuarterly  NewFloatingBPSPriceCadence = "quarterly"
	NewFloatingBPSPriceCadenceOneTime    NewFloatingBPSPriceCadence = "one_time"
	NewFloatingBPSPriceCadenceCustom     NewFloatingBPSPriceCadence = "custom"
)

func (r NewFloatingBPSPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingBPSPriceCadenceAnnual, NewFloatingBPSPriceCadenceSemiAnnual, NewFloatingBPSPriceCadenceMonthly, NewFloatingBPSPriceCadenceQuarterly, NewFloatingBPSPriceCadenceOneTime, NewFloatingBPSPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingBPSPriceModelType string

const (
	NewFloatingBPSPriceModelTypeBPS NewFloatingBPSPriceModelType = "bps"
)

func (r NewFloatingBPSPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingBPSPriceModelTypeBPS:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingBPSPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBPSPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                               `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                               `json:"unit_config"`
}

func (r NewFloatingBPSPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBPSPriceConversionRateConfigParam) implementsNewFloatingBPSPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingBPSPriceConversionRateConfigParam].
type NewFloatingBPSPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingBPSPriceConversionRateConfigUnionParam()
}

type NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingBPSPriceConversionRateConfigUnionParam() {
}

type NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingBPSPriceConversionRateConfigUnionParam() {
}

type NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBPSPriceConversionRateConfigConversionRateType string

const (
	NewFloatingBPSPriceConversionRateConfigConversionRateTypeUnit   NewFloatingBPSPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingBPSPriceConversionRateConfigConversionRateTypeTiered NewFloatingBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBPSPriceConversionRateConfigConversionRateTypeUnit, NewFloatingBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBulkBPSPriceParam struct {
	BulkBPSConfig param.Field[BulkBPSConfigParam] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingBulkBPSPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                           `json:"item_id,required"`
	ModelType param.Field[NewFloatingBulkBPSPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingBulkBPSPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingBulkBPSPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkBPSPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBulkBPSPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBulkBPSPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingBulkBPSPriceCadence string

const (
	NewFloatingBulkBPSPriceCadenceAnnual     NewFloatingBulkBPSPriceCadence = "annual"
	NewFloatingBulkBPSPriceCadenceSemiAnnual NewFloatingBulkBPSPriceCadence = "semi_annual"
	NewFloatingBulkBPSPriceCadenceMonthly    NewFloatingBulkBPSPriceCadence = "monthly"
	NewFloatingBulkBPSPriceCadenceQuarterly  NewFloatingBulkBPSPriceCadence = "quarterly"
	NewFloatingBulkBPSPriceCadenceOneTime    NewFloatingBulkBPSPriceCadence = "one_time"
	NewFloatingBulkBPSPriceCadenceCustom     NewFloatingBulkBPSPriceCadence = "custom"
)

func (r NewFloatingBulkBPSPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingBulkBPSPriceCadenceAnnual, NewFloatingBulkBPSPriceCadenceSemiAnnual, NewFloatingBulkBPSPriceCadenceMonthly, NewFloatingBulkBPSPriceCadenceQuarterly, NewFloatingBulkBPSPriceCadenceOneTime, NewFloatingBulkBPSPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingBulkBPSPriceModelType string

const (
	NewFloatingBulkBPSPriceModelTypeBulkBPS NewFloatingBulkBPSPriceModelType = "bulk_bps"
)

func (r NewFloatingBulkBPSPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingBulkBPSPriceModelTypeBulkBPS:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingBulkBPSPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkBPSPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                   `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                   `json:"unit_config"`
}

func (r NewFloatingBulkBPSPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkBPSPriceConversionRateConfigParam) implementsNewFloatingBulkBPSPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingBulkBPSPriceConversionRateConfigParam].
type NewFloatingBulkBPSPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingBulkBPSPriceConversionRateConfigUnionParam()
}

type NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingBulkBPSPriceConversionRateConfigUnionParam() {
}

type NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingBulkBPSPriceConversionRateConfigUnionParam() {
}

type NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkBPSPriceConversionRateConfigConversionRateType string

const (
	NewFloatingBulkBPSPriceConversionRateConfigConversionRateTypeUnit   NewFloatingBulkBPSPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingBulkBPSPriceConversionRateConfigConversionRateTypeTiered NewFloatingBulkBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBulkBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkBPSPriceConversionRateConfigConversionRateTypeUnit, NewFloatingBulkBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBulkPriceParam struct {
	BulkConfig param.Field[BulkConfigParam] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingBulkPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                        `json:"item_id,required"`
	ModelType param.Field[NewFloatingBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingBulkPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingBulkPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBulkPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBulkPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingBulkPriceCadence string

const (
	NewFloatingBulkPriceCadenceAnnual     NewFloatingBulkPriceCadence = "annual"
	NewFloatingBulkPriceCadenceSemiAnnual NewFloatingBulkPriceCadence = "semi_annual"
	NewFloatingBulkPriceCadenceMonthly    NewFloatingBulkPriceCadence = "monthly"
	NewFloatingBulkPriceCadenceQuarterly  NewFloatingBulkPriceCadence = "quarterly"
	NewFloatingBulkPriceCadenceOneTime    NewFloatingBulkPriceCadence = "one_time"
	NewFloatingBulkPriceCadenceCustom     NewFloatingBulkPriceCadence = "custom"
)

func (r NewFloatingBulkPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingBulkPriceCadenceAnnual, NewFloatingBulkPriceCadenceSemiAnnual, NewFloatingBulkPriceCadenceMonthly, NewFloatingBulkPriceCadenceQuarterly, NewFloatingBulkPriceCadenceOneTime, NewFloatingBulkPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingBulkPriceModelType string

const (
	NewFloatingBulkPriceModelTypeBulk NewFloatingBulkPriceModelType = "bulk"
)

func (r NewFloatingBulkPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingBulkPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                `json:"unit_config"`
}

func (r NewFloatingBulkPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkPriceConversionRateConfigParam) implementsNewFloatingBulkPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingBulkPriceConversionRateConfigParam].
type NewFloatingBulkPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingBulkPriceConversionRateConfigUnionParam()
}

type NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingBulkPriceConversionRateConfigUnionParam() {
}

type NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingBulkPriceConversionRateConfigUnionParam() {
}

type NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkPriceConversionRateConfigConversionRateType string

const (
	NewFloatingBulkPriceConversionRateConfigConversionRateTypeUnit   NewFloatingBulkPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingBulkPriceConversionRateConfigConversionRateTypeTiered NewFloatingBulkPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBulkPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkPriceConversionRateConfigConversionRateTypeUnit, NewFloatingBulkPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBulkWithProrationPriceParam struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingBulkWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                     `json:"item_id,required"`
	ModelType param.Field[NewFloatingBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingBulkWithProrationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingBulkWithProrationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkWithProrationPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBulkWithProrationPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingBulkWithProrationPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingBulkWithProrationPriceCadence string

const (
	NewFloatingBulkWithProrationPriceCadenceAnnual     NewFloatingBulkWithProrationPriceCadence = "annual"
	NewFloatingBulkWithProrationPriceCadenceSemiAnnual NewFloatingBulkWithProrationPriceCadence = "semi_annual"
	NewFloatingBulkWithProrationPriceCadenceMonthly    NewFloatingBulkWithProrationPriceCadence = "monthly"
	NewFloatingBulkWithProrationPriceCadenceQuarterly  NewFloatingBulkWithProrationPriceCadence = "quarterly"
	NewFloatingBulkWithProrationPriceCadenceOneTime    NewFloatingBulkWithProrationPriceCadence = "one_time"
	NewFloatingBulkWithProrationPriceCadenceCustom     NewFloatingBulkWithProrationPriceCadence = "custom"
)

func (r NewFloatingBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingBulkWithProrationPriceCadenceAnnual, NewFloatingBulkWithProrationPriceCadenceSemiAnnual, NewFloatingBulkWithProrationPriceCadenceMonthly, NewFloatingBulkWithProrationPriceCadenceQuarterly, NewFloatingBulkWithProrationPriceCadenceOneTime, NewFloatingBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingBulkWithProrationPriceModelType string

const (
	NewFloatingBulkWithProrationPriceModelTypeBulkWithProration NewFloatingBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r NewFloatingBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingBulkWithProrationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigParam) implementsNewFloatingBulkWithProrationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingBulkWithProrationPriceConversionRateConfigParam].
type NewFloatingBulkWithProrationPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingBulkWithProrationPriceConversionRateConfigUnionParam()
}

type NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingBulkWithProrationPriceConversionRateConfigUnionParam() {
}

type NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingBulkWithProrationPriceConversionRateConfigUnionParam() {
}

type NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateType string

const (
	NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateTypeUnit   NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateTypeTiered NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateTypeUnit, NewFloatingBulkWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingCumulativeGroupedBulkPriceParam struct {
	// The cadence to bill for this price on.
	Cadence                     param.Field[NewFloatingCumulativeGroupedBulkPriceCadence] `json:"cadence,required"`
	CumulativeGroupedBulkConfig param.Field[map[string]interface{}]                       `json:"cumulative_grouped_bulk_config,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                         `json:"item_id,required"`
	ModelType param.Field[NewFloatingCumulativeGroupedBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingCumulativeGroupedBulkPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingCumulativeGroupedBulkPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingCumulativeGroupedBulkPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingCumulativeGroupedBulkPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingCumulativeGroupedBulkPriceCadence string

const (
	NewFloatingCumulativeGroupedBulkPriceCadenceAnnual     NewFloatingCumulativeGroupedBulkPriceCadence = "annual"
	NewFloatingCumulativeGroupedBulkPriceCadenceSemiAnnual NewFloatingCumulativeGroupedBulkPriceCadence = "semi_annual"
	NewFloatingCumulativeGroupedBulkPriceCadenceMonthly    NewFloatingCumulativeGroupedBulkPriceCadence = "monthly"
	NewFloatingCumulativeGroupedBulkPriceCadenceQuarterly  NewFloatingCumulativeGroupedBulkPriceCadence = "quarterly"
	NewFloatingCumulativeGroupedBulkPriceCadenceOneTime    NewFloatingCumulativeGroupedBulkPriceCadence = "one_time"
	NewFloatingCumulativeGroupedBulkPriceCadenceCustom     NewFloatingCumulativeGroupedBulkPriceCadence = "custom"
)

func (r NewFloatingCumulativeGroupedBulkPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingCumulativeGroupedBulkPriceCadenceAnnual, NewFloatingCumulativeGroupedBulkPriceCadenceSemiAnnual, NewFloatingCumulativeGroupedBulkPriceCadenceMonthly, NewFloatingCumulativeGroupedBulkPriceCadenceQuarterly, NewFloatingCumulativeGroupedBulkPriceCadenceOneTime, NewFloatingCumulativeGroupedBulkPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingCumulativeGroupedBulkPriceModelType string

const (
	NewFloatingCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk NewFloatingCumulativeGroupedBulkPriceModelType = "cumulative_grouped_bulk"
)

func (r NewFloatingCumulativeGroupedBulkPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                 `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                 `json:"unit_config"`
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigParam) implementsNewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingCumulativeGroupedBulkPriceConversionRateConfigParam].
type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnionParam()
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnionParam() {
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingCumulativeGroupedBulkPriceConversionRateConfigUnionParam() {
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateType string

const (
	NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeUnit   NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeTiered NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeUnit, NewFloatingCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedAllocationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingGroupedAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                param.Field[string]                 `json:"currency,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}] `json:"grouped_allocation_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                     `json:"item_id,required"`
	ModelType param.Field[NewFloatingGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingGroupedAllocationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingGroupedAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedAllocationPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedAllocationPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedAllocationPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingGroupedAllocationPriceCadence string

const (
	NewFloatingGroupedAllocationPriceCadenceAnnual     NewFloatingGroupedAllocationPriceCadence = "annual"
	NewFloatingGroupedAllocationPriceCadenceSemiAnnual NewFloatingGroupedAllocationPriceCadence = "semi_annual"
	NewFloatingGroupedAllocationPriceCadenceMonthly    NewFloatingGroupedAllocationPriceCadence = "monthly"
	NewFloatingGroupedAllocationPriceCadenceQuarterly  NewFloatingGroupedAllocationPriceCadence = "quarterly"
	NewFloatingGroupedAllocationPriceCadenceOneTime    NewFloatingGroupedAllocationPriceCadence = "one_time"
	NewFloatingGroupedAllocationPriceCadenceCustom     NewFloatingGroupedAllocationPriceCadence = "custom"
)

func (r NewFloatingGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingGroupedAllocationPriceCadenceAnnual, NewFloatingGroupedAllocationPriceCadenceSemiAnnual, NewFloatingGroupedAllocationPriceCadenceMonthly, NewFloatingGroupedAllocationPriceCadenceQuarterly, NewFloatingGroupedAllocationPriceCadenceOneTime, NewFloatingGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingGroupedAllocationPriceModelType string

const (
	NewFloatingGroupedAllocationPriceModelTypeGroupedAllocation NewFloatingGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r NewFloatingGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingGroupedAllocationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigParam) implementsNewFloatingGroupedAllocationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingGroupedAllocationPriceConversionRateConfigParam].
type NewFloatingGroupedAllocationPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingGroupedAllocationPriceConversionRateConfigUnionParam()
}

type NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingGroupedAllocationPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingGroupedAllocationPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateTypeUnit   NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateTypeTiered NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateTypeUnit, NewFloatingGroupedAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingGroupedTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                   param.Field[string]                 `json:"currency,required"`
	GroupedTieredPackageConfig param.Field[map[string]interface{}] `json:"grouped_tiered_package_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                        `json:"item_id,required"`
	ModelType param.Field[NewFloatingGroupedTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingGroupedTieredPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingGroupedTieredPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPackagePriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedTieredPackagePriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedTieredPackagePriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingGroupedTieredPackagePriceCadence string

const (
	NewFloatingGroupedTieredPackagePriceCadenceAnnual     NewFloatingGroupedTieredPackagePriceCadence = "annual"
	NewFloatingGroupedTieredPackagePriceCadenceSemiAnnual NewFloatingGroupedTieredPackagePriceCadence = "semi_annual"
	NewFloatingGroupedTieredPackagePriceCadenceMonthly    NewFloatingGroupedTieredPackagePriceCadence = "monthly"
	NewFloatingGroupedTieredPackagePriceCadenceQuarterly  NewFloatingGroupedTieredPackagePriceCadence = "quarterly"
	NewFloatingGroupedTieredPackagePriceCadenceOneTime    NewFloatingGroupedTieredPackagePriceCadence = "one_time"
	NewFloatingGroupedTieredPackagePriceCadenceCustom     NewFloatingGroupedTieredPackagePriceCadence = "custom"
)

func (r NewFloatingGroupedTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPackagePriceCadenceAnnual, NewFloatingGroupedTieredPackagePriceCadenceSemiAnnual, NewFloatingGroupedTieredPackagePriceCadenceMonthly, NewFloatingGroupedTieredPackagePriceCadenceQuarterly, NewFloatingGroupedTieredPackagePriceCadenceOneTime, NewFloatingGroupedTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPackagePriceModelType string

const (
	NewFloatingGroupedTieredPackagePriceModelTypeGroupedTieredPackage NewFloatingGroupedTieredPackagePriceModelType = "grouped_tiered_package"
)

func (r NewFloatingGroupedTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPackagePriceModelTypeGroupedTieredPackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingGroupedTieredPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                `json:"unit_config"`
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigParam) implementsNewFloatingGroupedTieredPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingGroupedTieredPackagePriceConversionRateConfigParam].
type NewFloatingGroupedTieredPackagePriceConversionRateConfigUnionParam interface {
	implementsNewFloatingGroupedTieredPackagePriceConversionRateConfigUnionParam()
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingGroupedTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingGroupedTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateTypeUnit   NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateTypeTiered NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateTypeUnit, NewFloatingGroupedTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingGroupedTieredPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency            param.Field[string]                 `json:"currency,required"`
	GroupedTieredConfig param.Field[map[string]interface{}] `json:"grouped_tiered_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewFloatingGroupedTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingGroupedTieredPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingGroupedTieredPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedTieredPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedTieredPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingGroupedTieredPriceCadence string

const (
	NewFloatingGroupedTieredPriceCadenceAnnual     NewFloatingGroupedTieredPriceCadence = "annual"
	NewFloatingGroupedTieredPriceCadenceSemiAnnual NewFloatingGroupedTieredPriceCadence = "semi_annual"
	NewFloatingGroupedTieredPriceCadenceMonthly    NewFloatingGroupedTieredPriceCadence = "monthly"
	NewFloatingGroupedTieredPriceCadenceQuarterly  NewFloatingGroupedTieredPriceCadence = "quarterly"
	NewFloatingGroupedTieredPriceCadenceOneTime    NewFloatingGroupedTieredPriceCadence = "one_time"
	NewFloatingGroupedTieredPriceCadenceCustom     NewFloatingGroupedTieredPriceCadence = "custom"
)

func (r NewFloatingGroupedTieredPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPriceCadenceAnnual, NewFloatingGroupedTieredPriceCadenceSemiAnnual, NewFloatingGroupedTieredPriceCadenceMonthly, NewFloatingGroupedTieredPriceCadenceQuarterly, NewFloatingGroupedTieredPriceCadenceOneTime, NewFloatingGroupedTieredPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPriceModelType string

const (
	NewFloatingGroupedTieredPriceModelTypeGroupedTiered NewFloatingGroupedTieredPriceModelType = "grouped_tiered"
)

func (r NewFloatingGroupedTieredPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPriceModelTypeGroupedTiered:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingGroupedTieredPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedTieredPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigParam) implementsNewFloatingGroupedTieredPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingGroupedTieredPriceConversionRateConfigParam].
type NewFloatingGroupedTieredPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingGroupedTieredPriceConversionRateConfigUnionParam()
}

type NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingGroupedTieredPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingGroupedTieredPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedTieredPriceConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedTieredPriceConversionRateConfigConversionRateTypeUnit   NewFloatingGroupedTieredPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingGroupedTieredPriceConversionRateConfigConversionRateTypeTiered NewFloatingGroupedTieredPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedTieredPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedTieredPriceConversionRateConfigConversionRateTypeUnit, NewFloatingGroupedTieredPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedWithMeteredMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingGroupedWithMeteredMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                        param.Field[string]                 `json:"currency,required"`
	GroupedWithMeteredMinimumConfig param.Field[map[string]interface{}] `json:"grouped_with_metered_minimum_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                             `json:"item_id,required"`
	ModelType param.Field[NewFloatingGroupedWithMeteredMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithMeteredMinimumPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedWithMeteredMinimumPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedWithMeteredMinimumPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingGroupedWithMeteredMinimumPriceCadence string

const (
	NewFloatingGroupedWithMeteredMinimumPriceCadenceAnnual     NewFloatingGroupedWithMeteredMinimumPriceCadence = "annual"
	NewFloatingGroupedWithMeteredMinimumPriceCadenceSemiAnnual NewFloatingGroupedWithMeteredMinimumPriceCadence = "semi_annual"
	NewFloatingGroupedWithMeteredMinimumPriceCadenceMonthly    NewFloatingGroupedWithMeteredMinimumPriceCadence = "monthly"
	NewFloatingGroupedWithMeteredMinimumPriceCadenceQuarterly  NewFloatingGroupedWithMeteredMinimumPriceCadence = "quarterly"
	NewFloatingGroupedWithMeteredMinimumPriceCadenceOneTime    NewFloatingGroupedWithMeteredMinimumPriceCadence = "one_time"
	NewFloatingGroupedWithMeteredMinimumPriceCadenceCustom     NewFloatingGroupedWithMeteredMinimumPriceCadence = "custom"
)

func (r NewFloatingGroupedWithMeteredMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithMeteredMinimumPriceCadenceAnnual, NewFloatingGroupedWithMeteredMinimumPriceCadenceSemiAnnual, NewFloatingGroupedWithMeteredMinimumPriceCadenceMonthly, NewFloatingGroupedWithMeteredMinimumPriceCadenceQuarterly, NewFloatingGroupedWithMeteredMinimumPriceCadenceOneTime, NewFloatingGroupedWithMeteredMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingGroupedWithMeteredMinimumPriceModelType string

const (
	NewFloatingGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum NewFloatingGroupedWithMeteredMinimumPriceModelType = "grouped_with_metered_minimum"
)

func (r NewFloatingGroupedWithMeteredMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                     `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                     `json:"unit_config"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigParam) implementsNewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigParam].
type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam()
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeUnit   NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeTiered NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeUnit, NewFloatingGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedWithProratedMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                         param.Field[string]                 `json:"currency,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}] `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                              `json:"item_id,required"`
	ModelType param.Field[NewFloatingGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithProratedMinimumPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedWithProratedMinimumPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingGroupedWithProratedMinimumPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingGroupedWithProratedMinimumPriceCadence string

const (
	NewFloatingGroupedWithProratedMinimumPriceCadenceAnnual     NewFloatingGroupedWithProratedMinimumPriceCadence = "annual"
	NewFloatingGroupedWithProratedMinimumPriceCadenceSemiAnnual NewFloatingGroupedWithProratedMinimumPriceCadence = "semi_annual"
	NewFloatingGroupedWithProratedMinimumPriceCadenceMonthly    NewFloatingGroupedWithProratedMinimumPriceCadence = "monthly"
	NewFloatingGroupedWithProratedMinimumPriceCadenceQuarterly  NewFloatingGroupedWithProratedMinimumPriceCadence = "quarterly"
	NewFloatingGroupedWithProratedMinimumPriceCadenceOneTime    NewFloatingGroupedWithProratedMinimumPriceCadence = "one_time"
	NewFloatingGroupedWithProratedMinimumPriceCadenceCustom     NewFloatingGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r NewFloatingGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithProratedMinimumPriceCadenceAnnual, NewFloatingGroupedWithProratedMinimumPriceCadenceSemiAnnual, NewFloatingGroupedWithProratedMinimumPriceCadenceMonthly, NewFloatingGroupedWithProratedMinimumPriceCadenceQuarterly, NewFloatingGroupedWithProratedMinimumPriceCadenceOneTime, NewFloatingGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingGroupedWithProratedMinimumPriceModelType string

const (
	NewFloatingGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum NewFloatingGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r NewFloatingGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                      `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                      `json:"unit_config"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigParam) implementsNewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigParam].
type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnionParam()
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingGroupedWithProratedMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType string

const (
	NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeUnit   NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeTiered NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeUnit, NewFloatingGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMatrixPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingMatrixPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID       param.Field[string]                          `json:"item_id,required"`
	MatrixConfig param.Field[MatrixConfigParam]               `json:"matrix_config,required"`
	ModelType    param.Field[NewFloatingMatrixPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingMatrixPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingMatrixPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMatrixPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMatrixPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingMatrixPriceCadence string

const (
	NewFloatingMatrixPriceCadenceAnnual     NewFloatingMatrixPriceCadence = "annual"
	NewFloatingMatrixPriceCadenceSemiAnnual NewFloatingMatrixPriceCadence = "semi_annual"
	NewFloatingMatrixPriceCadenceMonthly    NewFloatingMatrixPriceCadence = "monthly"
	NewFloatingMatrixPriceCadenceQuarterly  NewFloatingMatrixPriceCadence = "quarterly"
	NewFloatingMatrixPriceCadenceOneTime    NewFloatingMatrixPriceCadence = "one_time"
	NewFloatingMatrixPriceCadenceCustom     NewFloatingMatrixPriceCadence = "custom"
)

func (r NewFloatingMatrixPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingMatrixPriceCadenceAnnual, NewFloatingMatrixPriceCadenceSemiAnnual, NewFloatingMatrixPriceCadenceMonthly, NewFloatingMatrixPriceCadenceQuarterly, NewFloatingMatrixPriceCadenceOneTime, NewFloatingMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingMatrixPriceModelType string

const (
	NewFloatingMatrixPriceModelTypeMatrix NewFloatingMatrixPriceModelType = "matrix"
)

func (r NewFloatingMatrixPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingMatrixPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                  `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                  `json:"unit_config"`
}

func (r NewFloatingMatrixPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixPriceConversionRateConfigParam) implementsNewFloatingMatrixPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingMatrixPriceConversionRateConfigParam].
type NewFloatingMatrixPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingMatrixPriceConversionRateConfigUnionParam()
}

type NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingMatrixPriceConversionRateConfigUnionParam() {
}

type NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingMatrixPriceConversionRateConfigUnionParam() {
}

type NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixPriceConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixPriceConversionRateConfigConversionRateTypeUnit   NewFloatingMatrixPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingMatrixPriceConversionRateConfigConversionRateTypeTiered NewFloatingMatrixPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMatrixPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixPriceConversionRateConfigConversionRateTypeUnit, NewFloatingMatrixPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMatrixWithAllocationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingMatrixWithAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID                     param.Field[string]                                        `json:"item_id,required"`
	MatrixWithAllocationConfig param.Field[MatrixWithAllocationConfigParam]               `json:"matrix_with_allocation_config,required"`
	ModelType                  param.Field[NewFloatingMatrixWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingMatrixWithAllocationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingMatrixWithAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithAllocationPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMatrixWithAllocationPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMatrixWithAllocationPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingMatrixWithAllocationPriceCadence string

const (
	NewFloatingMatrixWithAllocationPriceCadenceAnnual     NewFloatingMatrixWithAllocationPriceCadence = "annual"
	NewFloatingMatrixWithAllocationPriceCadenceSemiAnnual NewFloatingMatrixWithAllocationPriceCadence = "semi_annual"
	NewFloatingMatrixWithAllocationPriceCadenceMonthly    NewFloatingMatrixWithAllocationPriceCadence = "monthly"
	NewFloatingMatrixWithAllocationPriceCadenceQuarterly  NewFloatingMatrixWithAllocationPriceCadence = "quarterly"
	NewFloatingMatrixWithAllocationPriceCadenceOneTime    NewFloatingMatrixWithAllocationPriceCadence = "one_time"
	NewFloatingMatrixWithAllocationPriceCadenceCustom     NewFloatingMatrixWithAllocationPriceCadence = "custom"
)

func (r NewFloatingMatrixWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithAllocationPriceCadenceAnnual, NewFloatingMatrixWithAllocationPriceCadenceSemiAnnual, NewFloatingMatrixWithAllocationPriceCadenceMonthly, NewFloatingMatrixWithAllocationPriceCadenceQuarterly, NewFloatingMatrixWithAllocationPriceCadenceOneTime, NewFloatingMatrixWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingMatrixWithAllocationPriceModelType string

const (
	NewFloatingMatrixWithAllocationPriceModelTypeMatrixWithAllocation NewFloatingMatrixWithAllocationPriceModelType = "matrix_with_allocation"
)

func (r NewFloatingMatrixWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithAllocationPriceModelTypeMatrixWithAllocation:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingMatrixWithAllocationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                `json:"unit_config"`
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigParam) implementsNewFloatingMatrixWithAllocationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingMatrixWithAllocationPriceConversionRateConfigParam].
type NewFloatingMatrixWithAllocationPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingMatrixWithAllocationPriceConversionRateConfigUnionParam()
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingMatrixWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingMatrixWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateTypeUnit   NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateTypeTiered NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateTypeUnit, NewFloatingMatrixWithAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMatrixWithDisplayNamePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingMatrixWithDisplayNamePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID                      param.Field[string]                                         `json:"item_id,required"`
	MatrixWithDisplayNameConfig param.Field[map[string]interface{}]                         `json:"matrix_with_display_name_config,required"`
	ModelType                   param.Field[NewFloatingMatrixWithDisplayNamePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingMatrixWithDisplayNamePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithDisplayNamePriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMatrixWithDisplayNamePriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMatrixWithDisplayNamePriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingMatrixWithDisplayNamePriceCadence string

const (
	NewFloatingMatrixWithDisplayNamePriceCadenceAnnual     NewFloatingMatrixWithDisplayNamePriceCadence = "annual"
	NewFloatingMatrixWithDisplayNamePriceCadenceSemiAnnual NewFloatingMatrixWithDisplayNamePriceCadence = "semi_annual"
	NewFloatingMatrixWithDisplayNamePriceCadenceMonthly    NewFloatingMatrixWithDisplayNamePriceCadence = "monthly"
	NewFloatingMatrixWithDisplayNamePriceCadenceQuarterly  NewFloatingMatrixWithDisplayNamePriceCadence = "quarterly"
	NewFloatingMatrixWithDisplayNamePriceCadenceOneTime    NewFloatingMatrixWithDisplayNamePriceCadence = "one_time"
	NewFloatingMatrixWithDisplayNamePriceCadenceCustom     NewFloatingMatrixWithDisplayNamePriceCadence = "custom"
)

func (r NewFloatingMatrixWithDisplayNamePriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithDisplayNamePriceCadenceAnnual, NewFloatingMatrixWithDisplayNamePriceCadenceSemiAnnual, NewFloatingMatrixWithDisplayNamePriceCadenceMonthly, NewFloatingMatrixWithDisplayNamePriceCadenceQuarterly, NewFloatingMatrixWithDisplayNamePriceCadenceOneTime, NewFloatingMatrixWithDisplayNamePriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingMatrixWithDisplayNamePriceModelType string

const (
	NewFloatingMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName NewFloatingMatrixWithDisplayNamePriceModelType = "matrix_with_display_name"
)

func (r NewFloatingMatrixWithDisplayNamePriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                 `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                 `json:"unit_config"`
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigParam) implementsNewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingMatrixWithDisplayNamePriceConversionRateConfigParam].
type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnionParam interface {
	implementsNewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnionParam()
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnionParam() {
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingMatrixWithDisplayNamePriceConversionRateConfigUnionParam() {
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateType string

const (
	NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeUnit   NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateType = "unit"
	NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeTiered NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeUnit, NewFloatingMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMaxGroupTieredPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingMaxGroupTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID                      param.Field[string]                                         `json:"item_id,required"`
	MaxGroupTieredPackageConfig param.Field[map[string]interface{}]                         `json:"max_group_tiered_package_config,required"`
	ModelType                   param.Field[NewFloatingMaxGroupTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingMaxGroupTieredPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMaxGroupTieredPackagePriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMaxGroupTieredPackagePriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingMaxGroupTieredPackagePriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingMaxGroupTieredPackagePriceCadence string

const (
	NewFloatingMaxGroupTieredPackagePriceCadenceAnnual     NewFloatingMaxGroupTieredPackagePriceCadence = "annual"
	NewFloatingMaxGroupTieredPackagePriceCadenceSemiAnnual NewFloatingMaxGroupTieredPackagePriceCadence = "semi_annual"
	NewFloatingMaxGroupTieredPackagePriceCadenceMonthly    NewFloatingMaxGroupTieredPackagePriceCadence = "monthly"
	NewFloatingMaxGroupTieredPackagePriceCadenceQuarterly  NewFloatingMaxGroupTieredPackagePriceCadence = "quarterly"
	NewFloatingMaxGroupTieredPackagePriceCadenceOneTime    NewFloatingMaxGroupTieredPackagePriceCadence = "one_time"
	NewFloatingMaxGroupTieredPackagePriceCadenceCustom     NewFloatingMaxGroupTieredPackagePriceCadence = "custom"
)

func (r NewFloatingMaxGroupTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingMaxGroupTieredPackagePriceCadenceAnnual, NewFloatingMaxGroupTieredPackagePriceCadenceSemiAnnual, NewFloatingMaxGroupTieredPackagePriceCadenceMonthly, NewFloatingMaxGroupTieredPackagePriceCadenceQuarterly, NewFloatingMaxGroupTieredPackagePriceCadenceOneTime, NewFloatingMaxGroupTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingMaxGroupTieredPackagePriceModelType string

const (
	NewFloatingMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage NewFloatingMaxGroupTieredPackagePriceModelType = "max_group_tiered_package"
)

func (r NewFloatingMaxGroupTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                 `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                 `json:"unit_config"`
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigParam) implementsNewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingMaxGroupTieredPackagePriceConversionRateConfigParam].
type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnionParam interface {
	implementsNewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnionParam()
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingMaxGroupTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateType string

const (
	NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeUnit   NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeTiered NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeUnit, NewFloatingMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                           `json:"item_id,required"`
	ModelType param.Field[NewFloatingPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]             `json:"name,required"`
	PackageConfig param.Field[PackageConfigParam] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackagePriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingPackagePriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingPackagePriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingPackagePriceCadence string

const (
	NewFloatingPackagePriceCadenceAnnual     NewFloatingPackagePriceCadence = "annual"
	NewFloatingPackagePriceCadenceSemiAnnual NewFloatingPackagePriceCadence = "semi_annual"
	NewFloatingPackagePriceCadenceMonthly    NewFloatingPackagePriceCadence = "monthly"
	NewFloatingPackagePriceCadenceQuarterly  NewFloatingPackagePriceCadence = "quarterly"
	NewFloatingPackagePriceCadenceOneTime    NewFloatingPackagePriceCadence = "one_time"
	NewFloatingPackagePriceCadenceCustom     NewFloatingPackagePriceCadence = "custom"
)

func (r NewFloatingPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingPackagePriceCadenceAnnual, NewFloatingPackagePriceCadenceSemiAnnual, NewFloatingPackagePriceCadenceMonthly, NewFloatingPackagePriceCadenceQuarterly, NewFloatingPackagePriceCadenceOneTime, NewFloatingPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingPackagePriceModelType string

const (
	NewFloatingPackagePriceModelTypePackage NewFloatingPackagePriceModelType = "package"
)

func (r NewFloatingPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingPackagePriceModelTypePackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                   `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                   `json:"unit_config"`
}

func (r NewFloatingPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackagePriceConversionRateConfigParam) implementsNewFloatingPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingPackagePriceConversionRateConfigParam].
type NewFloatingPackagePriceConversionRateConfigUnionParam interface {
	implementsNewFloatingPackagePriceConversionRateConfigUnionParam()
}

type NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingPackagePriceConversionRateConfigConversionRateType string

const (
	NewFloatingPackagePriceConversionRateConfigConversionRateTypeUnit   NewFloatingPackagePriceConversionRateConfigConversionRateType = "unit"
	NewFloatingPackagePriceConversionRateConfigConversionRateTypeTiered NewFloatingPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingPackagePriceConversionRateConfigConversionRateTypeUnit, NewFloatingPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingPackageWithAllocationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                         `json:"item_id,required"`
	ModelType param.Field[NewFloatingPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingPackageWithAllocationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingPackageWithAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackageWithAllocationPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingPackageWithAllocationPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingPackageWithAllocationPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingPackageWithAllocationPriceCadence string

const (
	NewFloatingPackageWithAllocationPriceCadenceAnnual     NewFloatingPackageWithAllocationPriceCadence = "annual"
	NewFloatingPackageWithAllocationPriceCadenceSemiAnnual NewFloatingPackageWithAllocationPriceCadence = "semi_annual"
	NewFloatingPackageWithAllocationPriceCadenceMonthly    NewFloatingPackageWithAllocationPriceCadence = "monthly"
	NewFloatingPackageWithAllocationPriceCadenceQuarterly  NewFloatingPackageWithAllocationPriceCadence = "quarterly"
	NewFloatingPackageWithAllocationPriceCadenceOneTime    NewFloatingPackageWithAllocationPriceCadence = "one_time"
	NewFloatingPackageWithAllocationPriceCadenceCustom     NewFloatingPackageWithAllocationPriceCadence = "custom"
)

func (r NewFloatingPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingPackageWithAllocationPriceCadenceAnnual, NewFloatingPackageWithAllocationPriceCadenceSemiAnnual, NewFloatingPackageWithAllocationPriceCadenceMonthly, NewFloatingPackageWithAllocationPriceCadenceQuarterly, NewFloatingPackageWithAllocationPriceCadenceOneTime, NewFloatingPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingPackageWithAllocationPriceModelType string

const (
	NewFloatingPackageWithAllocationPriceModelTypePackageWithAllocation NewFloatingPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r NewFloatingPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingPackageWithAllocationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                 `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                 `json:"unit_config"`
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigParam) implementsNewFloatingPackageWithAllocationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingPackageWithAllocationPriceConversionRateConfigParam].
type NewFloatingPackageWithAllocationPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingPackageWithAllocationPriceConversionRateConfigUnionParam()
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingPackageWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingPackageWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateType string

const (
	NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateTypeUnit   NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateTypeTiered NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateTypeUnit, NewFloatingPackageWithAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithTieredPricingPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingScalableMatrixWithTieredPricingPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                   `json:"item_id,required"`
	ModelType param.Field[NewFloatingScalableMatrixWithTieredPricingPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                                  param.Field[string]                 `json:"name,required"`
	ScalableMatrixWithTieredPricingConfig param.Field[map[string]interface{}] `json:"scalable_matrix_with_tiered_pricing_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingScalableMatrixWithTieredPricingPriceCadence string

const (
	NewFloatingScalableMatrixWithTieredPricingPriceCadenceAnnual     NewFloatingScalableMatrixWithTieredPricingPriceCadence = "annual"
	NewFloatingScalableMatrixWithTieredPricingPriceCadenceSemiAnnual NewFloatingScalableMatrixWithTieredPricingPriceCadence = "semi_annual"
	NewFloatingScalableMatrixWithTieredPricingPriceCadenceMonthly    NewFloatingScalableMatrixWithTieredPricingPriceCadence = "monthly"
	NewFloatingScalableMatrixWithTieredPricingPriceCadenceQuarterly  NewFloatingScalableMatrixWithTieredPricingPriceCadence = "quarterly"
	NewFloatingScalableMatrixWithTieredPricingPriceCadenceOneTime    NewFloatingScalableMatrixWithTieredPricingPriceCadence = "one_time"
	NewFloatingScalableMatrixWithTieredPricingPriceCadenceCustom     NewFloatingScalableMatrixWithTieredPricingPriceCadence = "custom"
)

func (r NewFloatingScalableMatrixWithTieredPricingPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithTieredPricingPriceCadenceAnnual, NewFloatingScalableMatrixWithTieredPricingPriceCadenceSemiAnnual, NewFloatingScalableMatrixWithTieredPricingPriceCadenceMonthly, NewFloatingScalableMatrixWithTieredPricingPriceCadenceQuarterly, NewFloatingScalableMatrixWithTieredPricingPriceCadenceOneTime, NewFloatingScalableMatrixWithTieredPricingPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithTieredPricingPriceModelType string

const (
	NewFloatingScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing NewFloatingScalableMatrixWithTieredPricingPriceModelType = "scalable_matrix_with_tiered_pricing"
)

func (r NewFloatingScalableMatrixWithTieredPricingPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                           `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                           `json:"unit_config"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigParam) implementsNewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigParam].
type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam()
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam() {
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam() {
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType string

const (
	NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeUnit   NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeTiered NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeUnit, NewFloatingScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithUnitPricingPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingScalableMatrixWithUnitPricingPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                 `json:"item_id,required"`
	ModelType param.Field[NewFloatingScalableMatrixWithUnitPricingPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                                param.Field[string]                 `json:"name,required"`
	ScalableMatrixWithUnitPricingConfig param.Field[map[string]interface{}] `json:"scalable_matrix_with_unit_pricing_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingScalableMatrixWithUnitPricingPriceCadence string

const (
	NewFloatingScalableMatrixWithUnitPricingPriceCadenceAnnual     NewFloatingScalableMatrixWithUnitPricingPriceCadence = "annual"
	NewFloatingScalableMatrixWithUnitPricingPriceCadenceSemiAnnual NewFloatingScalableMatrixWithUnitPricingPriceCadence = "semi_annual"
	NewFloatingScalableMatrixWithUnitPricingPriceCadenceMonthly    NewFloatingScalableMatrixWithUnitPricingPriceCadence = "monthly"
	NewFloatingScalableMatrixWithUnitPricingPriceCadenceQuarterly  NewFloatingScalableMatrixWithUnitPricingPriceCadence = "quarterly"
	NewFloatingScalableMatrixWithUnitPricingPriceCadenceOneTime    NewFloatingScalableMatrixWithUnitPricingPriceCadence = "one_time"
	NewFloatingScalableMatrixWithUnitPricingPriceCadenceCustom     NewFloatingScalableMatrixWithUnitPricingPriceCadence = "custom"
)

func (r NewFloatingScalableMatrixWithUnitPricingPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithUnitPricingPriceCadenceAnnual, NewFloatingScalableMatrixWithUnitPricingPriceCadenceSemiAnnual, NewFloatingScalableMatrixWithUnitPricingPriceCadenceMonthly, NewFloatingScalableMatrixWithUnitPricingPriceCadenceQuarterly, NewFloatingScalableMatrixWithUnitPricingPriceCadenceOneTime, NewFloatingScalableMatrixWithUnitPricingPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithUnitPricingPriceModelType string

const (
	NewFloatingScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing NewFloatingScalableMatrixWithUnitPricingPriceModelType = "scalable_matrix_with_unit_pricing"
)

func (r NewFloatingScalableMatrixWithUnitPricingPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                         `json:"unit_config"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigParam) implementsNewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigParam].
type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam()
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam() {
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam() {
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType string

const (
	NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeUnit   NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeTiered NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeUnit, NewFloatingScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingThresholdTotalAmountPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                        `json:"item_id,required"`
	ModelType param.Field[NewFloatingThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingThresholdTotalAmountPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingThresholdTotalAmountPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingThresholdTotalAmountPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingThresholdTotalAmountPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingThresholdTotalAmountPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingThresholdTotalAmountPriceCadence string

const (
	NewFloatingThresholdTotalAmountPriceCadenceAnnual     NewFloatingThresholdTotalAmountPriceCadence = "annual"
	NewFloatingThresholdTotalAmountPriceCadenceSemiAnnual NewFloatingThresholdTotalAmountPriceCadence = "semi_annual"
	NewFloatingThresholdTotalAmountPriceCadenceMonthly    NewFloatingThresholdTotalAmountPriceCadence = "monthly"
	NewFloatingThresholdTotalAmountPriceCadenceQuarterly  NewFloatingThresholdTotalAmountPriceCadence = "quarterly"
	NewFloatingThresholdTotalAmountPriceCadenceOneTime    NewFloatingThresholdTotalAmountPriceCadence = "one_time"
	NewFloatingThresholdTotalAmountPriceCadenceCustom     NewFloatingThresholdTotalAmountPriceCadence = "custom"
)

func (r NewFloatingThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingThresholdTotalAmountPriceCadenceAnnual, NewFloatingThresholdTotalAmountPriceCadenceSemiAnnual, NewFloatingThresholdTotalAmountPriceCadenceMonthly, NewFloatingThresholdTotalAmountPriceCadenceQuarterly, NewFloatingThresholdTotalAmountPriceCadenceOneTime, NewFloatingThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingThresholdTotalAmountPriceModelType string

const (
	NewFloatingThresholdTotalAmountPriceModelTypeThresholdTotalAmount NewFloatingThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r NewFloatingThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingThresholdTotalAmountPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                `json:"unit_config"`
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigParam) implementsNewFloatingThresholdTotalAmountPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingThresholdTotalAmountPriceConversionRateConfigParam].
type NewFloatingThresholdTotalAmountPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingThresholdTotalAmountPriceConversionRateConfigUnionParam()
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingThresholdTotalAmountPriceConversionRateConfigUnionParam() {
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingThresholdTotalAmountPriceConversionRateConfigUnionParam() {
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateType string

const (
	NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateTypeUnit   NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateTypeTiered NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateTypeUnit, NewFloatingThresholdTotalAmountPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredBPSPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingTieredBPSPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                             `json:"item_id,required"`
	ModelType param.Field[NewFloatingTieredBPSPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]               `json:"name,required"`
	TieredBPSConfig param.Field[TieredBPSConfigParam] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingTieredBPSPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingTieredBPSPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredBPSPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredBPSPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredBPSPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingTieredBPSPriceCadence string

const (
	NewFloatingTieredBPSPriceCadenceAnnual     NewFloatingTieredBPSPriceCadence = "annual"
	NewFloatingTieredBPSPriceCadenceSemiAnnual NewFloatingTieredBPSPriceCadence = "semi_annual"
	NewFloatingTieredBPSPriceCadenceMonthly    NewFloatingTieredBPSPriceCadence = "monthly"
	NewFloatingTieredBPSPriceCadenceQuarterly  NewFloatingTieredBPSPriceCadence = "quarterly"
	NewFloatingTieredBPSPriceCadenceOneTime    NewFloatingTieredBPSPriceCadence = "one_time"
	NewFloatingTieredBPSPriceCadenceCustom     NewFloatingTieredBPSPriceCadence = "custom"
)

func (r NewFloatingTieredBPSPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingTieredBPSPriceCadenceAnnual, NewFloatingTieredBPSPriceCadenceSemiAnnual, NewFloatingTieredBPSPriceCadenceMonthly, NewFloatingTieredBPSPriceCadenceQuarterly, NewFloatingTieredBPSPriceCadenceOneTime, NewFloatingTieredBPSPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingTieredBPSPriceModelType string

const (
	NewFloatingTieredBPSPriceModelTypeTieredBPS NewFloatingTieredBPSPriceModelType = "tiered_bps"
)

func (r NewFloatingTieredBPSPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingTieredBPSPriceModelTypeTieredBPS:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingTieredBPSPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredBPSPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                     `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                     `json:"unit_config"`
}

func (r NewFloatingTieredBPSPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredBPSPriceConversionRateConfigParam) implementsNewFloatingTieredBPSPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingTieredBPSPriceConversionRateConfigParam].
type NewFloatingTieredBPSPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingTieredBPSPriceConversionRateConfigUnionParam()
}

type NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingTieredBPSPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingTieredBPSPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredBPSPriceConversionRateConfigConversionRateType string

const (
	NewFloatingTieredBPSPriceConversionRateConfigConversionRateTypeUnit   NewFloatingTieredBPSPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingTieredBPSPriceConversionRateConfigConversionRateTypeTiered NewFloatingTieredBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredBPSPriceConversionRateConfigConversionRateTypeUnit, NewFloatingTieredBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewFloatingTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingTieredPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingTieredPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackagePriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredPackagePriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredPackagePriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingTieredPackagePriceCadence string

const (
	NewFloatingTieredPackagePriceCadenceAnnual     NewFloatingTieredPackagePriceCadence = "annual"
	NewFloatingTieredPackagePriceCadenceSemiAnnual NewFloatingTieredPackagePriceCadence = "semi_annual"
	NewFloatingTieredPackagePriceCadenceMonthly    NewFloatingTieredPackagePriceCadence = "monthly"
	NewFloatingTieredPackagePriceCadenceQuarterly  NewFloatingTieredPackagePriceCadence = "quarterly"
	NewFloatingTieredPackagePriceCadenceOneTime    NewFloatingTieredPackagePriceCadence = "one_time"
	NewFloatingTieredPackagePriceCadenceCustom     NewFloatingTieredPackagePriceCadence = "custom"
)

func (r NewFloatingTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackagePriceCadenceAnnual, NewFloatingTieredPackagePriceCadenceSemiAnnual, NewFloatingTieredPackagePriceCadenceMonthly, NewFloatingTieredPackagePriceCadenceQuarterly, NewFloatingTieredPackagePriceCadenceOneTime, NewFloatingTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingTieredPackagePriceModelType string

const (
	NewFloatingTieredPackagePriceModelTypeTieredPackage NewFloatingTieredPackagePriceModelType = "tiered_package"
)

func (r NewFloatingTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingTieredPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewFloatingTieredPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackagePriceConversionRateConfigParam) implementsNewFloatingTieredPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingTieredPackagePriceConversionRateConfigParam].
type NewFloatingTieredPackagePriceConversionRateConfigUnionParam interface {
	implementsNewFloatingTieredPackagePriceConversionRateConfigUnionParam()
}

type NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPackagePriceConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPackagePriceConversionRateConfigConversionRateTypeUnit   NewFloatingTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	NewFloatingTieredPackagePriceConversionRateConfigConversionRateTypeTiered NewFloatingTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackagePriceConversionRateConfigConversionRateTypeUnit, NewFloatingTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredPackageWithMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingTieredPackageWithMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                            `json:"item_id,required"`
	ModelType param.Field[NewFloatingTieredPackageWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                           param.Field[string]                 `json:"name,required"`
	TieredPackageWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_package_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingTieredPackageWithMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackageWithMinimumPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredPackageWithMinimumPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredPackageWithMinimumPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingTieredPackageWithMinimumPriceCadence string

const (
	NewFloatingTieredPackageWithMinimumPriceCadenceAnnual     NewFloatingTieredPackageWithMinimumPriceCadence = "annual"
	NewFloatingTieredPackageWithMinimumPriceCadenceSemiAnnual NewFloatingTieredPackageWithMinimumPriceCadence = "semi_annual"
	NewFloatingTieredPackageWithMinimumPriceCadenceMonthly    NewFloatingTieredPackageWithMinimumPriceCadence = "monthly"
	NewFloatingTieredPackageWithMinimumPriceCadenceQuarterly  NewFloatingTieredPackageWithMinimumPriceCadence = "quarterly"
	NewFloatingTieredPackageWithMinimumPriceCadenceOneTime    NewFloatingTieredPackageWithMinimumPriceCadence = "one_time"
	NewFloatingTieredPackageWithMinimumPriceCadenceCustom     NewFloatingTieredPackageWithMinimumPriceCadence = "custom"
)

func (r NewFloatingTieredPackageWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackageWithMinimumPriceCadenceAnnual, NewFloatingTieredPackageWithMinimumPriceCadenceSemiAnnual, NewFloatingTieredPackageWithMinimumPriceCadenceMonthly, NewFloatingTieredPackageWithMinimumPriceCadenceQuarterly, NewFloatingTieredPackageWithMinimumPriceCadenceOneTime, NewFloatingTieredPackageWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingTieredPackageWithMinimumPriceModelType string

const (
	NewFloatingTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum NewFloatingTieredPackageWithMinimumPriceModelType = "tiered_package_with_minimum"
)

func (r NewFloatingTieredPackageWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                    `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                    `json:"unit_config"`
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigParam) implementsNewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingTieredPackageWithMinimumPriceConversionRateConfigParam].
type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnionParam()
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingTieredPackageWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeUnit   NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeTiered NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeUnit, NewFloatingTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingTieredPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                          `json:"item_id,required"`
	ModelType param.Field[NewFloatingTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]            `json:"name,required"`
	TieredConfig param.Field[TieredConfigParam] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingTieredPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingTieredPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingTieredPriceCadence string

const (
	NewFloatingTieredPriceCadenceAnnual     NewFloatingTieredPriceCadence = "annual"
	NewFloatingTieredPriceCadenceSemiAnnual NewFloatingTieredPriceCadence = "semi_annual"
	NewFloatingTieredPriceCadenceMonthly    NewFloatingTieredPriceCadence = "monthly"
	NewFloatingTieredPriceCadenceQuarterly  NewFloatingTieredPriceCadence = "quarterly"
	NewFloatingTieredPriceCadenceOneTime    NewFloatingTieredPriceCadence = "one_time"
	NewFloatingTieredPriceCadenceCustom     NewFloatingTieredPriceCadence = "custom"
)

func (r NewFloatingTieredPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingTieredPriceCadenceAnnual, NewFloatingTieredPriceCadenceSemiAnnual, NewFloatingTieredPriceCadenceMonthly, NewFloatingTieredPriceCadenceQuarterly, NewFloatingTieredPriceCadenceOneTime, NewFloatingTieredPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingTieredPriceModelType string

const (
	NewFloatingTieredPriceModelTypeTiered NewFloatingTieredPriceModelType = "tiered"
)

func (r NewFloatingTieredPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPriceModelTypeTiered:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingTieredPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                  `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                  `json:"unit_config"`
}

func (r NewFloatingTieredPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPriceConversionRateConfigParam) implementsNewFloatingTieredPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingTieredPriceConversionRateConfigParam].
type NewFloatingTieredPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingTieredPriceConversionRateConfigUnionParam()
}

type NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingTieredPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingTieredPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredPriceConversionRateConfigConversionRateType string

const (
	NewFloatingTieredPriceConversionRateConfigConversionRateTypeUnit   NewFloatingTieredPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingTieredPriceConversionRateConfigConversionRateTypeTiered NewFloatingTieredPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredPriceConversionRateConfigConversionRateTypeUnit, NewFloatingTieredPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredWithMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                     `json:"item_id,required"`
	ModelType param.Field[NewFloatingTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingTieredWithMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingTieredWithMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithMinimumPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredWithMinimumPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredWithMinimumPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingTieredWithMinimumPriceCadence string

const (
	NewFloatingTieredWithMinimumPriceCadenceAnnual     NewFloatingTieredWithMinimumPriceCadence = "annual"
	NewFloatingTieredWithMinimumPriceCadenceSemiAnnual NewFloatingTieredWithMinimumPriceCadence = "semi_annual"
	NewFloatingTieredWithMinimumPriceCadenceMonthly    NewFloatingTieredWithMinimumPriceCadence = "monthly"
	NewFloatingTieredWithMinimumPriceCadenceQuarterly  NewFloatingTieredWithMinimumPriceCadence = "quarterly"
	NewFloatingTieredWithMinimumPriceCadenceOneTime    NewFloatingTieredWithMinimumPriceCadence = "one_time"
	NewFloatingTieredWithMinimumPriceCadenceCustom     NewFloatingTieredWithMinimumPriceCadence = "custom"
)

func (r NewFloatingTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithMinimumPriceCadenceAnnual, NewFloatingTieredWithMinimumPriceCadenceSemiAnnual, NewFloatingTieredWithMinimumPriceCadenceMonthly, NewFloatingTieredWithMinimumPriceCadenceQuarterly, NewFloatingTieredWithMinimumPriceCadenceOneTime, NewFloatingTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingTieredWithMinimumPriceModelType string

const (
	NewFloatingTieredWithMinimumPriceModelTypeTieredWithMinimum NewFloatingTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r NewFloatingTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingTieredWithMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigParam) implementsNewFloatingTieredWithMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingTieredWithMinimumPriceConversionRateConfigParam].
type NewFloatingTieredWithMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingTieredWithMinimumPriceConversionRateConfigUnionParam()
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingTieredWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingTieredWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateType string

const (
	NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateTypeUnit   NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateTypeTiered NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateTypeUnit, NewFloatingTieredWithMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredWithProrationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingTieredWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                       `json:"item_id,required"`
	ModelType param.Field[NewFloatingTieredWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingTieredWithProrationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingTieredWithProrationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithProrationPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredWithProrationPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingTieredWithProrationPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingTieredWithProrationPriceCadence string

const (
	NewFloatingTieredWithProrationPriceCadenceAnnual     NewFloatingTieredWithProrationPriceCadence = "annual"
	NewFloatingTieredWithProrationPriceCadenceSemiAnnual NewFloatingTieredWithProrationPriceCadence = "semi_annual"
	NewFloatingTieredWithProrationPriceCadenceMonthly    NewFloatingTieredWithProrationPriceCadence = "monthly"
	NewFloatingTieredWithProrationPriceCadenceQuarterly  NewFloatingTieredWithProrationPriceCadence = "quarterly"
	NewFloatingTieredWithProrationPriceCadenceOneTime    NewFloatingTieredWithProrationPriceCadence = "one_time"
	NewFloatingTieredWithProrationPriceCadenceCustom     NewFloatingTieredWithProrationPriceCadence = "custom"
)

func (r NewFloatingTieredWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithProrationPriceCadenceAnnual, NewFloatingTieredWithProrationPriceCadenceSemiAnnual, NewFloatingTieredWithProrationPriceCadenceMonthly, NewFloatingTieredWithProrationPriceCadenceQuarterly, NewFloatingTieredWithProrationPriceCadenceOneTime, NewFloatingTieredWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingTieredWithProrationPriceModelType string

const (
	NewFloatingTieredWithProrationPriceModelTypeTieredWithProration NewFloatingTieredWithProrationPriceModelType = "tiered_with_proration"
)

func (r NewFloatingTieredWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingTieredWithProrationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                               `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                               `json:"unit_config"`
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigParam) implementsNewFloatingTieredWithProrationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingTieredWithProrationPriceConversionRateConfigParam].
type NewFloatingTieredWithProrationPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingTieredWithProrationPriceConversionRateConfigUnionParam()
}

type NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingTieredWithProrationPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingTieredWithProrationPriceConversionRateConfigUnionParam() {
}

type NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateType string

const (
	NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateTypeUnit   NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateTypeTiered NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateTypeUnit, NewFloatingTieredWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingUnitPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingUnitPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                        `json:"item_id,required"`
	ModelType param.Field[NewFloatingUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]          `json:"name,required"`
	UnitConfig param.Field[UnitConfigParam] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingUnitPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingUnitPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingUnitPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingUnitPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {}

// The cadence to bill for this price on.
type NewFloatingUnitPriceCadence string

const (
	NewFloatingUnitPriceCadenceAnnual     NewFloatingUnitPriceCadence = "annual"
	NewFloatingUnitPriceCadenceSemiAnnual NewFloatingUnitPriceCadence = "semi_annual"
	NewFloatingUnitPriceCadenceMonthly    NewFloatingUnitPriceCadence = "monthly"
	NewFloatingUnitPriceCadenceQuarterly  NewFloatingUnitPriceCadence = "quarterly"
	NewFloatingUnitPriceCadenceOneTime    NewFloatingUnitPriceCadence = "one_time"
	NewFloatingUnitPriceCadenceCustom     NewFloatingUnitPriceCadence = "custom"
)

func (r NewFloatingUnitPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingUnitPriceCadenceAnnual, NewFloatingUnitPriceCadenceSemiAnnual, NewFloatingUnitPriceCadenceMonthly, NewFloatingUnitPriceCadenceQuarterly, NewFloatingUnitPriceCadenceOneTime, NewFloatingUnitPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingUnitPriceModelType string

const (
	NewFloatingUnitPriceModelTypeUnit NewFloatingUnitPriceModelType = "unit"
)

func (r NewFloatingUnitPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingUnitPriceModelTypeUnit:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingUnitPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                `json:"unit_config"`
}

func (r NewFloatingUnitPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitPriceConversionRateConfigParam) implementsNewFloatingUnitPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingUnitPriceConversionRateConfigParam].
type NewFloatingUnitPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingUnitPriceConversionRateConfigUnionParam()
}

type NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingUnitPriceConversionRateConfigUnionParam() {
}

type NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingUnitPriceConversionRateConfigUnionParam() {
}

type NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitPriceConversionRateConfigConversionRateType string

const (
	NewFloatingUnitPriceConversionRateConfigConversionRateTypeUnit   NewFloatingUnitPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingUnitPriceConversionRateConfigConversionRateTypeTiered NewFloatingUnitPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingUnitPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitPriceConversionRateConfigConversionRateTypeUnit, NewFloatingUnitPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingUnitWithPercentPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingUnitWithPercentPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                   `json:"item_id,required"`
	ModelType param.Field[NewFloatingUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingUnitWithPercentPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingUnitWithPercentPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithPercentPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingUnitWithPercentPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingUnitWithPercentPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingUnitWithPercentPriceCadence string

const (
	NewFloatingUnitWithPercentPriceCadenceAnnual     NewFloatingUnitWithPercentPriceCadence = "annual"
	NewFloatingUnitWithPercentPriceCadenceSemiAnnual NewFloatingUnitWithPercentPriceCadence = "semi_annual"
	NewFloatingUnitWithPercentPriceCadenceMonthly    NewFloatingUnitWithPercentPriceCadence = "monthly"
	NewFloatingUnitWithPercentPriceCadenceQuarterly  NewFloatingUnitWithPercentPriceCadence = "quarterly"
	NewFloatingUnitWithPercentPriceCadenceOneTime    NewFloatingUnitWithPercentPriceCadence = "one_time"
	NewFloatingUnitWithPercentPriceCadenceCustom     NewFloatingUnitWithPercentPriceCadence = "custom"
)

func (r NewFloatingUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithPercentPriceCadenceAnnual, NewFloatingUnitWithPercentPriceCadenceSemiAnnual, NewFloatingUnitWithPercentPriceCadenceMonthly, NewFloatingUnitWithPercentPriceCadenceQuarterly, NewFloatingUnitWithPercentPriceCadenceOneTime, NewFloatingUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingUnitWithPercentPriceModelType string

const (
	NewFloatingUnitWithPercentPriceModelTypeUnitWithPercent NewFloatingUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r NewFloatingUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingUnitWithPercentPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                           `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                           `json:"unit_config"`
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigParam) implementsNewFloatingUnitWithPercentPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingUnitWithPercentPriceConversionRateConfigParam].
type NewFloatingUnitWithPercentPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingUnitWithPercentPriceConversionRateConfigUnionParam()
}

type NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingUnitWithPercentPriceConversionRateConfigUnionParam() {
}

type NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingUnitWithPercentPriceConversionRateConfigUnionParam() {
}

type NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateType string

const (
	NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateTypeUnit   NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateTypeTiered NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateTypeUnit, NewFloatingUnitWithPercentPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingUnitWithProrationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewFloatingUnitWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                     `json:"item_id,required"`
	ModelType param.Field[NewFloatingUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewFloatingUnitWithProrationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewFloatingUnitWithProrationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithProrationPriceParam) ImplementsPriceEvaluateMultipleParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingUnitWithProrationPriceParam) ImplementsPriceEvaluatePreviewEventsParamsPriceEvaluationsPriceUnion() {
}

func (r NewFloatingUnitWithProrationPriceParam) ImplementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type NewFloatingUnitWithProrationPriceCadence string

const (
	NewFloatingUnitWithProrationPriceCadenceAnnual     NewFloatingUnitWithProrationPriceCadence = "annual"
	NewFloatingUnitWithProrationPriceCadenceSemiAnnual NewFloatingUnitWithProrationPriceCadence = "semi_annual"
	NewFloatingUnitWithProrationPriceCadenceMonthly    NewFloatingUnitWithProrationPriceCadence = "monthly"
	NewFloatingUnitWithProrationPriceCadenceQuarterly  NewFloatingUnitWithProrationPriceCadence = "quarterly"
	NewFloatingUnitWithProrationPriceCadenceOneTime    NewFloatingUnitWithProrationPriceCadence = "one_time"
	NewFloatingUnitWithProrationPriceCadenceCustom     NewFloatingUnitWithProrationPriceCadence = "custom"
)

func (r NewFloatingUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithProrationPriceCadenceAnnual, NewFloatingUnitWithProrationPriceCadenceSemiAnnual, NewFloatingUnitWithProrationPriceCadenceMonthly, NewFloatingUnitWithProrationPriceCadenceQuarterly, NewFloatingUnitWithProrationPriceCadenceOneTime, NewFloatingUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type NewFloatingUnitWithProrationPriceModelType string

const (
	NewFloatingUnitWithProrationPriceModelTypeUnitWithProration NewFloatingUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r NewFloatingUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewFloatingUnitWithProrationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigParam) implementsNewFloatingUnitWithProrationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewFloatingUnitWithProrationPriceConversionRateConfigParam].
type NewFloatingUnitWithProrationPriceConversionRateConfigUnionParam interface {
	implementsNewFloatingUnitWithProrationPriceConversionRateConfigUnionParam()
}

type NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewFloatingUnitWithProrationPriceConversionRateConfigUnionParam() {
}

type NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewFloatingUnitWithProrationPriceConversionRateConfigUnionParam() {
}

type NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewFloatingUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateType string

const (
	NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateTypeUnit   NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateType = "unit"
	NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateTypeTiered NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateTypeUnit, NewFloatingUnitWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewMaximumParam struct {
	AdjustmentType param.Field[NewMaximumAdjustmentType] `json:"adjustment_type,required"`
	MaximumAmount  param.Field[string]                   `json:"maximum_amount,required"`
	// If set, the adjustment will apply to every price on the subscription.
	AppliesToAll param.Field[NewMaximumAppliesToAll] `json:"applies_to_all"`
	// The set of item IDs to which this adjustment applies.
	AppliesToItemIDs param.Field[[]string] `json:"applies_to_item_ids"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// If set, only prices in the specified currency will have the adjustment applied.
	Currency param.Field[string] `json:"currency"`
	// A list of filters that determine which prices this adjustment will apply to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// If set, only prices of the specified type will have the adjustment applied.
	PriceType param.Field[NewMaximumPriceType] `json:"price_type"`
}

func (r NewMaximumParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewMaximumParam) ImplementsBetaNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewMaximumParam) ImplementsBetaNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {}

func (r NewMaximumParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewMaximumParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewMaximumParam) ImplementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewMaximumParam) ImplementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {}

func (r NewMaximumParam) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewMaximumParam) ImplementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewMaximumParam) ImplementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type NewMaximumAdjustmentType string

const (
	NewMaximumAdjustmentTypeMaximum NewMaximumAdjustmentType = "maximum"
)

func (r NewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case NewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

// If set, the adjustment will apply to every price on the subscription.
type NewMaximumAppliesToAll bool

const (
	NewMaximumAppliesToAllTrue NewMaximumAppliesToAll = true
)

func (r NewMaximumAppliesToAll) IsKnown() bool {
	switch r {
	case NewMaximumAppliesToAllTrue:
		return true
	}
	return false
}

// If set, only prices of the specified type will have the adjustment applied.
type NewMaximumPriceType string

const (
	NewMaximumPriceTypeUsage          NewMaximumPriceType = "usage"
	NewMaximumPriceTypeFixedInAdvance NewMaximumPriceType = "fixed_in_advance"
	NewMaximumPriceTypeFixedInArrears NewMaximumPriceType = "fixed_in_arrears"
	NewMaximumPriceTypeFixed          NewMaximumPriceType = "fixed"
	NewMaximumPriceTypeInArrears      NewMaximumPriceType = "in_arrears"
)

func (r NewMaximumPriceType) IsKnown() bool {
	switch r {
	case NewMaximumPriceTypeUsage, NewMaximumPriceTypeFixedInAdvance, NewMaximumPriceTypeFixedInArrears, NewMaximumPriceTypeFixed, NewMaximumPriceTypeInArrears:
		return true
	}
	return false
}

type NewMinimumParam struct {
	AdjustmentType param.Field[NewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// If set, the adjustment will apply to every price on the subscription.
	AppliesToAll param.Field[NewMinimumAppliesToAll] `json:"applies_to_all"`
	// The set of item IDs to which this adjustment applies.
	AppliesToItemIDs param.Field[[]string] `json:"applies_to_item_ids"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// If set, only prices in the specified currency will have the adjustment applied.
	Currency param.Field[string] `json:"currency"`
	// A list of filters that determine which prices this adjustment will apply to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// If set, only prices of the specified type will have the adjustment applied.
	PriceType param.Field[NewMinimumPriceType] `json:"price_type"`
}

func (r NewMinimumParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewMinimumParam) ImplementsBetaNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewMinimumParam) ImplementsBetaNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {}

func (r NewMinimumParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewMinimumParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewMinimumParam) ImplementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewMinimumParam) ImplementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {}

func (r NewMinimumParam) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewMinimumParam) ImplementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewMinimumParam) ImplementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type NewMinimumAdjustmentType string

const (
	NewMinimumAdjustmentTypeMinimum NewMinimumAdjustmentType = "minimum"
)

func (r NewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case NewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

// If set, the adjustment will apply to every price on the subscription.
type NewMinimumAppliesToAll bool

const (
	NewMinimumAppliesToAllTrue NewMinimumAppliesToAll = true
)

func (r NewMinimumAppliesToAll) IsKnown() bool {
	switch r {
	case NewMinimumAppliesToAllTrue:
		return true
	}
	return false
}

// If set, only prices of the specified type will have the adjustment applied.
type NewMinimumPriceType string

const (
	NewMinimumPriceTypeUsage          NewMinimumPriceType = "usage"
	NewMinimumPriceTypeFixedInAdvance NewMinimumPriceType = "fixed_in_advance"
	NewMinimumPriceTypeFixedInArrears NewMinimumPriceType = "fixed_in_arrears"
	NewMinimumPriceTypeFixed          NewMinimumPriceType = "fixed"
	NewMinimumPriceTypeInArrears      NewMinimumPriceType = "in_arrears"
)

func (r NewMinimumPriceType) IsKnown() bool {
	switch r {
	case NewMinimumPriceTypeUsage, NewMinimumPriceTypeFixedInAdvance, NewMinimumPriceTypeFixedInArrears, NewMinimumPriceTypeFixed, NewMinimumPriceTypeInArrears:
		return true
	}
	return false
}

type NewPercentageDiscountParam struct {
	AdjustmentType     param.Field[NewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	PercentageDiscount param.Field[float64]                             `json:"percentage_discount,required"`
	// If set, the adjustment will apply to every price on the subscription.
	AppliesToAll param.Field[NewPercentageDiscountAppliesToAll] `json:"applies_to_all"`
	// The set of item IDs to which this adjustment applies.
	AppliesToItemIDs param.Field[[]string] `json:"applies_to_item_ids"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// If set, only prices in the specified currency will have the adjustment applied.
	Currency param.Field[string] `json:"currency"`
	// A list of filters that determine which prices this adjustment will apply to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// If set, only prices of the specified type will have the adjustment applied.
	PriceType param.Field[NewPercentageDiscountPriceType] `json:"price_type"`
}

func (r NewPercentageDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPercentageDiscountParam) ImplementsBetaNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsBetaNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewPercentageDiscountParam) ImplementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewPercentageDiscountParam) ImplementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type NewPercentageDiscountAdjustmentType string

const (
	NewPercentageDiscountAdjustmentTypePercentageDiscount NewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r NewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case NewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

// If set, the adjustment will apply to every price on the subscription.
type NewPercentageDiscountAppliesToAll bool

const (
	NewPercentageDiscountAppliesToAllTrue NewPercentageDiscountAppliesToAll = true
)

func (r NewPercentageDiscountAppliesToAll) IsKnown() bool {
	switch r {
	case NewPercentageDiscountAppliesToAllTrue:
		return true
	}
	return false
}

// If set, only prices of the specified type will have the adjustment applied.
type NewPercentageDiscountPriceType string

const (
	NewPercentageDiscountPriceTypeUsage          NewPercentageDiscountPriceType = "usage"
	NewPercentageDiscountPriceTypeFixedInAdvance NewPercentageDiscountPriceType = "fixed_in_advance"
	NewPercentageDiscountPriceTypeFixedInArrears NewPercentageDiscountPriceType = "fixed_in_arrears"
	NewPercentageDiscountPriceTypeFixed          NewPercentageDiscountPriceType = "fixed"
	NewPercentageDiscountPriceTypeInArrears      NewPercentageDiscountPriceType = "in_arrears"
)

func (r NewPercentageDiscountPriceType) IsKnown() bool {
	switch r {
	case NewPercentageDiscountPriceTypeUsage, NewPercentageDiscountPriceTypeFixedInAdvance, NewPercentageDiscountPriceTypeFixedInArrears, NewPercentageDiscountPriceTypeFixed, NewPercentageDiscountPriceTypeInArrears:
		return true
	}
	return false
}

type NewPlanBPSPriceParam struct {
	BPSConfig param.Field[BPSConfigParam] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanBPSPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                   `json:"item_id,required"`
	ModelType param.Field[NewPlanBPSPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanBPSPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanBPSPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBPSPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanBPSPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanBPSPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanBPSPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanBPSPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanBPSPriceCadence string

const (
	NewPlanBPSPriceCadenceAnnual     NewPlanBPSPriceCadence = "annual"
	NewPlanBPSPriceCadenceSemiAnnual NewPlanBPSPriceCadence = "semi_annual"
	NewPlanBPSPriceCadenceMonthly    NewPlanBPSPriceCadence = "monthly"
	NewPlanBPSPriceCadenceQuarterly  NewPlanBPSPriceCadence = "quarterly"
	NewPlanBPSPriceCadenceOneTime    NewPlanBPSPriceCadence = "one_time"
	NewPlanBPSPriceCadenceCustom     NewPlanBPSPriceCadence = "custom"
)

func (r NewPlanBPSPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanBPSPriceCadenceAnnual, NewPlanBPSPriceCadenceSemiAnnual, NewPlanBPSPriceCadenceMonthly, NewPlanBPSPriceCadenceQuarterly, NewPlanBPSPriceCadenceOneTime, NewPlanBPSPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanBPSPriceModelType string

const (
	NewPlanBPSPriceModelTypeBPS NewPlanBPSPriceModelType = "bps"
)

func (r NewPlanBPSPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanBPSPriceModelTypeBPS:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanBPSPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBPSPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                           `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                           `json:"unit_config"`
}

func (r NewPlanBPSPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBPSPriceConversionRateConfigParam) implementsNewPlanBPSPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanBPSPriceConversionRateConfigParam].
type NewPlanBPSPriceConversionRateConfigUnionParam interface {
	implementsNewPlanBPSPriceConversionRateConfigUnionParam()
}

type NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanBPSPriceConversionRateConfigUnionParam() {
}

type NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanBPSPriceConversionRateConfigUnionParam() {
}

type NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBPSPriceConversionRateConfigConversionRateType string

const (
	NewPlanBPSPriceConversionRateConfigConversionRateTypeUnit   NewPlanBPSPriceConversionRateConfigConversionRateType = "unit"
	NewPlanBPSPriceConversionRateConfigConversionRateTypeTiered NewPlanBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBPSPriceConversionRateConfigConversionRateTypeUnit, NewPlanBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBulkBPSPriceParam struct {
	BulkBPSConfig param.Field[BulkBPSConfigParam] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanBulkBPSPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                       `json:"item_id,required"`
	ModelType param.Field[NewPlanBulkBPSPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanBulkBPSPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanBulkBPSPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkBPSPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanBulkBPSPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanBulkBPSPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanBulkBPSPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanBulkBPSPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanBulkBPSPriceCadence string

const (
	NewPlanBulkBPSPriceCadenceAnnual     NewPlanBulkBPSPriceCadence = "annual"
	NewPlanBulkBPSPriceCadenceSemiAnnual NewPlanBulkBPSPriceCadence = "semi_annual"
	NewPlanBulkBPSPriceCadenceMonthly    NewPlanBulkBPSPriceCadence = "monthly"
	NewPlanBulkBPSPriceCadenceQuarterly  NewPlanBulkBPSPriceCadence = "quarterly"
	NewPlanBulkBPSPriceCadenceOneTime    NewPlanBulkBPSPriceCadence = "one_time"
	NewPlanBulkBPSPriceCadenceCustom     NewPlanBulkBPSPriceCadence = "custom"
)

func (r NewPlanBulkBPSPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanBulkBPSPriceCadenceAnnual, NewPlanBulkBPSPriceCadenceSemiAnnual, NewPlanBulkBPSPriceCadenceMonthly, NewPlanBulkBPSPriceCadenceQuarterly, NewPlanBulkBPSPriceCadenceOneTime, NewPlanBulkBPSPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanBulkBPSPriceModelType string

const (
	NewPlanBulkBPSPriceModelTypeBulkBPS NewPlanBulkBPSPriceModelType = "bulk_bps"
)

func (r NewPlanBulkBPSPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanBulkBPSPriceModelTypeBulkBPS:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanBulkBPSPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkBPSPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                               `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                               `json:"unit_config"`
}

func (r NewPlanBulkBPSPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkBPSPriceConversionRateConfigParam) implementsNewPlanBulkBPSPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanBulkBPSPriceConversionRateConfigParam].
type NewPlanBulkBPSPriceConversionRateConfigUnionParam interface {
	implementsNewPlanBulkBPSPriceConversionRateConfigUnionParam()
}

type NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanBulkBPSPriceConversionRateConfigUnionParam() {
}

type NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanBulkBPSPriceConversionRateConfigUnionParam() {
}

type NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkBPSPriceConversionRateConfigConversionRateType string

const (
	NewPlanBulkBPSPriceConversionRateConfigConversionRateTypeUnit   NewPlanBulkBPSPriceConversionRateConfigConversionRateType = "unit"
	NewPlanBulkBPSPriceConversionRateConfigConversionRateTypeTiered NewPlanBulkBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBulkBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkBPSPriceConversionRateConfigConversionRateTypeUnit, NewPlanBulkBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBulkPriceParam struct {
	BulkConfig param.Field[BulkConfigParam] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanBulkPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                    `json:"item_id,required"`
	ModelType param.Field[NewPlanBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanBulkPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanBulkPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanBulkPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanBulkPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanBulkPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanBulkPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanBulkPriceCadence string

const (
	NewPlanBulkPriceCadenceAnnual     NewPlanBulkPriceCadence = "annual"
	NewPlanBulkPriceCadenceSemiAnnual NewPlanBulkPriceCadence = "semi_annual"
	NewPlanBulkPriceCadenceMonthly    NewPlanBulkPriceCadence = "monthly"
	NewPlanBulkPriceCadenceQuarterly  NewPlanBulkPriceCadence = "quarterly"
	NewPlanBulkPriceCadenceOneTime    NewPlanBulkPriceCadence = "one_time"
	NewPlanBulkPriceCadenceCustom     NewPlanBulkPriceCadence = "custom"
)

func (r NewPlanBulkPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanBulkPriceCadenceAnnual, NewPlanBulkPriceCadenceSemiAnnual, NewPlanBulkPriceCadenceMonthly, NewPlanBulkPriceCadenceQuarterly, NewPlanBulkPriceCadenceOneTime, NewPlanBulkPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanBulkPriceModelType string

const (
	NewPlanBulkPriceModelTypeBulk NewPlanBulkPriceModelType = "bulk"
)

func (r NewPlanBulkPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanBulkPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                            `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                            `json:"unit_config"`
}

func (r NewPlanBulkPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkPriceConversionRateConfigParam) implementsNewPlanBulkPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanBulkPriceConversionRateConfigParam].
type NewPlanBulkPriceConversionRateConfigUnionParam interface {
	implementsNewPlanBulkPriceConversionRateConfigUnionParam()
}

type NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanBulkPriceConversionRateConfigUnionParam() {
}

type NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanBulkPriceConversionRateConfigUnionParam() {
}

type NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkPriceConversionRateConfigConversionRateType string

const (
	NewPlanBulkPriceConversionRateConfigConversionRateTypeUnit   NewPlanBulkPriceConversionRateConfigConversionRateType = "unit"
	NewPlanBulkPriceConversionRateConfigConversionRateTypeTiered NewPlanBulkPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBulkPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkPriceConversionRateConfigConversionRateTypeUnit, NewPlanBulkPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBulkWithProrationPriceParam struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanBulkWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewPlanBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanBulkWithProrationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanBulkWithProrationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkWithProrationPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanBulkWithProrationPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanBulkWithProrationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanBulkWithProrationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanBulkWithProrationPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanBulkWithProrationPriceCadence string

const (
	NewPlanBulkWithProrationPriceCadenceAnnual     NewPlanBulkWithProrationPriceCadence = "annual"
	NewPlanBulkWithProrationPriceCadenceSemiAnnual NewPlanBulkWithProrationPriceCadence = "semi_annual"
	NewPlanBulkWithProrationPriceCadenceMonthly    NewPlanBulkWithProrationPriceCadence = "monthly"
	NewPlanBulkWithProrationPriceCadenceQuarterly  NewPlanBulkWithProrationPriceCadence = "quarterly"
	NewPlanBulkWithProrationPriceCadenceOneTime    NewPlanBulkWithProrationPriceCadence = "one_time"
	NewPlanBulkWithProrationPriceCadenceCustom     NewPlanBulkWithProrationPriceCadence = "custom"
)

func (r NewPlanBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanBulkWithProrationPriceCadenceAnnual, NewPlanBulkWithProrationPriceCadenceSemiAnnual, NewPlanBulkWithProrationPriceCadenceMonthly, NewPlanBulkWithProrationPriceCadenceQuarterly, NewPlanBulkWithProrationPriceCadenceOneTime, NewPlanBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanBulkWithProrationPriceModelType string

const (
	NewPlanBulkWithProrationPriceModelTypeBulkWithProration NewPlanBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r NewPlanBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanBulkWithProrationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkWithProrationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigParam) implementsNewPlanBulkWithProrationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanBulkWithProrationPriceConversionRateConfigParam].
type NewPlanBulkWithProrationPriceConversionRateConfigUnionParam interface {
	implementsNewPlanBulkWithProrationPriceConversionRateConfigUnionParam()
}

type NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanBulkWithProrationPriceConversionRateConfigUnionParam() {
}

type NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanBulkWithProrationPriceConversionRateConfigUnionParam() {
}

type NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanBulkWithProrationPriceConversionRateConfigConversionRateType string

const (
	NewPlanBulkWithProrationPriceConversionRateConfigConversionRateTypeUnit   NewPlanBulkWithProrationPriceConversionRateConfigConversionRateType = "unit"
	NewPlanBulkWithProrationPriceConversionRateConfigConversionRateTypeTiered NewPlanBulkWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanBulkWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanBulkWithProrationPriceConversionRateConfigConversionRateTypeUnit, NewPlanBulkWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanCumulativeGroupedBulkPriceParam struct {
	// The cadence to bill for this price on.
	Cadence                     param.Field[NewPlanCumulativeGroupedBulkPriceCadence] `json:"cadence,required"`
	CumulativeGroupedBulkConfig param.Field[map[string]interface{}]                   `json:"cumulative_grouped_bulk_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                     `json:"item_id,required"`
	ModelType param.Field[NewPlanCumulativeGroupedBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanCumulativeGroupedBulkPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanCumulativeGroupedBulkPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanCumulativeGroupedBulkPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanCumulativeGroupedBulkPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanCumulativeGroupedBulkPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanCumulativeGroupedBulkPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanCumulativeGroupedBulkPriceCadence string

const (
	NewPlanCumulativeGroupedBulkPriceCadenceAnnual     NewPlanCumulativeGroupedBulkPriceCadence = "annual"
	NewPlanCumulativeGroupedBulkPriceCadenceSemiAnnual NewPlanCumulativeGroupedBulkPriceCadence = "semi_annual"
	NewPlanCumulativeGroupedBulkPriceCadenceMonthly    NewPlanCumulativeGroupedBulkPriceCadence = "monthly"
	NewPlanCumulativeGroupedBulkPriceCadenceQuarterly  NewPlanCumulativeGroupedBulkPriceCadence = "quarterly"
	NewPlanCumulativeGroupedBulkPriceCadenceOneTime    NewPlanCumulativeGroupedBulkPriceCadence = "one_time"
	NewPlanCumulativeGroupedBulkPriceCadenceCustom     NewPlanCumulativeGroupedBulkPriceCadence = "custom"
)

func (r NewPlanCumulativeGroupedBulkPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanCumulativeGroupedBulkPriceCadenceAnnual, NewPlanCumulativeGroupedBulkPriceCadenceSemiAnnual, NewPlanCumulativeGroupedBulkPriceCadenceMonthly, NewPlanCumulativeGroupedBulkPriceCadenceQuarterly, NewPlanCumulativeGroupedBulkPriceCadenceOneTime, NewPlanCumulativeGroupedBulkPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanCumulativeGroupedBulkPriceModelType string

const (
	NewPlanCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk NewPlanCumulativeGroupedBulkPriceModelType = "cumulative_grouped_bulk"
)

func (r NewPlanCumulativeGroupedBulkPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanCumulativeGroupedBulkPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigParam) implementsNewPlanCumulativeGroupedBulkPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanCumulativeGroupedBulkPriceConversionRateConfigParam].
type NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnionParam interface {
	implementsNewPlanCumulativeGroupedBulkPriceConversionRateConfigUnionParam()
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanCumulativeGroupedBulkPriceConversionRateConfigUnionParam() {
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanCumulativeGroupedBulkPriceConversionRateConfigUnionParam() {
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateType string

const (
	NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeUnit   NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateType = "unit"
	NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeTiered NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeUnit, NewPlanCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedAllocationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence                 param.Field[NewPlanGroupedAllocationPriceCadence] `json:"cadence,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}]               `json:"grouped_allocation_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewPlanGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanGroupedAllocationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanGroupedAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedAllocationPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanGroupedAllocationPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedAllocationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedAllocationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedAllocationPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanGroupedAllocationPriceCadence string

const (
	NewPlanGroupedAllocationPriceCadenceAnnual     NewPlanGroupedAllocationPriceCadence = "annual"
	NewPlanGroupedAllocationPriceCadenceSemiAnnual NewPlanGroupedAllocationPriceCadence = "semi_annual"
	NewPlanGroupedAllocationPriceCadenceMonthly    NewPlanGroupedAllocationPriceCadence = "monthly"
	NewPlanGroupedAllocationPriceCadenceQuarterly  NewPlanGroupedAllocationPriceCadence = "quarterly"
	NewPlanGroupedAllocationPriceCadenceOneTime    NewPlanGroupedAllocationPriceCadence = "one_time"
	NewPlanGroupedAllocationPriceCadenceCustom     NewPlanGroupedAllocationPriceCadence = "custom"
)

func (r NewPlanGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanGroupedAllocationPriceCadenceAnnual, NewPlanGroupedAllocationPriceCadenceSemiAnnual, NewPlanGroupedAllocationPriceCadenceMonthly, NewPlanGroupedAllocationPriceCadenceQuarterly, NewPlanGroupedAllocationPriceCadenceOneTime, NewPlanGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanGroupedAllocationPriceModelType string

const (
	NewPlanGroupedAllocationPriceModelTypeGroupedAllocation NewPlanGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r NewPlanGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanGroupedAllocationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedAllocationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigParam) implementsNewPlanGroupedAllocationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanGroupedAllocationPriceConversionRateConfigParam].
type NewPlanGroupedAllocationPriceConversionRateConfigUnionParam interface {
	implementsNewPlanGroupedAllocationPriceConversionRateConfigUnionParam()
}

type NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanGroupedAllocationPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanGroupedAllocationPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedAllocationPriceConversionRateConfigConversionRateType string

const (
	NewPlanGroupedAllocationPriceConversionRateConfigConversionRateTypeUnit   NewPlanGroupedAllocationPriceConversionRateConfigConversionRateType = "unit"
	NewPlanGroupedAllocationPriceConversionRateConfigConversionRateTypeTiered NewPlanGroupedAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedAllocationPriceConversionRateConfigConversionRateTypeUnit, NewPlanGroupedAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedTieredPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence                    param.Field[NewPlanGroupedTieredPackagePriceCadence] `json:"cadence,required"`
	GroupedTieredPackageConfig param.Field[map[string]interface{}]                  `json:"grouped_tiered_package_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                    `json:"item_id,required"`
	ModelType param.Field[NewPlanGroupedTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanGroupedTieredPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanGroupedTieredPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPackagePriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedTieredPackagePriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedTieredPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedTieredPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedTieredPackagePriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanGroupedTieredPackagePriceCadence string

const (
	NewPlanGroupedTieredPackagePriceCadenceAnnual     NewPlanGroupedTieredPackagePriceCadence = "annual"
	NewPlanGroupedTieredPackagePriceCadenceSemiAnnual NewPlanGroupedTieredPackagePriceCadence = "semi_annual"
	NewPlanGroupedTieredPackagePriceCadenceMonthly    NewPlanGroupedTieredPackagePriceCadence = "monthly"
	NewPlanGroupedTieredPackagePriceCadenceQuarterly  NewPlanGroupedTieredPackagePriceCadence = "quarterly"
	NewPlanGroupedTieredPackagePriceCadenceOneTime    NewPlanGroupedTieredPackagePriceCadence = "one_time"
	NewPlanGroupedTieredPackagePriceCadenceCustom     NewPlanGroupedTieredPackagePriceCadence = "custom"
)

func (r NewPlanGroupedTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPackagePriceCadenceAnnual, NewPlanGroupedTieredPackagePriceCadenceSemiAnnual, NewPlanGroupedTieredPackagePriceCadenceMonthly, NewPlanGroupedTieredPackagePriceCadenceQuarterly, NewPlanGroupedTieredPackagePriceCadenceOneTime, NewPlanGroupedTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanGroupedTieredPackagePriceModelType string

const (
	NewPlanGroupedTieredPackagePriceModelTypeGroupedTieredPackage NewPlanGroupedTieredPackagePriceModelType = "grouped_tiered_package"
)

func (r NewPlanGroupedTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPackagePriceModelTypeGroupedTieredPackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanGroupedTieredPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                            `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                            `json:"unit_config"`
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigParam) implementsNewPlanGroupedTieredPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanGroupedTieredPackagePriceConversionRateConfigParam].
type NewPlanGroupedTieredPackagePriceConversionRateConfigUnionParam interface {
	implementsNewPlanGroupedTieredPackagePriceConversionRateConfigUnionParam()
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanGroupedTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanGroupedTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateType string

const (
	NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateTypeUnit   NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateTypeTiered NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateTypeUnit, NewPlanGroupedTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedTieredPriceParam struct {
	// The cadence to bill for this price on.
	Cadence             param.Field[NewPlanGroupedTieredPriceCadence] `json:"cadence,required"`
	GroupedTieredConfig param.Field[map[string]interface{}]           `json:"grouped_tiered_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                             `json:"item_id,required"`
	ModelType param.Field[NewPlanGroupedTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanGroupedTieredPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanGroupedTieredPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanGroupedTieredPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanGroupedTieredPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedTieredPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedTieredPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanGroupedTieredPriceCadence string

const (
	NewPlanGroupedTieredPriceCadenceAnnual     NewPlanGroupedTieredPriceCadence = "annual"
	NewPlanGroupedTieredPriceCadenceSemiAnnual NewPlanGroupedTieredPriceCadence = "semi_annual"
	NewPlanGroupedTieredPriceCadenceMonthly    NewPlanGroupedTieredPriceCadence = "monthly"
	NewPlanGroupedTieredPriceCadenceQuarterly  NewPlanGroupedTieredPriceCadence = "quarterly"
	NewPlanGroupedTieredPriceCadenceOneTime    NewPlanGroupedTieredPriceCadence = "one_time"
	NewPlanGroupedTieredPriceCadenceCustom     NewPlanGroupedTieredPriceCadence = "custom"
)

func (r NewPlanGroupedTieredPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPriceCadenceAnnual, NewPlanGroupedTieredPriceCadenceSemiAnnual, NewPlanGroupedTieredPriceCadenceMonthly, NewPlanGroupedTieredPriceCadenceQuarterly, NewPlanGroupedTieredPriceCadenceOneTime, NewPlanGroupedTieredPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanGroupedTieredPriceModelType string

const (
	NewPlanGroupedTieredPriceModelTypeGroupedTiered NewPlanGroupedTieredPriceModelType = "grouped_tiered"
)

func (r NewPlanGroupedTieredPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPriceModelTypeGroupedTiered:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanGroupedTieredPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedTieredPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                     `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                     `json:"unit_config"`
}

func (r NewPlanGroupedTieredPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPriceConversionRateConfigParam) implementsNewPlanGroupedTieredPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanGroupedTieredPriceConversionRateConfigParam].
type NewPlanGroupedTieredPriceConversionRateConfigUnionParam interface {
	implementsNewPlanGroupedTieredPriceConversionRateConfigUnionParam()
}

type NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanGroupedTieredPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanGroupedTieredPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedTieredPriceConversionRateConfigConversionRateType string

const (
	NewPlanGroupedTieredPriceConversionRateConfigConversionRateTypeUnit   NewPlanGroupedTieredPriceConversionRateConfigConversionRateType = "unit"
	NewPlanGroupedTieredPriceConversionRateConfigConversionRateTypeTiered NewPlanGroupedTieredPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedTieredPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedTieredPriceConversionRateConfigConversionRateTypeUnit, NewPlanGroupedTieredPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedWithMeteredMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence                         param.Field[NewPlanGroupedWithMeteredMinimumPriceCadence] `json:"cadence,required"`
	GroupedWithMeteredMinimumConfig param.Field[map[string]interface{}]                       `json:"grouped_with_metered_minimum_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                         `json:"item_id,required"`
	ModelType param.Field[NewPlanGroupedWithMeteredMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithMeteredMinimumPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedWithMeteredMinimumPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedWithMeteredMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedWithMeteredMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedWithMeteredMinimumPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanGroupedWithMeteredMinimumPriceCadence string

const (
	NewPlanGroupedWithMeteredMinimumPriceCadenceAnnual     NewPlanGroupedWithMeteredMinimumPriceCadence = "annual"
	NewPlanGroupedWithMeteredMinimumPriceCadenceSemiAnnual NewPlanGroupedWithMeteredMinimumPriceCadence = "semi_annual"
	NewPlanGroupedWithMeteredMinimumPriceCadenceMonthly    NewPlanGroupedWithMeteredMinimumPriceCadence = "monthly"
	NewPlanGroupedWithMeteredMinimumPriceCadenceQuarterly  NewPlanGroupedWithMeteredMinimumPriceCadence = "quarterly"
	NewPlanGroupedWithMeteredMinimumPriceCadenceOneTime    NewPlanGroupedWithMeteredMinimumPriceCadence = "one_time"
	NewPlanGroupedWithMeteredMinimumPriceCadenceCustom     NewPlanGroupedWithMeteredMinimumPriceCadence = "custom"
)

func (r NewPlanGroupedWithMeteredMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithMeteredMinimumPriceCadenceAnnual, NewPlanGroupedWithMeteredMinimumPriceCadenceSemiAnnual, NewPlanGroupedWithMeteredMinimumPriceCadenceMonthly, NewPlanGroupedWithMeteredMinimumPriceCadenceQuarterly, NewPlanGroupedWithMeteredMinimumPriceCadenceOneTime, NewPlanGroupedWithMeteredMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanGroupedWithMeteredMinimumPriceModelType string

const (
	NewPlanGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum NewPlanGroupedWithMeteredMinimumPriceModelType = "grouped_with_metered_minimum"
)

func (r NewPlanGroupedWithMeteredMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                 `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                 `json:"unit_config"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigParam) implementsNewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigParam].
type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam()
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanGroupedWithMeteredMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType string

const (
	NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeUnit   NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeTiered NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeUnit, NewPlanGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedWithProratedMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence                          param.Field[NewPlanGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}]                        `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                          `json:"item_id,required"`
	ModelType param.Field[NewPlanGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanGroupedWithProratedMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithProratedMinimumPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedWithProratedMinimumPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedWithProratedMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanGroupedWithProratedMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanGroupedWithProratedMinimumPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanGroupedWithProratedMinimumPriceCadence string

const (
	NewPlanGroupedWithProratedMinimumPriceCadenceAnnual     NewPlanGroupedWithProratedMinimumPriceCadence = "annual"
	NewPlanGroupedWithProratedMinimumPriceCadenceSemiAnnual NewPlanGroupedWithProratedMinimumPriceCadence = "semi_annual"
	NewPlanGroupedWithProratedMinimumPriceCadenceMonthly    NewPlanGroupedWithProratedMinimumPriceCadence = "monthly"
	NewPlanGroupedWithProratedMinimumPriceCadenceQuarterly  NewPlanGroupedWithProratedMinimumPriceCadence = "quarterly"
	NewPlanGroupedWithProratedMinimumPriceCadenceOneTime    NewPlanGroupedWithProratedMinimumPriceCadence = "one_time"
	NewPlanGroupedWithProratedMinimumPriceCadenceCustom     NewPlanGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r NewPlanGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithProratedMinimumPriceCadenceAnnual, NewPlanGroupedWithProratedMinimumPriceCadenceSemiAnnual, NewPlanGroupedWithProratedMinimumPriceCadenceMonthly, NewPlanGroupedWithProratedMinimumPriceCadenceQuarterly, NewPlanGroupedWithProratedMinimumPriceCadenceOneTime, NewPlanGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanGroupedWithProratedMinimumPriceModelType string

const (
	NewPlanGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum NewPlanGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r NewPlanGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                  `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                  `json:"unit_config"`
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigParam) implementsNewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanGroupedWithProratedMinimumPriceConversionRateConfigParam].
type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnionParam()
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanGroupedWithProratedMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType string

const (
	NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeUnit   NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeTiered NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeUnit, NewPlanGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMatrixPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanMatrixPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID       param.Field[string]                      `json:"item_id,required"`
	MatrixConfig param.Field[MatrixConfigParam]           `json:"matrix_config,required"`
	ModelType    param.Field[NewPlanMatrixPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanMatrixPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanMatrixPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanMatrixPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanMatrixPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMatrixPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMatrixPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanMatrixPriceCadence string

const (
	NewPlanMatrixPriceCadenceAnnual     NewPlanMatrixPriceCadence = "annual"
	NewPlanMatrixPriceCadenceSemiAnnual NewPlanMatrixPriceCadence = "semi_annual"
	NewPlanMatrixPriceCadenceMonthly    NewPlanMatrixPriceCadence = "monthly"
	NewPlanMatrixPriceCadenceQuarterly  NewPlanMatrixPriceCadence = "quarterly"
	NewPlanMatrixPriceCadenceOneTime    NewPlanMatrixPriceCadence = "one_time"
	NewPlanMatrixPriceCadenceCustom     NewPlanMatrixPriceCadence = "custom"
)

func (r NewPlanMatrixPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanMatrixPriceCadenceAnnual, NewPlanMatrixPriceCadenceSemiAnnual, NewPlanMatrixPriceCadenceMonthly, NewPlanMatrixPriceCadenceQuarterly, NewPlanMatrixPriceCadenceOneTime, NewPlanMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanMatrixPriceModelType string

const (
	NewPlanMatrixPriceModelTypeMatrix NewPlanMatrixPriceModelType = "matrix"
)

func (r NewPlanMatrixPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanMatrixPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                              `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                              `json:"unit_config"`
}

func (r NewPlanMatrixPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixPriceConversionRateConfigParam) implementsNewPlanMatrixPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanMatrixPriceConversionRateConfigParam].
type NewPlanMatrixPriceConversionRateConfigUnionParam interface {
	implementsNewPlanMatrixPriceConversionRateConfigUnionParam()
}

type NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanMatrixPriceConversionRateConfigUnionParam() {
}

type NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanMatrixPriceConversionRateConfigUnionParam() {
}

type NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixPriceConversionRateConfigConversionRateType string

const (
	NewPlanMatrixPriceConversionRateConfigConversionRateTypeUnit   NewPlanMatrixPriceConversionRateConfigConversionRateType = "unit"
	NewPlanMatrixPriceConversionRateConfigConversionRateTypeTiered NewPlanMatrixPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMatrixPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixPriceConversionRateConfigConversionRateTypeUnit, NewPlanMatrixPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMatrixWithAllocationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanMatrixWithAllocationPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID                     param.Field[string]                                    `json:"item_id,required"`
	MatrixWithAllocationConfig param.Field[MatrixWithAllocationConfigParam]           `json:"matrix_with_allocation_config,required"`
	ModelType                  param.Field[NewPlanMatrixWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanMatrixWithAllocationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanMatrixWithAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithAllocationPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMatrixWithAllocationPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMatrixWithAllocationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMatrixWithAllocationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMatrixWithAllocationPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanMatrixWithAllocationPriceCadence string

const (
	NewPlanMatrixWithAllocationPriceCadenceAnnual     NewPlanMatrixWithAllocationPriceCadence = "annual"
	NewPlanMatrixWithAllocationPriceCadenceSemiAnnual NewPlanMatrixWithAllocationPriceCadence = "semi_annual"
	NewPlanMatrixWithAllocationPriceCadenceMonthly    NewPlanMatrixWithAllocationPriceCadence = "monthly"
	NewPlanMatrixWithAllocationPriceCadenceQuarterly  NewPlanMatrixWithAllocationPriceCadence = "quarterly"
	NewPlanMatrixWithAllocationPriceCadenceOneTime    NewPlanMatrixWithAllocationPriceCadence = "one_time"
	NewPlanMatrixWithAllocationPriceCadenceCustom     NewPlanMatrixWithAllocationPriceCadence = "custom"
)

func (r NewPlanMatrixWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithAllocationPriceCadenceAnnual, NewPlanMatrixWithAllocationPriceCadenceSemiAnnual, NewPlanMatrixWithAllocationPriceCadenceMonthly, NewPlanMatrixWithAllocationPriceCadenceQuarterly, NewPlanMatrixWithAllocationPriceCadenceOneTime, NewPlanMatrixWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanMatrixWithAllocationPriceModelType string

const (
	NewPlanMatrixWithAllocationPriceModelTypeMatrixWithAllocation NewPlanMatrixWithAllocationPriceModelType = "matrix_with_allocation"
)

func (r NewPlanMatrixWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithAllocationPriceModelTypeMatrixWithAllocation:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanMatrixWithAllocationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                            `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                            `json:"unit_config"`
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigParam) implementsNewPlanMatrixWithAllocationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanMatrixWithAllocationPriceConversionRateConfigParam].
type NewPlanMatrixWithAllocationPriceConversionRateConfigUnionParam interface {
	implementsNewPlanMatrixWithAllocationPriceConversionRateConfigUnionParam()
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanMatrixWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanMatrixWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateType string

const (
	NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateTypeUnit   NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateType = "unit"
	NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateTypeTiered NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateTypeUnit, NewPlanMatrixWithAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMatrixWithDisplayNamePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanMatrixWithDisplayNamePriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID                      param.Field[string]                                     `json:"item_id,required"`
	MatrixWithDisplayNameConfig param.Field[map[string]interface{}]                     `json:"matrix_with_display_name_config,required"`
	ModelType                   param.Field[NewPlanMatrixWithDisplayNamePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanMatrixWithDisplayNamePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithDisplayNamePriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMatrixWithDisplayNamePriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMatrixWithDisplayNamePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMatrixWithDisplayNamePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMatrixWithDisplayNamePriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanMatrixWithDisplayNamePriceCadence string

const (
	NewPlanMatrixWithDisplayNamePriceCadenceAnnual     NewPlanMatrixWithDisplayNamePriceCadence = "annual"
	NewPlanMatrixWithDisplayNamePriceCadenceSemiAnnual NewPlanMatrixWithDisplayNamePriceCadence = "semi_annual"
	NewPlanMatrixWithDisplayNamePriceCadenceMonthly    NewPlanMatrixWithDisplayNamePriceCadence = "monthly"
	NewPlanMatrixWithDisplayNamePriceCadenceQuarterly  NewPlanMatrixWithDisplayNamePriceCadence = "quarterly"
	NewPlanMatrixWithDisplayNamePriceCadenceOneTime    NewPlanMatrixWithDisplayNamePriceCadence = "one_time"
	NewPlanMatrixWithDisplayNamePriceCadenceCustom     NewPlanMatrixWithDisplayNamePriceCadence = "custom"
)

func (r NewPlanMatrixWithDisplayNamePriceCadence) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithDisplayNamePriceCadenceAnnual, NewPlanMatrixWithDisplayNamePriceCadenceSemiAnnual, NewPlanMatrixWithDisplayNamePriceCadenceMonthly, NewPlanMatrixWithDisplayNamePriceCadenceQuarterly, NewPlanMatrixWithDisplayNamePriceCadenceOneTime, NewPlanMatrixWithDisplayNamePriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanMatrixWithDisplayNamePriceModelType string

const (
	NewPlanMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName NewPlanMatrixWithDisplayNamePriceModelType = "matrix_with_display_name"
)

func (r NewPlanMatrixWithDisplayNamePriceModelType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanMatrixWithDisplayNamePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigParam) implementsNewPlanMatrixWithDisplayNamePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanMatrixWithDisplayNamePriceConversionRateConfigParam].
type NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnionParam interface {
	implementsNewPlanMatrixWithDisplayNamePriceConversionRateConfigUnionParam()
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanMatrixWithDisplayNamePriceConversionRateConfigUnionParam() {
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanMatrixWithDisplayNamePriceConversionRateConfigUnionParam() {
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateType string

const (
	NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeUnit   NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateType = "unit"
	NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeTiered NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeUnit, NewPlanMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMaxGroupTieredPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanMaxGroupTieredPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID                      param.Field[string]                                     `json:"item_id,required"`
	MaxGroupTieredPackageConfig param.Field[map[string]interface{}]                     `json:"max_group_tiered_package_config,required"`
	ModelType                   param.Field[NewPlanMaxGroupTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanMaxGroupTieredPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMaxGroupTieredPackagePriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMaxGroupTieredPackagePriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMaxGroupTieredPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanMaxGroupTieredPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanMaxGroupTieredPackagePriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanMaxGroupTieredPackagePriceCadence string

const (
	NewPlanMaxGroupTieredPackagePriceCadenceAnnual     NewPlanMaxGroupTieredPackagePriceCadence = "annual"
	NewPlanMaxGroupTieredPackagePriceCadenceSemiAnnual NewPlanMaxGroupTieredPackagePriceCadence = "semi_annual"
	NewPlanMaxGroupTieredPackagePriceCadenceMonthly    NewPlanMaxGroupTieredPackagePriceCadence = "monthly"
	NewPlanMaxGroupTieredPackagePriceCadenceQuarterly  NewPlanMaxGroupTieredPackagePriceCadence = "quarterly"
	NewPlanMaxGroupTieredPackagePriceCadenceOneTime    NewPlanMaxGroupTieredPackagePriceCadence = "one_time"
	NewPlanMaxGroupTieredPackagePriceCadenceCustom     NewPlanMaxGroupTieredPackagePriceCadence = "custom"
)

func (r NewPlanMaxGroupTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewPlanMaxGroupTieredPackagePriceCadenceAnnual, NewPlanMaxGroupTieredPackagePriceCadenceSemiAnnual, NewPlanMaxGroupTieredPackagePriceCadenceMonthly, NewPlanMaxGroupTieredPackagePriceCadenceQuarterly, NewPlanMaxGroupTieredPackagePriceCadenceOneTime, NewPlanMaxGroupTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanMaxGroupTieredPackagePriceModelType string

const (
	NewPlanMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage NewPlanMaxGroupTieredPackagePriceModelType = "max_group_tiered_package"
)

func (r NewPlanMaxGroupTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewPlanMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanMaxGroupTieredPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigParam) implementsNewPlanMaxGroupTieredPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanMaxGroupTieredPackagePriceConversionRateConfigParam].
type NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnionParam interface {
	implementsNewPlanMaxGroupTieredPackagePriceConversionRateConfigUnionParam()
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanMaxGroupTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanMaxGroupTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateType string

const (
	NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeUnit   NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeTiered NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeUnit, NewPlanMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                       `json:"item_id,required"`
	ModelType param.Field[NewPlanPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]             `json:"name,required"`
	PackageConfig param.Field[PackageConfigParam] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackagePriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanPackagePriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanPackagePriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanPackagePriceCadence string

const (
	NewPlanPackagePriceCadenceAnnual     NewPlanPackagePriceCadence = "annual"
	NewPlanPackagePriceCadenceSemiAnnual NewPlanPackagePriceCadence = "semi_annual"
	NewPlanPackagePriceCadenceMonthly    NewPlanPackagePriceCadence = "monthly"
	NewPlanPackagePriceCadenceQuarterly  NewPlanPackagePriceCadence = "quarterly"
	NewPlanPackagePriceCadenceOneTime    NewPlanPackagePriceCadence = "one_time"
	NewPlanPackagePriceCadenceCustom     NewPlanPackagePriceCadence = "custom"
)

func (r NewPlanPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewPlanPackagePriceCadenceAnnual, NewPlanPackagePriceCadenceSemiAnnual, NewPlanPackagePriceCadenceMonthly, NewPlanPackagePriceCadenceQuarterly, NewPlanPackagePriceCadenceOneTime, NewPlanPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanPackagePriceModelType string

const (
	NewPlanPackagePriceModelTypePackage NewPlanPackagePriceModelType = "package"
)

func (r NewPlanPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewPlanPackagePriceModelTypePackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                               `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                               `json:"unit_config"`
}

func (r NewPlanPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackagePriceConversionRateConfigParam) implementsNewPlanPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanPackagePriceConversionRateConfigParam].
type NewPlanPackagePriceConversionRateConfigUnionParam interface {
	implementsNewPlanPackagePriceConversionRateConfigUnionParam()
}

type NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanPackagePriceConversionRateConfigConversionRateType string

const (
	NewPlanPackagePriceConversionRateConfigConversionRateTypeUnit   NewPlanPackagePriceConversionRateConfigConversionRateType = "unit"
	NewPlanPackagePriceConversionRateConfigConversionRateTypeTiered NewPlanPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanPackagePriceConversionRateConfigConversionRateTypeUnit, NewPlanPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanPackageWithAllocationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                     `json:"item_id,required"`
	ModelType param.Field[NewPlanPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanPackageWithAllocationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanPackageWithAllocationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackageWithAllocationPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanPackageWithAllocationPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanPackageWithAllocationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanPackageWithAllocationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanPackageWithAllocationPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanPackageWithAllocationPriceCadence string

const (
	NewPlanPackageWithAllocationPriceCadenceAnnual     NewPlanPackageWithAllocationPriceCadence = "annual"
	NewPlanPackageWithAllocationPriceCadenceSemiAnnual NewPlanPackageWithAllocationPriceCadence = "semi_annual"
	NewPlanPackageWithAllocationPriceCadenceMonthly    NewPlanPackageWithAllocationPriceCadence = "monthly"
	NewPlanPackageWithAllocationPriceCadenceQuarterly  NewPlanPackageWithAllocationPriceCadence = "quarterly"
	NewPlanPackageWithAllocationPriceCadenceOneTime    NewPlanPackageWithAllocationPriceCadence = "one_time"
	NewPlanPackageWithAllocationPriceCadenceCustom     NewPlanPackageWithAllocationPriceCadence = "custom"
)

func (r NewPlanPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanPackageWithAllocationPriceCadenceAnnual, NewPlanPackageWithAllocationPriceCadenceSemiAnnual, NewPlanPackageWithAllocationPriceCadenceMonthly, NewPlanPackageWithAllocationPriceCadenceQuarterly, NewPlanPackageWithAllocationPriceCadenceOneTime, NewPlanPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanPackageWithAllocationPriceModelType string

const (
	NewPlanPackageWithAllocationPriceModelTypePackageWithAllocation NewPlanPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r NewPlanPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanPackageWithAllocationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                             `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                             `json:"unit_config"`
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigParam) implementsNewPlanPackageWithAllocationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanPackageWithAllocationPriceConversionRateConfigParam].
type NewPlanPackageWithAllocationPriceConversionRateConfigUnionParam interface {
	implementsNewPlanPackageWithAllocationPriceConversionRateConfigUnionParam()
}

type NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanPackageWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanPackageWithAllocationPriceConversionRateConfigUnionParam() {
}

type NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanPackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateType string

const (
	NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateTypeUnit   NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateType = "unit"
	NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateTypeTiered NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateTypeUnit, NewPlanPackageWithAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithTieredPricingPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanScalableMatrixWithTieredPricingPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                               `json:"item_id,required"`
	ModelType param.Field[NewPlanScalableMatrixWithTieredPricingPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                                  param.Field[string]                 `json:"name,required"`
	ScalableMatrixWithTieredPricingConfig param.Field[map[string]interface{}] `json:"scalable_matrix_with_tiered_pricing_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithTieredPricingPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithTieredPricingPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithTieredPricingPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithTieredPricingPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithTieredPricingPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanScalableMatrixWithTieredPricingPriceCadence string

const (
	NewPlanScalableMatrixWithTieredPricingPriceCadenceAnnual     NewPlanScalableMatrixWithTieredPricingPriceCadence = "annual"
	NewPlanScalableMatrixWithTieredPricingPriceCadenceSemiAnnual NewPlanScalableMatrixWithTieredPricingPriceCadence = "semi_annual"
	NewPlanScalableMatrixWithTieredPricingPriceCadenceMonthly    NewPlanScalableMatrixWithTieredPricingPriceCadence = "monthly"
	NewPlanScalableMatrixWithTieredPricingPriceCadenceQuarterly  NewPlanScalableMatrixWithTieredPricingPriceCadence = "quarterly"
	NewPlanScalableMatrixWithTieredPricingPriceCadenceOneTime    NewPlanScalableMatrixWithTieredPricingPriceCadence = "one_time"
	NewPlanScalableMatrixWithTieredPricingPriceCadenceCustom     NewPlanScalableMatrixWithTieredPricingPriceCadence = "custom"
)

func (r NewPlanScalableMatrixWithTieredPricingPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithTieredPricingPriceCadenceAnnual, NewPlanScalableMatrixWithTieredPricingPriceCadenceSemiAnnual, NewPlanScalableMatrixWithTieredPricingPriceCadenceMonthly, NewPlanScalableMatrixWithTieredPricingPriceCadenceQuarterly, NewPlanScalableMatrixWithTieredPricingPriceCadenceOneTime, NewPlanScalableMatrixWithTieredPricingPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithTieredPricingPriceModelType string

const (
	NewPlanScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing NewPlanScalableMatrixWithTieredPricingPriceModelType = "scalable_matrix_with_tiered_pricing"
)

func (r NewPlanScalableMatrixWithTieredPricingPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                       `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                       `json:"unit_config"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigParam) implementsNewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigParam].
type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam interface {
	implementsNewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam()
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam() {
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigUnionParam() {
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType string

const (
	NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeUnit   NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType = "unit"
	NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeTiered NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeUnit, NewPlanScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithUnitPricingPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanScalableMatrixWithUnitPricingPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                             `json:"item_id,required"`
	ModelType param.Field[NewPlanScalableMatrixWithUnitPricingPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                                param.Field[string]                 `json:"name,required"`
	ScalableMatrixWithUnitPricingConfig param.Field[map[string]interface{}] `json:"scalable_matrix_with_unit_pricing_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithUnitPricingPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithUnitPricingPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithUnitPricingPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithUnitPricingPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanScalableMatrixWithUnitPricingPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanScalableMatrixWithUnitPricingPriceCadence string

const (
	NewPlanScalableMatrixWithUnitPricingPriceCadenceAnnual     NewPlanScalableMatrixWithUnitPricingPriceCadence = "annual"
	NewPlanScalableMatrixWithUnitPricingPriceCadenceSemiAnnual NewPlanScalableMatrixWithUnitPricingPriceCadence = "semi_annual"
	NewPlanScalableMatrixWithUnitPricingPriceCadenceMonthly    NewPlanScalableMatrixWithUnitPricingPriceCadence = "monthly"
	NewPlanScalableMatrixWithUnitPricingPriceCadenceQuarterly  NewPlanScalableMatrixWithUnitPricingPriceCadence = "quarterly"
	NewPlanScalableMatrixWithUnitPricingPriceCadenceOneTime    NewPlanScalableMatrixWithUnitPricingPriceCadence = "one_time"
	NewPlanScalableMatrixWithUnitPricingPriceCadenceCustom     NewPlanScalableMatrixWithUnitPricingPriceCadence = "custom"
)

func (r NewPlanScalableMatrixWithUnitPricingPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithUnitPricingPriceCadenceAnnual, NewPlanScalableMatrixWithUnitPricingPriceCadenceSemiAnnual, NewPlanScalableMatrixWithUnitPricingPriceCadenceMonthly, NewPlanScalableMatrixWithUnitPricingPriceCadenceQuarterly, NewPlanScalableMatrixWithUnitPricingPriceCadenceOneTime, NewPlanScalableMatrixWithUnitPricingPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithUnitPricingPriceModelType string

const (
	NewPlanScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing NewPlanScalableMatrixWithUnitPricingPriceModelType = "scalable_matrix_with_unit_pricing"
)

func (r NewPlanScalableMatrixWithUnitPricingPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                     `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                     `json:"unit_config"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigParam) implementsNewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigParam].
type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam interface {
	implementsNewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam()
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam() {
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigUnionParam() {
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType string

const (
	NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeUnit   NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType = "unit"
	NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeTiered NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeUnit, NewPlanScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanThresholdTotalAmountPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                    `json:"item_id,required"`
	ModelType param.Field[NewPlanThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanThresholdTotalAmountPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanThresholdTotalAmountPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanThresholdTotalAmountPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanThresholdTotalAmountPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanThresholdTotalAmountPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanThresholdTotalAmountPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanThresholdTotalAmountPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanThresholdTotalAmountPriceCadence string

const (
	NewPlanThresholdTotalAmountPriceCadenceAnnual     NewPlanThresholdTotalAmountPriceCadence = "annual"
	NewPlanThresholdTotalAmountPriceCadenceSemiAnnual NewPlanThresholdTotalAmountPriceCadence = "semi_annual"
	NewPlanThresholdTotalAmountPriceCadenceMonthly    NewPlanThresholdTotalAmountPriceCadence = "monthly"
	NewPlanThresholdTotalAmountPriceCadenceQuarterly  NewPlanThresholdTotalAmountPriceCadence = "quarterly"
	NewPlanThresholdTotalAmountPriceCadenceOneTime    NewPlanThresholdTotalAmountPriceCadence = "one_time"
	NewPlanThresholdTotalAmountPriceCadenceCustom     NewPlanThresholdTotalAmountPriceCadence = "custom"
)

func (r NewPlanThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanThresholdTotalAmountPriceCadenceAnnual, NewPlanThresholdTotalAmountPriceCadenceSemiAnnual, NewPlanThresholdTotalAmountPriceCadenceMonthly, NewPlanThresholdTotalAmountPriceCadenceQuarterly, NewPlanThresholdTotalAmountPriceCadenceOneTime, NewPlanThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanThresholdTotalAmountPriceModelType string

const (
	NewPlanThresholdTotalAmountPriceModelTypeThresholdTotalAmount NewPlanThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r NewPlanThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanThresholdTotalAmountPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                            `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                            `json:"unit_config"`
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigParam) implementsNewPlanThresholdTotalAmountPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanThresholdTotalAmountPriceConversionRateConfigParam].
type NewPlanThresholdTotalAmountPriceConversionRateConfigUnionParam interface {
	implementsNewPlanThresholdTotalAmountPriceConversionRateConfigUnionParam()
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanThresholdTotalAmountPriceConversionRateConfigUnionParam() {
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanThresholdTotalAmountPriceConversionRateConfigUnionParam() {
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateType string

const (
	NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateTypeUnit   NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateType = "unit"
	NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateTypeTiered NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateTypeUnit, NewPlanThresholdTotalAmountPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTierWithProrationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanTierWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewPlanTierWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanTierWithProrationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanTierWithProrationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTierWithProrationPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanTierWithProrationPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTierWithProrationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTierWithProrationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTierWithProrationPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanTierWithProrationPriceCadence string

const (
	NewPlanTierWithProrationPriceCadenceAnnual     NewPlanTierWithProrationPriceCadence = "annual"
	NewPlanTierWithProrationPriceCadenceSemiAnnual NewPlanTierWithProrationPriceCadence = "semi_annual"
	NewPlanTierWithProrationPriceCadenceMonthly    NewPlanTierWithProrationPriceCadence = "monthly"
	NewPlanTierWithProrationPriceCadenceQuarterly  NewPlanTierWithProrationPriceCadence = "quarterly"
	NewPlanTierWithProrationPriceCadenceOneTime    NewPlanTierWithProrationPriceCadence = "one_time"
	NewPlanTierWithProrationPriceCadenceCustom     NewPlanTierWithProrationPriceCadence = "custom"
)

func (r NewPlanTierWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanTierWithProrationPriceCadenceAnnual, NewPlanTierWithProrationPriceCadenceSemiAnnual, NewPlanTierWithProrationPriceCadenceMonthly, NewPlanTierWithProrationPriceCadenceQuarterly, NewPlanTierWithProrationPriceCadenceOneTime, NewPlanTierWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanTierWithProrationPriceModelType string

const (
	NewPlanTierWithProrationPriceModelTypeTieredWithProration NewPlanTierWithProrationPriceModelType = "tiered_with_proration"
)

func (r NewPlanTierWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanTierWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanTierWithProrationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTierWithProrationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewPlanTierWithProrationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTierWithProrationPriceConversionRateConfigParam) implementsNewPlanTierWithProrationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanTierWithProrationPriceConversionRateConfigParam].
type NewPlanTierWithProrationPriceConversionRateConfigUnionParam interface {
	implementsNewPlanTierWithProrationPriceConversionRateConfigUnionParam()
}

type NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanTierWithProrationPriceConversionRateConfigUnionParam() {
}

type NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanTierWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanTierWithProrationPriceConversionRateConfigUnionParam() {
}

type NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanTierWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTierWithProrationPriceConversionRateConfigConversionRateType string

const (
	NewPlanTierWithProrationPriceConversionRateConfigConversionRateTypeUnit   NewPlanTierWithProrationPriceConversionRateConfigConversionRateType = "unit"
	NewPlanTierWithProrationPriceConversionRateConfigConversionRateTypeTiered NewPlanTierWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTierWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTierWithProrationPriceConversionRateConfigConversionRateTypeUnit, NewPlanTierWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredBPSPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanTieredBPSPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                         `json:"item_id,required"`
	ModelType param.Field[NewPlanTieredBPSPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]               `json:"name,required"`
	TieredBPSConfig param.Field[TieredBPSConfigParam] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanTieredBPSPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanTieredBPSPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredBPSPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanTieredBPSPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanTieredBPSPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTieredBPSPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredBPSPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanTieredBPSPriceCadence string

const (
	NewPlanTieredBPSPriceCadenceAnnual     NewPlanTieredBPSPriceCadence = "annual"
	NewPlanTieredBPSPriceCadenceSemiAnnual NewPlanTieredBPSPriceCadence = "semi_annual"
	NewPlanTieredBPSPriceCadenceMonthly    NewPlanTieredBPSPriceCadence = "monthly"
	NewPlanTieredBPSPriceCadenceQuarterly  NewPlanTieredBPSPriceCadence = "quarterly"
	NewPlanTieredBPSPriceCadenceOneTime    NewPlanTieredBPSPriceCadence = "one_time"
	NewPlanTieredBPSPriceCadenceCustom     NewPlanTieredBPSPriceCadence = "custom"
)

func (r NewPlanTieredBPSPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanTieredBPSPriceCadenceAnnual, NewPlanTieredBPSPriceCadenceSemiAnnual, NewPlanTieredBPSPriceCadenceMonthly, NewPlanTieredBPSPriceCadenceQuarterly, NewPlanTieredBPSPriceCadenceOneTime, NewPlanTieredBPSPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanTieredBPSPriceModelType string

const (
	NewPlanTieredBPSPriceModelTypeTieredBPS NewPlanTieredBPSPriceModelType = "tiered_bps"
)

func (r NewPlanTieredBPSPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanTieredBPSPriceModelTypeTieredBPS:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanTieredBPSPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredBPSPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                 `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                 `json:"unit_config"`
}

func (r NewPlanTieredBPSPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredBPSPriceConversionRateConfigParam) implementsNewPlanTieredBPSPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanTieredBPSPriceConversionRateConfigParam].
type NewPlanTieredBPSPriceConversionRateConfigUnionParam interface {
	implementsNewPlanTieredBPSPriceConversionRateConfigUnionParam()
}

type NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanTieredBPSPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanTieredBPSPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredBPSPriceConversionRateConfigConversionRateType string

const (
	NewPlanTieredBPSPriceConversionRateConfigConversionRateTypeUnit   NewPlanTieredBPSPriceConversionRateConfigConversionRateType = "unit"
	NewPlanTieredBPSPriceConversionRateConfigConversionRateTypeTiered NewPlanTieredBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredBPSPriceConversionRateConfigConversionRateTypeUnit, NewPlanTieredBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredPackagePriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanTieredPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                             `json:"item_id,required"`
	ModelType param.Field[NewPlanTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanTieredPackagePriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanTieredPackagePriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackagePriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanTieredPackagePriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanTieredPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTieredPackagePriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredPackagePriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanTieredPackagePriceCadence string

const (
	NewPlanTieredPackagePriceCadenceAnnual     NewPlanTieredPackagePriceCadence = "annual"
	NewPlanTieredPackagePriceCadenceSemiAnnual NewPlanTieredPackagePriceCadence = "semi_annual"
	NewPlanTieredPackagePriceCadenceMonthly    NewPlanTieredPackagePriceCadence = "monthly"
	NewPlanTieredPackagePriceCadenceQuarterly  NewPlanTieredPackagePriceCadence = "quarterly"
	NewPlanTieredPackagePriceCadenceOneTime    NewPlanTieredPackagePriceCadence = "one_time"
	NewPlanTieredPackagePriceCadenceCustom     NewPlanTieredPackagePriceCadence = "custom"
)

func (r NewPlanTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case NewPlanTieredPackagePriceCadenceAnnual, NewPlanTieredPackagePriceCadenceSemiAnnual, NewPlanTieredPackagePriceCadenceMonthly, NewPlanTieredPackagePriceCadenceQuarterly, NewPlanTieredPackagePriceCadenceOneTime, NewPlanTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanTieredPackagePriceModelType string

const (
	NewPlanTieredPackagePriceModelTypeTieredPackage NewPlanTieredPackagePriceModelType = "tiered_package"
)

func (r NewPlanTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanTieredPackagePriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPackagePriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                     `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                     `json:"unit_config"`
}

func (r NewPlanTieredPackagePriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackagePriceConversionRateConfigParam) implementsNewPlanTieredPackagePriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanTieredPackagePriceConversionRateConfigParam].
type NewPlanTieredPackagePriceConversionRateConfigUnionParam interface {
	implementsNewPlanTieredPackagePriceConversionRateConfigUnionParam()
}

type NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanTieredPackagePriceConversionRateConfigUnionParam() {
}

type NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPackagePriceConversionRateConfigConversionRateType string

const (
	NewPlanTieredPackagePriceConversionRateConfigConversionRateTypeUnit   NewPlanTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	NewPlanTieredPackagePriceConversionRateConfigConversionRateTypeTiered NewPlanTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackagePriceConversionRateConfigConversionRateTypeUnit, NewPlanTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredPackageWithMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanTieredPackageWithMinimumPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                        `json:"item_id,required"`
	ModelType param.Field[NewPlanTieredPackageWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                           param.Field[string]                 `json:"name,required"`
	TieredPackageWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_package_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanTieredPackageWithMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackageWithMinimumPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTieredPackageWithMinimumPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredPackageWithMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTieredPackageWithMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredPackageWithMinimumPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanTieredPackageWithMinimumPriceCadence string

const (
	NewPlanTieredPackageWithMinimumPriceCadenceAnnual     NewPlanTieredPackageWithMinimumPriceCadence = "annual"
	NewPlanTieredPackageWithMinimumPriceCadenceSemiAnnual NewPlanTieredPackageWithMinimumPriceCadence = "semi_annual"
	NewPlanTieredPackageWithMinimumPriceCadenceMonthly    NewPlanTieredPackageWithMinimumPriceCadence = "monthly"
	NewPlanTieredPackageWithMinimumPriceCadenceQuarterly  NewPlanTieredPackageWithMinimumPriceCadence = "quarterly"
	NewPlanTieredPackageWithMinimumPriceCadenceOneTime    NewPlanTieredPackageWithMinimumPriceCadence = "one_time"
	NewPlanTieredPackageWithMinimumPriceCadenceCustom     NewPlanTieredPackageWithMinimumPriceCadence = "custom"
)

func (r NewPlanTieredPackageWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanTieredPackageWithMinimumPriceCadenceAnnual, NewPlanTieredPackageWithMinimumPriceCadenceSemiAnnual, NewPlanTieredPackageWithMinimumPriceCadenceMonthly, NewPlanTieredPackageWithMinimumPriceCadenceQuarterly, NewPlanTieredPackageWithMinimumPriceCadenceOneTime, NewPlanTieredPackageWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanTieredPackageWithMinimumPriceModelType string

const (
	NewPlanTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum NewPlanTieredPackageWithMinimumPriceModelType = "tiered_package_with_minimum"
)

func (r NewPlanTieredPackageWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanTieredPackageWithMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                                `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                                `json:"unit_config"`
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigParam) implementsNewPlanTieredPackageWithMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanTieredPackageWithMinimumPriceConversionRateConfigParam].
type NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewPlanTieredPackageWithMinimumPriceConversionRateConfigUnionParam()
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanTieredPackageWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanTieredPackageWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateType string

const (
	NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeUnit   NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeTiered NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeUnit, NewPlanTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanTieredPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                      `json:"item_id,required"`
	ModelType param.Field[NewPlanTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]            `json:"name,required"`
	TieredConfig param.Field[TieredConfigParam] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanTieredPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanTieredPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanTieredPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanTieredPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTieredPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanTieredPriceCadence string

const (
	NewPlanTieredPriceCadenceAnnual     NewPlanTieredPriceCadence = "annual"
	NewPlanTieredPriceCadenceSemiAnnual NewPlanTieredPriceCadence = "semi_annual"
	NewPlanTieredPriceCadenceMonthly    NewPlanTieredPriceCadence = "monthly"
	NewPlanTieredPriceCadenceQuarterly  NewPlanTieredPriceCadence = "quarterly"
	NewPlanTieredPriceCadenceOneTime    NewPlanTieredPriceCadence = "one_time"
	NewPlanTieredPriceCadenceCustom     NewPlanTieredPriceCadence = "custom"
)

func (r NewPlanTieredPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanTieredPriceCadenceAnnual, NewPlanTieredPriceCadenceSemiAnnual, NewPlanTieredPriceCadenceMonthly, NewPlanTieredPriceCadenceQuarterly, NewPlanTieredPriceCadenceOneTime, NewPlanTieredPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanTieredPriceModelType string

const (
	NewPlanTieredPriceModelTypeTiered NewPlanTieredPriceModelType = "tiered"
)

func (r NewPlanTieredPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanTieredPriceModelTypeTiered:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanTieredPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                              `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                              `json:"unit_config"`
}

func (r NewPlanTieredPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPriceConversionRateConfigParam) implementsNewPlanTieredPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanTieredPriceConversionRateConfigParam].
type NewPlanTieredPriceConversionRateConfigUnionParam interface {
	implementsNewPlanTieredPriceConversionRateConfigUnionParam()
}

type NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanTieredPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanTieredPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredPriceConversionRateConfigConversionRateType string

const (
	NewPlanTieredPriceConversionRateConfigConversionRateTypeUnit   NewPlanTieredPriceConversionRateConfigConversionRateType = "unit"
	NewPlanTieredPriceConversionRateConfigConversionRateTypeTiered NewPlanTieredPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredPriceConversionRateConfigConversionRateTypeUnit, NewPlanTieredPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredWithMinimumPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewPlanTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanTieredWithMinimumPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanTieredWithMinimumPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredWithMinimumPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanTieredWithMinimumPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredWithMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanTieredWithMinimumPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanTieredWithMinimumPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanTieredWithMinimumPriceCadence string

const (
	NewPlanTieredWithMinimumPriceCadenceAnnual     NewPlanTieredWithMinimumPriceCadence = "annual"
	NewPlanTieredWithMinimumPriceCadenceSemiAnnual NewPlanTieredWithMinimumPriceCadence = "semi_annual"
	NewPlanTieredWithMinimumPriceCadenceMonthly    NewPlanTieredWithMinimumPriceCadence = "monthly"
	NewPlanTieredWithMinimumPriceCadenceQuarterly  NewPlanTieredWithMinimumPriceCadence = "quarterly"
	NewPlanTieredWithMinimumPriceCadenceOneTime    NewPlanTieredWithMinimumPriceCadence = "one_time"
	NewPlanTieredWithMinimumPriceCadenceCustom     NewPlanTieredWithMinimumPriceCadence = "custom"
)

func (r NewPlanTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanTieredWithMinimumPriceCadenceAnnual, NewPlanTieredWithMinimumPriceCadenceSemiAnnual, NewPlanTieredWithMinimumPriceCadenceMonthly, NewPlanTieredWithMinimumPriceCadenceQuarterly, NewPlanTieredWithMinimumPriceCadenceOneTime, NewPlanTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanTieredWithMinimumPriceModelType string

const (
	NewPlanTieredWithMinimumPriceModelTypeTieredWithMinimum NewPlanTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r NewPlanTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanTieredWithMinimumPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigParam) implementsNewPlanTieredWithMinimumPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanTieredWithMinimumPriceConversionRateConfigParam].
type NewPlanTieredWithMinimumPriceConversionRateConfigUnionParam interface {
	implementsNewPlanTieredWithMinimumPriceConversionRateConfigUnionParam()
}

type NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanTieredWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanTieredWithMinimumPriceConversionRateConfigUnionParam() {
}

type NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateType string

const (
	NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateTypeUnit   NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateType = "unit"
	NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateTypeTiered NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateTypeUnit, NewPlanTieredWithMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanUnitPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanUnitPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                    `json:"item_id,required"`
	ModelType param.Field[NewPlanUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]          `json:"name,required"`
	UnitConfig param.Field[UnitConfigParam] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanUnitPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanUnitPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanUnitPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {}

func (r NewPlanUnitPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanUnitPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanUnitPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanUnitPriceCadence string

const (
	NewPlanUnitPriceCadenceAnnual     NewPlanUnitPriceCadence = "annual"
	NewPlanUnitPriceCadenceSemiAnnual NewPlanUnitPriceCadence = "semi_annual"
	NewPlanUnitPriceCadenceMonthly    NewPlanUnitPriceCadence = "monthly"
	NewPlanUnitPriceCadenceQuarterly  NewPlanUnitPriceCadence = "quarterly"
	NewPlanUnitPriceCadenceOneTime    NewPlanUnitPriceCadence = "one_time"
	NewPlanUnitPriceCadenceCustom     NewPlanUnitPriceCadence = "custom"
)

func (r NewPlanUnitPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanUnitPriceCadenceAnnual, NewPlanUnitPriceCadenceSemiAnnual, NewPlanUnitPriceCadenceMonthly, NewPlanUnitPriceCadenceQuarterly, NewPlanUnitPriceCadenceOneTime, NewPlanUnitPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanUnitPriceModelType string

const (
	NewPlanUnitPriceModelTypeUnit NewPlanUnitPriceModelType = "unit"
)

func (r NewPlanUnitPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanUnitPriceModelTypeUnit:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanUnitPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                            `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                            `json:"unit_config"`
}

func (r NewPlanUnitPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitPriceConversionRateConfigParam) implementsNewPlanUnitPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanUnitPriceConversionRateConfigParam].
type NewPlanUnitPriceConversionRateConfigUnionParam interface {
	implementsNewPlanUnitPriceConversionRateConfigUnionParam()
}

type NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanUnitPriceConversionRateConfigUnionParam() {
}

type NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanUnitPriceConversionRateConfigUnionParam() {
}

type NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitPriceConversionRateConfigConversionRateType string

const (
	NewPlanUnitPriceConversionRateConfigConversionRateTypeUnit   NewPlanUnitPriceConversionRateConfigConversionRateType = "unit"
	NewPlanUnitPriceConversionRateConfigConversionRateTypeTiered NewPlanUnitPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanUnitPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitPriceConversionRateConfigConversionRateTypeUnit, NewPlanUnitPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanUnitWithPercentPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanUnitWithPercentPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                               `json:"item_id,required"`
	ModelType param.Field[NewPlanUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanUnitWithPercentPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanUnitWithPercentPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithPercentPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanUnitWithPercentPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanUnitWithPercentPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanUnitWithPercentPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanUnitWithPercentPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanUnitWithPercentPriceCadence string

const (
	NewPlanUnitWithPercentPriceCadenceAnnual     NewPlanUnitWithPercentPriceCadence = "annual"
	NewPlanUnitWithPercentPriceCadenceSemiAnnual NewPlanUnitWithPercentPriceCadence = "semi_annual"
	NewPlanUnitWithPercentPriceCadenceMonthly    NewPlanUnitWithPercentPriceCadence = "monthly"
	NewPlanUnitWithPercentPriceCadenceQuarterly  NewPlanUnitWithPercentPriceCadence = "quarterly"
	NewPlanUnitWithPercentPriceCadenceOneTime    NewPlanUnitWithPercentPriceCadence = "one_time"
	NewPlanUnitWithPercentPriceCadenceCustom     NewPlanUnitWithPercentPriceCadence = "custom"
)

func (r NewPlanUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanUnitWithPercentPriceCadenceAnnual, NewPlanUnitWithPercentPriceCadenceSemiAnnual, NewPlanUnitWithPercentPriceCadenceMonthly, NewPlanUnitWithPercentPriceCadenceQuarterly, NewPlanUnitWithPercentPriceCadenceOneTime, NewPlanUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanUnitWithPercentPriceModelType string

const (
	NewPlanUnitWithPercentPriceModelTypeUnitWithPercent NewPlanUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r NewPlanUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanUnitWithPercentPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitWithPercentPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                       `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                       `json:"unit_config"`
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigParam) implementsNewPlanUnitWithPercentPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanUnitWithPercentPriceConversionRateConfigParam].
type NewPlanUnitWithPercentPriceConversionRateConfigUnionParam interface {
	implementsNewPlanUnitWithPercentPriceConversionRateConfigUnionParam()
}

type NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanUnitWithPercentPriceConversionRateConfigUnionParam() {
}

type NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanUnitWithPercentPriceConversionRateConfigUnionParam() {
}

type NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitWithPercentPriceConversionRateConfigConversionRateType string

const (
	NewPlanUnitWithPercentPriceConversionRateConfigConversionRateTypeUnit   NewPlanUnitWithPercentPriceConversionRateConfigConversionRateType = "unit"
	NewPlanUnitWithPercentPriceConversionRateConfigConversionRateTypeTiered NewPlanUnitWithPercentPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanUnitWithPercentPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithPercentPriceConversionRateConfigConversionRateTypeUnit, NewPlanUnitWithPercentPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanUnitWithProrationPriceParam struct {
	// The cadence to bill for this price on.
	Cadence param.Field[NewPlanUnitWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                 `json:"item_id,required"`
	ModelType param.Field[NewPlanUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// The configuration for the rate of the price currency to the invoicing currency.
	ConversionRateConfig param.Field[NewPlanUnitWithProrationPriceConversionRateConfigUnionParam] `json:"conversion_rate_config"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// For dimensional price: specifies a price group and dimension values
	DimensionalPriceConfiguration param.Field[NewDimensionalPriceConfigurationParam] `json:"dimensional_price_configuration"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[NewBillingCycleConfigurationParam] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r NewPlanUnitWithProrationPriceParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithProrationPriceParam) ImplementsBetaNewPlanVersionParamsAddPricesPriceUnion() {}

func (r NewPlanUnitWithProrationPriceParam) ImplementsBetaNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanUnitWithProrationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddPricesPriceUnion() {
}

func (r NewPlanUnitWithProrationPriceParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplacePricesPriceUnion() {
}

func (r NewPlanUnitWithProrationPriceParam) ImplementsPlanNewParamsPriceUnion() {}

// The cadence to bill for this price on.
type NewPlanUnitWithProrationPriceCadence string

const (
	NewPlanUnitWithProrationPriceCadenceAnnual     NewPlanUnitWithProrationPriceCadence = "annual"
	NewPlanUnitWithProrationPriceCadenceSemiAnnual NewPlanUnitWithProrationPriceCadence = "semi_annual"
	NewPlanUnitWithProrationPriceCadenceMonthly    NewPlanUnitWithProrationPriceCadence = "monthly"
	NewPlanUnitWithProrationPriceCadenceQuarterly  NewPlanUnitWithProrationPriceCadence = "quarterly"
	NewPlanUnitWithProrationPriceCadenceOneTime    NewPlanUnitWithProrationPriceCadence = "one_time"
	NewPlanUnitWithProrationPriceCadenceCustom     NewPlanUnitWithProrationPriceCadence = "custom"
)

func (r NewPlanUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case NewPlanUnitWithProrationPriceCadenceAnnual, NewPlanUnitWithProrationPriceCadenceSemiAnnual, NewPlanUnitWithProrationPriceCadenceMonthly, NewPlanUnitWithProrationPriceCadenceQuarterly, NewPlanUnitWithProrationPriceCadenceOneTime, NewPlanUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type NewPlanUnitWithProrationPriceModelType string

const (
	NewPlanUnitWithProrationPriceModelTypeUnitWithProration NewPlanUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r NewPlanUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// The configuration for the rate of the price currency to the invoicing currency.
type NewPlanUnitWithProrationPriceConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitWithProrationPriceConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[interface{}]                                                         `json:"tiered_config"`
	UnitConfig         param.Field[interface{}]                                                         `json:"unit_config"`
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigParam) implementsNewPlanUnitWithProrationPriceConversionRateConfigUnionParam() {
}

// The configuration for the rate of the price currency to the invoicing currency.
//
// Satisfied by
// [shared.NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam],
// [shared.NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam],
// [NewPlanUnitWithProrationPriceConversionRateConfigParam].
type NewPlanUnitWithProrationPriceConversionRateConfigUnionParam interface {
	implementsNewPlanUnitWithProrationPriceConversionRateConfigUnionParam()
}

type NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	UnitConfig         param.Field[NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam]    `json:"unit_config,required"`
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigParam) implementsNewPlanUnitWithProrationPriceConversionRateConfigUnionParam() {
}

type NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam struct {
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam struct {
	ConversionRateType param.Field[NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType] `json:"conversion_rate_type,required"`
	TieredConfig       param.Field[NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam]  `json:"tiered_config,required"`
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigParam) implementsNewPlanUnitWithProrationPriceConversionRateConfigUnionParam() {
}

type NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam] `json:"tiers,required"`
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r NewPlanUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type NewPlanUnitWithProrationPriceConversionRateConfigConversionRateType string

const (
	NewPlanUnitWithProrationPriceConversionRateConfigConversionRateTypeUnit   NewPlanUnitWithProrationPriceConversionRateConfigConversionRateType = "unit"
	NewPlanUnitWithProrationPriceConversionRateConfigConversionRateTypeTiered NewPlanUnitWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r NewPlanUnitWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case NewPlanUnitWithProrationPriceConversionRateConfigConversionRateTypeUnit, NewPlanUnitWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type NewUsageDiscountParam struct {
	AdjustmentType param.Field[NewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	UsageDiscount  param.Field[float64]                        `json:"usage_discount,required"`
	// If set, the adjustment will apply to every price on the subscription.
	AppliesToAll param.Field[NewUsageDiscountAppliesToAll] `json:"applies_to_all"`
	// The set of item IDs to which this adjustment applies.
	AppliesToItemIDs param.Field[[]string] `json:"applies_to_item_ids"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// If set, only prices in the specified currency will have the adjustment applied.
	Currency param.Field[string] `json:"currency"`
	// A list of filters that determine which prices this adjustment will apply to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// If set, only prices of the specified type will have the adjustment applied.
	PriceType param.Field[NewUsageDiscountPriceType] `json:"price_type"`
}

func (r NewUsageDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r NewUsageDiscountParam) ImplementsBetaNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewUsageDiscountParam) ImplementsBetaNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewUsageDiscountParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewUsageDiscountParam) ImplementsBetaExternalPlanIDNewPlanVersionParamsReplaceAdjustmentsAdjustmentUnion() {
}

func (r NewUsageDiscountParam) ImplementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {}

func (r NewUsageDiscountParam) ImplementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {}

func (r NewUsageDiscountParam) ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewUsageDiscountParam) ImplementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

func (r NewUsageDiscountParam) ImplementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type NewUsageDiscountAdjustmentType string

const (
	NewUsageDiscountAdjustmentTypeUsageDiscount NewUsageDiscountAdjustmentType = "usage_discount"
)

func (r NewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case NewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

// If set, the adjustment will apply to every price on the subscription.
type NewUsageDiscountAppliesToAll bool

const (
	NewUsageDiscountAppliesToAllTrue NewUsageDiscountAppliesToAll = true
)

func (r NewUsageDiscountAppliesToAll) IsKnown() bool {
	switch r {
	case NewUsageDiscountAppliesToAllTrue:
		return true
	}
	return false
}

// If set, only prices of the specified type will have the adjustment applied.
type NewUsageDiscountPriceType string

const (
	NewUsageDiscountPriceTypeUsage          NewUsageDiscountPriceType = "usage"
	NewUsageDiscountPriceTypeFixedInAdvance NewUsageDiscountPriceType = "fixed_in_advance"
	NewUsageDiscountPriceTypeFixedInArrears NewUsageDiscountPriceType = "fixed_in_arrears"
	NewUsageDiscountPriceTypeFixed          NewUsageDiscountPriceType = "fixed"
	NewUsageDiscountPriceTypeInArrears      NewUsageDiscountPriceType = "in_arrears"
)

func (r NewUsageDiscountPriceType) IsKnown() bool {
	switch r {
	case NewUsageDiscountPriceTypeUsage, NewUsageDiscountPriceTypeFixedInAdvance, NewUsageDiscountPriceTypeFixedInArrears, NewUsageDiscountPriceTypeFixed, NewUsageDiscountPriceTypeInArrears:
		return true
	}
	return false
}

type OtherSubLineItem struct {
	// The total amount for this sub line item.
	Amount   string               `json:"amount,required"`
	Grouping SubLineItemGrouping  `json:"grouping,required,nullable"`
	Name     string               `json:"name,required"`
	Quantity float64              `json:"quantity,required"`
	Type     OtherSubLineItemType `json:"type,required"`
	JSON     otherSubLineItemJSON `json:"-"`
}

// otherSubLineItemJSON contains the JSON metadata for the struct
// [OtherSubLineItem]
type otherSubLineItemJSON struct {
	Amount      apijson.Field
	Grouping    apijson.Field
	Name        apijson.Field
	Quantity    apijson.Field
	Type        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *OtherSubLineItem) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r otherSubLineItemJSON) RawJSON() string {
	return r.raw
}

func (r OtherSubLineItem) ImplementsInvoiceLineItemsSubLineItem() {}

func (r OtherSubLineItem) ImplementsInvoiceLineItemNewResponseSubLineItem() {}

func (r OtherSubLineItem) ImplementsInvoiceFetchUpcomingResponseLineItemsSubLineItem() {}

type OtherSubLineItemType string

const (
	OtherSubLineItemTypeNull OtherSubLineItemType = "'null'"
)

func (r OtherSubLineItemType) IsKnown() bool {
	switch r {
	case OtherSubLineItemTypeNull:
		return true
	}
	return false
}

type PackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount string `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize int64             `json:"package_size,required"`
	JSON        packageConfigJSON `json:"-"`
}

// packageConfigJSON contains the JSON metadata for the struct [PackageConfig]
type packageConfigJSON struct {
	PackageAmount apijson.Field
	PackageSize   apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *PackageConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r packageConfigJSON) RawJSON() string {
	return r.raw
}

type PackageConfigParam struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r PackageConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type PaginationMetadata struct {
	HasMore    bool                   `json:"has_more,required"`
	NextCursor string                 `json:"next_cursor,required,nullable"`
	JSON       paginationMetadataJSON `json:"-"`
}

// paginationMetadataJSON contains the JSON metadata for the struct
// [PaginationMetadata]
type paginationMetadataJSON struct {
	HasMore     apijson.Field
	NextCursor  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PaginationMetadata) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r paginationMetadataJSON) RawJSON() string {
	return r.raw
}

type PerPriceCost struct {
	// The price object
	Price Price `json:"price,required"`
	// The price the cost is associated with
	PriceID string `json:"price_id,required"`
	// Price's contributions for the timeframe, excluding any minimums and discounts.
	Subtotal string `json:"subtotal,required"`
	// Price's contributions for the timeframe, including minimums and discounts.
	Total string `json:"total,required"`
	// The price's quantity for the timeframe
	Quantity float64          `json:"quantity,nullable"`
	JSON     perPriceCostJSON `json:"-"`
}

// perPriceCostJSON contains the JSON metadata for the struct [PerPriceCost]
type perPriceCostJSON struct {
	Price       apijson.Field
	PriceID     apijson.Field
	Subtotal    apijson.Field
	Total       apijson.Field
	Quantity    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PerPriceCost) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r perPriceCostJSON) RawJSON() string {
	return r.raw
}

type PercentageDiscount struct {
	DiscountType PercentageDiscountDiscountType `json:"discount_type,required"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,nullable"`
	// The filters that determine which prices to apply this discount to.
	Filters []TransformPriceFilter `json:"filters,nullable"`
	Reason  string                 `json:"reason,nullable"`
	JSON    percentageDiscountJSON `json:"-"`
}

// percentageDiscountJSON contains the JSON metadata for the struct
// [PercentageDiscount]
type percentageDiscountJSON struct {
	DiscountType       apijson.Field
	PercentageDiscount apijson.Field
	AppliesToPriceIDs  apijson.Field
	Filters            apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PercentageDiscount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r percentageDiscountJSON) RawJSON() string {
	return r.raw
}

func (r PercentageDiscount) ImplementsDiscount() {}

func (r PercentageDiscount) ImplementsInvoiceLevelDiscount() {}

func (r PercentageDiscount) ImplementsCouponDiscount() {}

type PercentageDiscountDiscountType string

const (
	PercentageDiscountDiscountTypePercentage PercentageDiscountDiscountType = "percentage"
)

func (r PercentageDiscountDiscountType) IsKnown() bool {
	switch r {
	case PercentageDiscountDiscountTypePercentage:
		return true
	}
	return false
}

type PercentageDiscountParam struct {
	DiscountType param.Field[PercentageDiscountDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// The filters that determine which prices to apply this discount to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	Reason  param.Field[string]                      `json:"reason"`
}

func (r PercentageDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r PercentageDiscountParam) ImplementsDiscountUnionParam() {}

type PercentageDiscountInterval struct {
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                               `json:"applies_to_price_interval_ids,required"`
	DiscountType              PercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The filters that determine which prices this discount interval applies to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                      `json:"start_date,required" format:"date-time"`
	JSON      percentageDiscountIntervalJSON `json:"-"`
}

// percentageDiscountIntervalJSON contains the JSON metadata for the struct
// [PercentageDiscountInterval]
type percentageDiscountIntervalJSON struct {
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	Filters                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *PercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r percentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r PercentageDiscountInterval) ImplementsSubscriptionDiscountInterval() {}

func (r PercentageDiscountInterval) ImplementsMutatedSubscriptionDiscountInterval() {}

type PercentageDiscountIntervalDiscountType string

const (
	PercentageDiscountIntervalDiscountTypePercentage PercentageDiscountIntervalDiscountType = "percentage"
)

func (r PercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case PercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type PlanPhaseAmountDiscountAdjustment struct {
	ID             string                                          `json:"id,required"`
	AdjustmentType PlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                `json:"reason,required,nullable"`
	JSON   planPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// planPhaseAmountDiscountAdjustmentJSON contains the JSON metadata for the struct
// [PlanPhaseAmountDiscountAdjustment]
type planPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *PlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r planPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r PlanPhaseAmountDiscountAdjustment) ImplementsAdjustmentIntervalAdjustment() {}

func (r PlanPhaseAmountDiscountAdjustment) ImplementsPlanVersionAdjustment() {}

func (r PlanPhaseAmountDiscountAdjustment) ImplementsPlanAdjustment() {}

type PlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	PlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount PlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r PlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case PlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type PlanPhaseMaximumAdjustment struct {
	ID             string                                   `json:"id,required"`
	AdjustmentType PlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                         `json:"reason,required,nullable"`
	JSON   planPhaseMaximumAdjustmentJSON `json:"-"`
}

// planPhaseMaximumAdjustmentJSON contains the JSON metadata for the struct
// [PlanPhaseMaximumAdjustment]
type planPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *PlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r planPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r PlanPhaseMaximumAdjustment) ImplementsAdjustmentIntervalAdjustment() {}

func (r PlanPhaseMaximumAdjustment) ImplementsPlanVersionAdjustment() {}

func (r PlanPhaseMaximumAdjustment) ImplementsPlanAdjustment() {}

type PlanPhaseMaximumAdjustmentAdjustmentType string

const (
	PlanPhaseMaximumAdjustmentAdjustmentTypeMaximum PlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r PlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case PlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type PlanPhaseMinimumAdjustment struct {
	ID             string                                   `json:"id,required"`
	AdjustmentType PlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                         `json:"reason,required,nullable"`
	JSON   planPhaseMinimumAdjustmentJSON `json:"-"`
}

// planPhaseMinimumAdjustmentJSON contains the JSON metadata for the struct
// [PlanPhaseMinimumAdjustment]
type planPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *PlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r planPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r PlanPhaseMinimumAdjustment) ImplementsAdjustmentIntervalAdjustment() {}

func (r PlanPhaseMinimumAdjustment) ImplementsPlanVersionAdjustment() {}

func (r PlanPhaseMinimumAdjustment) ImplementsPlanAdjustment() {}

type PlanPhaseMinimumAdjustmentAdjustmentType string

const (
	PlanPhaseMinimumAdjustmentAdjustmentTypeMinimum PlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r PlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case PlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type PlanPhasePercentageDiscountAdjustment struct {
	ID             string                                              `json:"id,required"`
	AdjustmentType PlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                    `json:"reason,required,nullable"`
	JSON   planPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// planPhasePercentageDiscountAdjustmentJSON contains the JSON metadata for the
// struct [PlanPhasePercentageDiscountAdjustment]
type planPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	Filters            apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r planPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r PlanPhasePercentageDiscountAdjustment) ImplementsAdjustmentIntervalAdjustment() {}

func (r PlanPhasePercentageDiscountAdjustment) ImplementsPlanVersionAdjustment() {}

func (r PlanPhasePercentageDiscountAdjustment) ImplementsPlanAdjustment() {}

type PlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	PlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount PlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r PlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case PlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type PlanPhaseUsageDiscountAdjustment struct {
	ID             string                                         `json:"id,required"`
	AdjustmentType PlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	//
	// Deprecated: deprecated
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The filters that determine which prices to apply this adjustment to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                              `json:"usage_discount,required"`
	JSON          planPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// planPhaseUsageDiscountAdjustmentJSON contains the JSON metadata for the struct
// [PlanPhaseUsageDiscountAdjustment]
type planPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *PlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r planPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r PlanPhaseUsageDiscountAdjustment) ImplementsAdjustmentIntervalAdjustment() {}

func (r PlanPhaseUsageDiscountAdjustment) ImplementsPlanVersionAdjustment() {}

func (r PlanPhaseUsageDiscountAdjustment) ImplementsPlanAdjustment() {}

type PlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	PlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount PlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r PlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case PlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

// The Price resource represents a price that can be billed on a subscription,
// resulting in a charge on an invoice in the form of an invoice line item. Prices
// take a quantity and determine an amount to bill.
//
// Orb supports a few different pricing models out of the box. Each of these models
// is serialized differently in a given Price object. The model_type field
// determines the key for the configuration object that is present.
//
// For more on the types of prices, see
// [the core concepts documentation](/core-concepts#plan-and-price)
type Price struct {
	ID                        string                    `json:"id,required"`
	BillableMetric            BillableMetricTiny        `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration `json:"billing_cycle_configuration,required"`
	Cadence                   PriceCadence              `json:"cadence,required"`
	ConversionRate            float64                   `json:"conversion_rate,required,nullable"`
	// This field can have the runtime type of [PriceUnitPriceConversionRateConfig],
	// [PricePackagePriceConversionRateConfig], [PriceMatrixPriceConversionRateConfig],
	// [PriceTieredPriceConversionRateConfig],
	// [PriceTieredBPSPriceConversionRateConfig], [PriceBPSPriceConversionRateConfig],
	// [PriceBulkBPSPriceConversionRateConfig], [PriceBulkPriceConversionRateConfig],
	// [PriceThresholdTotalAmountPriceConversionRateConfig],
	// [PriceTieredPackagePriceConversionRateConfig],
	// [PriceGroupedTieredPriceConversionRateConfig],
	// [PriceTieredWithMinimumPriceConversionRateConfig],
	// [PriceTieredPackageWithMinimumPriceConversionRateConfig],
	// [PricePackageWithAllocationPriceConversionRateConfig],
	// [PriceUnitWithPercentPriceConversionRateConfig],
	// [PriceMatrixWithAllocationPriceConversionRateConfig],
	// [PriceTieredWithProrationPriceConversionRateConfig],
	// [PriceUnitWithProrationPriceConversionRateConfig],
	// [PriceGroupedAllocationPriceConversionRateConfig],
	// [PriceGroupedWithProratedMinimumPriceConversionRateConfig],
	// [PriceGroupedWithMeteredMinimumPriceConversionRateConfig],
	// [PriceMatrixWithDisplayNamePriceConversionRateConfig],
	// [PriceBulkWithProrationPriceConversionRateConfig],
	// [PriceGroupedTieredPackagePriceConversionRateConfig],
	// [PriceMaxGroupTieredPackagePriceConversionRateConfig],
	// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfig],
	// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfig],
	// [PriceCumulativeGroupedBulkPriceConversionRateConfig].
	ConversionRateConfig interface{} `json:"conversion_rate_config,required"`
	CreatedAt            time.Time   `json:"created_at,required" format:"date-time"`
	CreditAllocation     Allocation  `json:"credit_allocation,required,nullable"`
	Currency             string      `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// This field can have the runtime type of [map[string]string].
	Metadata interface{} `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount  string         `json:"minimum_amount,required,nullable"`
	ModelType      PriceModelType `json:"model_type,required"`
	Name           string         `json:"name,required"`
	PlanPhaseOrder int64          `json:"plan_phase_order,required,nullable"`
	PriceType      PricePriceType `json:"price_type,required"`
	BPSConfig      BPSConfig      `json:"bps_config"`
	BulkBPSConfig  BulkBPSConfig  `json:"bulk_bps_config"`
	BulkConfig     BulkConfig     `json:"bulk_config"`
	// This field can have the runtime type of [map[string]interface{}].
	BulkWithProrationConfig interface{} `json:"bulk_with_proration_config"`
	// This field can have the runtime type of [map[string]interface{}].
	CumulativeGroupedBulkConfig   interface{}                   `json:"cumulative_grouped_bulk_config"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	// This field can have the runtime type of [map[string]interface{}].
	GroupedAllocationConfig interface{} `json:"grouped_allocation_config"`
	// This field can have the runtime type of [map[string]interface{}].
	GroupedTieredConfig interface{} `json:"grouped_tiered_config"`
	// This field can have the runtime type of [map[string]interface{}].
	GroupedTieredPackageConfig interface{} `json:"grouped_tiered_package_config"`
	// This field can have the runtime type of [map[string]interface{}].
	GroupedWithMeteredMinimumConfig interface{} `json:"grouped_with_metered_minimum_config"`
	// This field can have the runtime type of [map[string]interface{}].
	GroupedWithProratedMinimumConfig interface{}                `json:"grouped_with_prorated_minimum_config"`
	MatrixConfig                     MatrixConfig               `json:"matrix_config"`
	MatrixWithAllocationConfig       MatrixWithAllocationConfig `json:"matrix_with_allocation_config"`
	// This field can have the runtime type of [map[string]interface{}].
	MatrixWithDisplayNameConfig interface{} `json:"matrix_with_display_name_config"`
	// This field can have the runtime type of [map[string]interface{}].
	MaxGroupTieredPackageConfig interface{}   `json:"max_group_tiered_package_config"`
	PackageConfig               PackageConfig `json:"package_config"`
	// This field can have the runtime type of [map[string]interface{}].
	PackageWithAllocationConfig interface{} `json:"package_with_allocation_config"`
	// This field can have the runtime type of [map[string]interface{}].
	ScalableMatrixWithTieredPricingConfig interface{} `json:"scalable_matrix_with_tiered_pricing_config"`
	// This field can have the runtime type of [map[string]interface{}].
	ScalableMatrixWithUnitPricingConfig interface{} `json:"scalable_matrix_with_unit_pricing_config"`
	// This field can have the runtime type of [map[string]interface{}].
	ThresholdTotalAmountConfig interface{}     `json:"threshold_total_amount_config"`
	TieredBPSConfig            TieredBPSConfig `json:"tiered_bps_config"`
	TieredConfig               TieredConfig    `json:"tiered_config"`
	// This field can have the runtime type of [map[string]interface{}].
	TieredPackageConfig interface{} `json:"tiered_package_config"`
	// This field can have the runtime type of [map[string]interface{}].
	TieredPackageWithMinimumConfig interface{} `json:"tiered_package_with_minimum_config"`
	// This field can have the runtime type of [map[string]interface{}].
	TieredWithMinimumConfig interface{} `json:"tiered_with_minimum_config"`
	// This field can have the runtime type of [map[string]interface{}].
	TieredWithProrationConfig interface{} `json:"tiered_with_proration_config"`
	UnitConfig                UnitConfig  `json:"unit_config"`
	// This field can have the runtime type of [map[string]interface{}].
	UnitWithPercentConfig interface{} `json:"unit_with_percent_config"`
	// This field can have the runtime type of [map[string]interface{}].
	UnitWithProrationConfig interface{} `json:"unit_with_proration_config"`
	JSON                    priceJSON   `json:"-"`
	union                   PriceUnion
}

// priceJSON contains the JSON metadata for the struct [Price]
type priceJSON struct {
	ID                                    apijson.Field
	BillableMetric                        apijson.Field
	BillingCycleConfiguration             apijson.Field
	Cadence                               apijson.Field
	ConversionRate                        apijson.Field
	ConversionRateConfig                  apijson.Field
	CreatedAt                             apijson.Field
	CreditAllocation                      apijson.Field
	Currency                              apijson.Field
	Discount                              apijson.Field
	ExternalPriceID                       apijson.Field
	FixedPriceQuantity                    apijson.Field
	InvoicingCycleConfiguration           apijson.Field
	Item                                  apijson.Field
	Maximum                               apijson.Field
	MaximumAmount                         apijson.Field
	Metadata                              apijson.Field
	Minimum                               apijson.Field
	MinimumAmount                         apijson.Field
	ModelType                             apijson.Field
	Name                                  apijson.Field
	PlanPhaseOrder                        apijson.Field
	PriceType                             apijson.Field
	BPSConfig                             apijson.Field
	BulkBPSConfig                         apijson.Field
	BulkConfig                            apijson.Field
	BulkWithProrationConfig               apijson.Field
	CumulativeGroupedBulkConfig           apijson.Field
	DimensionalPriceConfiguration         apijson.Field
	GroupedAllocationConfig               apijson.Field
	GroupedTieredConfig                   apijson.Field
	GroupedTieredPackageConfig            apijson.Field
	GroupedWithMeteredMinimumConfig       apijson.Field
	GroupedWithProratedMinimumConfig      apijson.Field
	MatrixConfig                          apijson.Field
	MatrixWithAllocationConfig            apijson.Field
	MatrixWithDisplayNameConfig           apijson.Field
	MaxGroupTieredPackageConfig           apijson.Field
	PackageConfig                         apijson.Field
	PackageWithAllocationConfig           apijson.Field
	ScalableMatrixWithTieredPricingConfig apijson.Field
	ScalableMatrixWithUnitPricingConfig   apijson.Field
	ThresholdTotalAmountConfig            apijson.Field
	TieredBPSConfig                       apijson.Field
	TieredConfig                          apijson.Field
	TieredPackageConfig                   apijson.Field
	TieredPackageWithMinimumConfig        apijson.Field
	TieredWithMinimumConfig               apijson.Field
	TieredWithProrationConfig             apijson.Field
	UnitConfig                            apijson.Field
	UnitWithPercentConfig                 apijson.Field
	UnitWithProrationConfig               apijson.Field
	raw                                   string
	ExtraFields                           map[string]apijson.Field
}

func (r priceJSON) RawJSON() string {
	return r.raw
}

func (r *Price) UnmarshalJSON(data []byte) (err error) {
	*r = Price{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceUnion] interface which you can cast to the specific
// types for more type safety.
//
// Possible runtime types of the union are [PriceUnitPrice], [PricePackagePrice],
// [PriceMatrixPrice], [PriceTieredPrice], [PriceTieredBPSPrice], [PriceBPSPrice],
// [PriceBulkBPSPrice], [PriceBulkPrice], [PriceThresholdTotalAmountPrice],
// [PriceTieredPackagePrice], [PriceGroupedTieredPrice],
// [PriceTieredWithMinimumPrice], [PriceTieredPackageWithMinimumPrice],
// [PricePackageWithAllocationPrice], [PriceUnitWithPercentPrice],
// [PriceMatrixWithAllocationPrice], [PriceTieredWithProrationPrice],
// [PriceUnitWithProrationPrice], [PriceGroupedAllocationPrice],
// [PriceGroupedWithProratedMinimumPrice], [PriceGroupedWithMeteredMinimumPrice],
// [PriceMatrixWithDisplayNamePrice], [PriceBulkWithProrationPrice],
// [PriceGroupedTieredPackagePrice], [PriceMaxGroupTieredPackagePrice],
// [PriceScalableMatrixWithUnitPricingPrice],
// [PriceScalableMatrixWithTieredPricingPrice], [PriceCumulativeGroupedBulkPrice].
func (r Price) AsUnion() PriceUnion {
	return r.union
}

// The Price resource represents a price that can be billed on a subscription,
// resulting in a charge on an invoice in the form of an invoice line item. Prices
// take a quantity and determine an amount to bill.
//
// Orb supports a few different pricing models out of the box. Each of these models
// is serialized differently in a given Price object. The model_type field
// determines the key for the configuration object that is present.
//
// For more on the types of prices, see
// [the core concepts documentation](/core-concepts#plan-and-price)
//
// Union satisfied by [PriceUnitPrice], [PricePackagePrice], [PriceMatrixPrice],
// [PriceTieredPrice], [PriceTieredBPSPrice], [PriceBPSPrice], [PriceBulkBPSPrice],
// [PriceBulkPrice], [PriceThresholdTotalAmountPrice], [PriceTieredPackagePrice],
// [PriceGroupedTieredPrice], [PriceTieredWithMinimumPrice],
// [PriceTieredPackageWithMinimumPrice], [PricePackageWithAllocationPrice],
// [PriceUnitWithPercentPrice], [PriceMatrixWithAllocationPrice],
// [PriceTieredWithProrationPrice], [PriceUnitWithProrationPrice],
// [PriceGroupedAllocationPrice], [PriceGroupedWithProratedMinimumPrice],
// [PriceGroupedWithMeteredMinimumPrice], [PriceMatrixWithDisplayNamePrice],
// [PriceBulkWithProrationPrice], [PriceGroupedTieredPackagePrice],
// [PriceMaxGroupTieredPackagePrice], [PriceScalableMatrixWithUnitPricingPrice],
// [PriceScalableMatrixWithTieredPricingPrice] or
// [PriceCumulativeGroupedBulkPrice].
type PriceUnion interface {
	implementsPrice()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceUnion)(nil)).Elem(),
		"model_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitPrice{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PricePackagePrice{}),
			DiscriminatorValue: "package",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixPrice{}),
			DiscriminatorValue: "matrix",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPrice{}),
			DiscriminatorValue: "tiered",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredBPSPrice{}),
			DiscriminatorValue: "tiered_bps",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBPSPrice{}),
			DiscriminatorValue: "bps",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkBPSPrice{}),
			DiscriminatorValue: "bulk_bps",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkPrice{}),
			DiscriminatorValue: "bulk",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceThresholdTotalAmountPrice{}),
			DiscriminatorValue: "threshold_total_amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPackagePrice{}),
			DiscriminatorValue: "tiered_package",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedTieredPrice{}),
			DiscriminatorValue: "grouped_tiered",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredWithMinimumPrice{}),
			DiscriminatorValue: "tiered_with_minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPackageWithMinimumPrice{}),
			DiscriminatorValue: "tiered_package_with_minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PricePackageWithAllocationPrice{}),
			DiscriminatorValue: "package_with_allocation",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitWithPercentPrice{}),
			DiscriminatorValue: "unit_with_percent",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixWithAllocationPrice{}),
			DiscriminatorValue: "matrix_with_allocation",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredWithProrationPrice{}),
			DiscriminatorValue: "tiered_with_proration",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitWithProrationPrice{}),
			DiscriminatorValue: "unit_with_proration",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedAllocationPrice{}),
			DiscriminatorValue: "grouped_allocation",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedWithProratedMinimumPrice{}),
			DiscriminatorValue: "grouped_with_prorated_minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedWithMeteredMinimumPrice{}),
			DiscriminatorValue: "grouped_with_metered_minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixWithDisplayNamePrice{}),
			DiscriminatorValue: "matrix_with_display_name",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkWithProrationPrice{}),
			DiscriminatorValue: "bulk_with_proration",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedTieredPackagePrice{}),
			DiscriminatorValue: "grouped_tiered_package",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMaxGroupTieredPackagePrice{}),
			DiscriminatorValue: "max_group_tiered_package",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceScalableMatrixWithUnitPricingPrice{}),
			DiscriminatorValue: "scalable_matrix_with_unit_pricing",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceScalableMatrixWithTieredPricingPrice{}),
			DiscriminatorValue: "scalable_matrix_with_tiered_pricing",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceCumulativeGroupedBulkPrice{}),
			DiscriminatorValue: "cumulative_grouped_bulk",
		},
	)
}

type PriceUnitPrice struct {
	ID                        string                             `json:"id,required"`
	BillableMetric            BillableMetricTiny                 `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration          `json:"billing_cycle_configuration,required"`
	Cadence                   PriceUnitPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                            `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceUnitPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                          `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                         `json:"credit_allocation,required,nullable"`
	Currency                  string                             `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceUnitPriceModelType       `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceUnitPricePriceType       `json:"price_type,required"`
	UnitConfig                    UnitConfig                    `json:"unit_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceUnitPriceJSON            `json:"-"`
}

// priceUnitPriceJSON contains the JSON metadata for the struct [PriceUnitPrice]
type priceUnitPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	UnitConfig                    apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceUnitPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitPrice) implementsPrice() {}

type PriceUnitPriceCadence string

const (
	PriceUnitPriceCadenceOneTime    PriceUnitPriceCadence = "one_time"
	PriceUnitPriceCadenceMonthly    PriceUnitPriceCadence = "monthly"
	PriceUnitPriceCadenceQuarterly  PriceUnitPriceCadence = "quarterly"
	PriceUnitPriceCadenceSemiAnnual PriceUnitPriceCadence = "semi_annual"
	PriceUnitPriceCadenceAnnual     PriceUnitPriceCadence = "annual"
	PriceUnitPriceCadenceCustom     PriceUnitPriceCadence = "custom"
)

func (r PriceUnitPriceCadence) IsKnown() bool {
	switch r {
	case PriceUnitPriceCadenceOneTime, PriceUnitPriceCadenceMonthly, PriceUnitPriceCadenceQuarterly, PriceUnitPriceCadenceSemiAnnual, PriceUnitPriceCadenceAnnual, PriceUnitPriceCadenceCustom:
		return true
	}
	return false
}

type PriceUnitPriceConversionRateConfig struct {
	ConversionRateType PriceUnitPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                            `json:"unit_config"`
	JSON       priceUnitPriceConversionRateConfigJSON `json:"-"`
	union      PriceUnitPriceConversionRateConfigUnion
}

// priceUnitPriceConversionRateConfigJSON contains the JSON metadata for the struct
// [PriceUnitPriceConversionRateConfig]
type priceUnitPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceUnitPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceUnitPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceUnitPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceUnitPriceConversionRateConfigUnion] interface which you
// can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceUnitPriceConversionRateConfigUnitConversionRateConfig],
// [PriceUnitPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceUnitPriceConversionRateConfig) AsUnion() PriceUnitPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by [PriceUnitPriceConversionRateConfigUnitConversionRateConfig]
// or [PriceUnitPriceConversionRateConfigTieredConversionRateConfig].
type PriceUnitPriceConversionRateConfigUnion interface {
	implementsPriceUnitPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceUnitPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceUnitPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceUnitPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceUnitPriceConversionRateConfigUnitConversionRateConfigJSON contains the JSON
// metadata for the struct
// [PriceUnitPriceConversionRateConfigUnitConversionRateConfig]
type priceUnitPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceUnitPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitPriceConversionRateConfigUnitConversionRateConfig) implementsPriceUnitPriceConversionRateConfig() {
}

type PriceUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                   `json:"unit_amount,required"`
	JSON       priceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceUnitPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceUnitPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceUnitPriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceUnitPriceConversionRateConfigTieredConversionRateConfig]
type priceUnitPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceUnitPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitPriceConversionRateConfigTieredConversionRateConfig) implementsPriceUnitPriceConversionRateConfig() {
}

type PriceUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                          `json:"last_unit,nullable"`
	JSON     priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceUnitPriceConversionRateConfigConversionRateType string

const (
	PriceUnitPriceConversionRateConfigConversionRateTypeUnit   PriceUnitPriceConversionRateConfigConversionRateType = "unit"
	PriceUnitPriceConversionRateConfigConversionRateTypeTiered PriceUnitPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceUnitPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitPriceConversionRateConfigConversionRateTypeUnit, PriceUnitPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceUnitPriceModelType string

const (
	PriceUnitPriceModelTypeUnit PriceUnitPriceModelType = "unit"
)

func (r PriceUnitPriceModelType) IsKnown() bool {
	switch r {
	case PriceUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type PriceUnitPricePriceType string

const (
	PriceUnitPricePriceTypeUsagePrice PriceUnitPricePriceType = "usage_price"
	PriceUnitPricePriceTypeFixedPrice PriceUnitPricePriceType = "fixed_price"
)

func (r PriceUnitPricePriceType) IsKnown() bool {
	switch r {
	case PriceUnitPricePriceTypeUsagePrice, PriceUnitPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PricePackagePrice struct {
	ID                        string                                `json:"id,required"`
	BillableMetric            BillableMetricTiny                    `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration             `json:"billing_cycle_configuration,required"`
	Cadence                   PricePackagePriceCadence              `json:"cadence,required"`
	ConversionRate            float64                               `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PricePackagePriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                             `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                            `json:"credit_allocation,required,nullable"`
	Currency                  string                                `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PricePackagePriceModelType    `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PackageConfig                 PackageConfig                 `json:"package_config,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PricePackagePricePriceType    `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          pricePackagePriceJSON         `json:"-"`
}

// pricePackagePriceJSON contains the JSON metadata for the struct
// [PricePackagePrice]
type pricePackagePriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PackageConfig                 apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PricePackagePrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackagePriceJSON) RawJSON() string {
	return r.raw
}

func (r PricePackagePrice) implementsPrice() {}

type PricePackagePriceCadence string

const (
	PricePackagePriceCadenceOneTime    PricePackagePriceCadence = "one_time"
	PricePackagePriceCadenceMonthly    PricePackagePriceCadence = "monthly"
	PricePackagePriceCadenceQuarterly  PricePackagePriceCadence = "quarterly"
	PricePackagePriceCadenceSemiAnnual PricePackagePriceCadence = "semi_annual"
	PricePackagePriceCadenceAnnual     PricePackagePriceCadence = "annual"
	PricePackagePriceCadenceCustom     PricePackagePriceCadence = "custom"
)

func (r PricePackagePriceCadence) IsKnown() bool {
	switch r {
	case PricePackagePriceCadenceOneTime, PricePackagePriceCadenceMonthly, PricePackagePriceCadenceQuarterly, PricePackagePriceCadenceSemiAnnual, PricePackagePriceCadenceAnnual, PricePackagePriceCadenceCustom:
		return true
	}
	return false
}

type PricePackagePriceConversionRateConfig struct {
	ConversionRateType PricePackagePriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                               `json:"unit_config"`
	JSON       pricePackagePriceConversionRateConfigJSON `json:"-"`
	union      PricePackagePriceConversionRateConfigUnion
}

// pricePackagePriceConversionRateConfigJSON contains the JSON metadata for the
// struct [PricePackagePriceConversionRateConfig]
type pricePackagePriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r pricePackagePriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PricePackagePriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PricePackagePriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PricePackagePriceConversionRateConfigUnion] interface which
// you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PricePackagePriceConversionRateConfigUnitConversionRateConfig],
// [PricePackagePriceConversionRateConfigTieredConversionRateConfig].
func (r PricePackagePriceConversionRateConfig) AsUnion() PricePackagePriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PricePackagePriceConversionRateConfigUnitConversionRateConfig] or
// [PricePackagePriceConversionRateConfigTieredConversionRateConfig].
type PricePackagePriceConversionRateConfigUnion interface {
	implementsPricePackagePriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PricePackagePriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PricePackagePriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PricePackagePriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PricePackagePriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PricePackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               pricePackagePriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// pricePackagePriceConversionRateConfigUnitConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PricePackagePriceConversionRateConfigUnitConversionRateConfig]
type pricePackagePriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PricePackagePriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackagePriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PricePackagePriceConversionRateConfigUnitConversionRateConfig) implementsPricePackagePriceConversionRateConfig() {
}

type PricePackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PricePackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PricePackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PricePackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PricePackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                      `json:"unit_amount,required"`
	JSON       pricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// pricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type pricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PricePackagePriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PricePackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               pricePackagePriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// pricePackagePriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PricePackagePriceConversionRateConfigTieredConversionRateConfig]
type pricePackagePriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PricePackagePriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackagePriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PricePackagePriceConversionRateConfigTieredConversionRateConfig) implementsPricePackagePriceConversionRateConfig() {
}

type PricePackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PricePackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PricePackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PricePackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PricePackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                             `json:"last_unit,nullable"`
	JSON     pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PricePackagePriceConversionRateConfigConversionRateType string

const (
	PricePackagePriceConversionRateConfigConversionRateTypeUnit   PricePackagePriceConversionRateConfigConversionRateType = "unit"
	PricePackagePriceConversionRateConfigConversionRateTypeTiered PricePackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r PricePackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PricePackagePriceConversionRateConfigConversionRateTypeUnit, PricePackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PricePackagePriceModelType string

const (
	PricePackagePriceModelTypePackage PricePackagePriceModelType = "package"
)

func (r PricePackagePriceModelType) IsKnown() bool {
	switch r {
	case PricePackagePriceModelTypePackage:
		return true
	}
	return false
}

type PricePackagePricePriceType string

const (
	PricePackagePricePriceTypeUsagePrice PricePackagePricePriceType = "usage_price"
	PricePackagePricePriceTypeFixedPrice PricePackagePricePriceType = "fixed_price"
)

func (r PricePackagePricePriceType) IsKnown() bool {
	switch r {
	case PricePackagePricePriceTypeUsagePrice, PricePackagePricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceMatrixPrice struct {
	ID                        string                               `json:"id,required"`
	BillableMetric            BillableMetricTiny                   `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration            `json:"billing_cycle_configuration,required"`
	Cadence                   PriceMatrixPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                              `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceMatrixPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                            `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                           `json:"credit_allocation,required,nullable"`
	Currency                  string                               `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	MatrixConfig                MatrixConfig              `json:"matrix_config,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceMatrixPriceModelType     `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceMatrixPricePriceType     `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceMatrixPriceJSON          `json:"-"`
}

// priceMatrixPriceJSON contains the JSON metadata for the struct
// [PriceMatrixPrice]
type priceMatrixPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	MatrixConfig                  apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceMatrixPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixPrice) implementsPrice() {}

type PriceMatrixPriceCadence string

const (
	PriceMatrixPriceCadenceOneTime    PriceMatrixPriceCadence = "one_time"
	PriceMatrixPriceCadenceMonthly    PriceMatrixPriceCadence = "monthly"
	PriceMatrixPriceCadenceQuarterly  PriceMatrixPriceCadence = "quarterly"
	PriceMatrixPriceCadenceSemiAnnual PriceMatrixPriceCadence = "semi_annual"
	PriceMatrixPriceCadenceAnnual     PriceMatrixPriceCadence = "annual"
	PriceMatrixPriceCadenceCustom     PriceMatrixPriceCadence = "custom"
)

func (r PriceMatrixPriceCadence) IsKnown() bool {
	switch r {
	case PriceMatrixPriceCadenceOneTime, PriceMatrixPriceCadenceMonthly, PriceMatrixPriceCadenceQuarterly, PriceMatrixPriceCadenceSemiAnnual, PriceMatrixPriceCadenceAnnual, PriceMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type PriceMatrixPriceConversionRateConfig struct {
	ConversionRateType PriceMatrixPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                              `json:"unit_config"`
	JSON       priceMatrixPriceConversionRateConfigJSON `json:"-"`
	union      PriceMatrixPriceConversionRateConfigUnion
}

// priceMatrixPriceConversionRateConfigJSON contains the JSON metadata for the
// struct [PriceMatrixPriceConversionRateConfig]
type priceMatrixPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceMatrixPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceMatrixPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceMatrixPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceMatrixPriceConversionRateConfigUnion] interface which
// you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceMatrixPriceConversionRateConfigUnitConversionRateConfig],
// [PriceMatrixPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceMatrixPriceConversionRateConfig) AsUnion() PriceMatrixPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceMatrixPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceMatrixPriceConversionRateConfigTieredConversionRateConfig].
type PriceMatrixPriceConversionRateConfigUnion interface {
	implementsPriceMatrixPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceMatrixPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceMatrixPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceMatrixPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceMatrixPriceConversionRateConfigUnitConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceMatrixPriceConversionRateConfigUnitConversionRateConfig]
type priceMatrixPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMatrixPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixPriceConversionRateConfigUnitConversionRateConfig) implementsPriceMatrixPriceConversionRateConfig() {
}

type PriceMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                     `json:"unit_amount,required"`
	JSON       priceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceMatrixPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceMatrixPriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceMatrixPriceConversionRateConfigTieredConversionRateConfig]
type priceMatrixPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMatrixPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixPriceConversionRateConfigTieredConversionRateConfig) implementsPriceMatrixPriceConversionRateConfig() {
}

type PriceMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                            `json:"last_unit,nullable"`
	JSON     priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixPriceConversionRateConfigConversionRateType string

const (
	PriceMatrixPriceConversionRateConfigConversionRateTypeUnit   PriceMatrixPriceConversionRateConfigConversionRateType = "unit"
	PriceMatrixPriceConversionRateConfigConversionRateTypeTiered PriceMatrixPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMatrixPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixPriceConversionRateConfigConversionRateTypeUnit, PriceMatrixPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMatrixPriceModelType string

const (
	PriceMatrixPriceModelTypeMatrix PriceMatrixPriceModelType = "matrix"
)

func (r PriceMatrixPriceModelType) IsKnown() bool {
	switch r {
	case PriceMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

type PriceMatrixPricePriceType string

const (
	PriceMatrixPricePriceTypeUsagePrice PriceMatrixPricePriceType = "usage_price"
	PriceMatrixPricePriceTypeFixedPrice PriceMatrixPricePriceType = "fixed_price"
)

func (r PriceMatrixPricePriceType) IsKnown() bool {
	switch r {
	case PriceMatrixPricePriceTypeUsagePrice, PriceMatrixPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceTieredPrice struct {
	ID                        string                               `json:"id,required"`
	BillableMetric            BillableMetricTiny                   `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration            `json:"billing_cycle_configuration,required"`
	Cadence                   PriceTieredPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                              `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceTieredPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                            `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                           `json:"credit_allocation,required,nullable"`
	Currency                  string                               `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceTieredPriceModelType     `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceTieredPricePriceType     `json:"price_type,required"`
	TieredConfig                  TieredConfig                  `json:"tiered_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceTieredPriceJSON          `json:"-"`
}

// priceTieredPriceJSON contains the JSON metadata for the struct
// [PriceTieredPrice]
type priceTieredPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	TieredConfig                  apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceTieredPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPrice) implementsPrice() {}

type PriceTieredPriceCadence string

const (
	PriceTieredPriceCadenceOneTime    PriceTieredPriceCadence = "one_time"
	PriceTieredPriceCadenceMonthly    PriceTieredPriceCadence = "monthly"
	PriceTieredPriceCadenceQuarterly  PriceTieredPriceCadence = "quarterly"
	PriceTieredPriceCadenceSemiAnnual PriceTieredPriceCadence = "semi_annual"
	PriceTieredPriceCadenceAnnual     PriceTieredPriceCadence = "annual"
	PriceTieredPriceCadenceCustom     PriceTieredPriceCadence = "custom"
)

func (r PriceTieredPriceCadence) IsKnown() bool {
	switch r {
	case PriceTieredPriceCadenceOneTime, PriceTieredPriceCadenceMonthly, PriceTieredPriceCadenceQuarterly, PriceTieredPriceCadenceSemiAnnual, PriceTieredPriceCadenceAnnual, PriceTieredPriceCadenceCustom:
		return true
	}
	return false
}

type PriceTieredPriceConversionRateConfig struct {
	ConversionRateType PriceTieredPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                              `json:"unit_config"`
	JSON       priceTieredPriceConversionRateConfigJSON `json:"-"`
	union      PriceTieredPriceConversionRateConfigUnion
}

// priceTieredPriceConversionRateConfigJSON contains the JSON metadata for the
// struct [PriceTieredPriceConversionRateConfig]
type priceTieredPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceTieredPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceTieredPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceTieredPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceTieredPriceConversionRateConfigUnion] interface which
// you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceTieredPriceConversionRateConfigUnitConversionRateConfig],
// [PriceTieredPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceTieredPriceConversionRateConfig) AsUnion() PriceTieredPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceTieredPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceTieredPriceConversionRateConfigTieredConversionRateConfig].
type PriceTieredPriceConversionRateConfigUnion interface {
	implementsPriceTieredPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceTieredPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceTieredPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceTieredPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceTieredPriceConversionRateConfigUnitConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceTieredPriceConversionRateConfigUnitConversionRateConfig]
type priceTieredPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPriceConversionRateConfigUnitConversionRateConfig) implementsPriceTieredPriceConversionRateConfig() {
}

type PriceTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                     `json:"unit_amount,required"`
	JSON       priceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceTieredPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceTieredPriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceTieredPriceConversionRateConfigTieredConversionRateConfig]
type priceTieredPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPriceConversionRateConfigTieredConversionRateConfig) implementsPriceTieredPriceConversionRateConfig() {
}

type PriceTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                            `json:"last_unit,nullable"`
	JSON     priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPriceConversionRateConfigConversionRateType string

const (
	PriceTieredPriceConversionRateConfigConversionRateTypeUnit   PriceTieredPriceConversionRateConfigConversionRateType = "unit"
	PriceTieredPriceConversionRateConfigConversionRateTypeTiered PriceTieredPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPriceConversionRateConfigConversionRateTypeUnit, PriceTieredPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredPriceModelType string

const (
	PriceTieredPriceModelTypeTiered PriceTieredPriceModelType = "tiered"
)

func (r PriceTieredPriceModelType) IsKnown() bool {
	switch r {
	case PriceTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type PriceTieredPricePriceType string

const (
	PriceTieredPricePriceTypeUsagePrice PriceTieredPricePriceType = "usage_price"
	PriceTieredPricePriceTypeFixedPrice PriceTieredPricePriceType = "fixed_price"
)

func (r PriceTieredPricePriceType) IsKnown() bool {
	switch r {
	case PriceTieredPricePriceTypeUsagePrice, PriceTieredPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceTieredBPSPrice struct {
	ID                        string                                  `json:"id,required"`
	BillableMetric            BillableMetricTiny                      `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration               `json:"billing_cycle_configuration,required"`
	Cadence                   PriceTieredBPSPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                 `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceTieredBPSPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                               `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                              `json:"credit_allocation,required,nullable"`
	Currency                  string                                  `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceTieredBPSPriceModelType  `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceTieredBPSPricePriceType  `json:"price_type,required"`
	TieredBPSConfig               TieredBPSConfig               `json:"tiered_bps_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceTieredBPSPriceJSON       `json:"-"`
}

// priceTieredBPSPriceJSON contains the JSON metadata for the struct
// [PriceTieredBPSPrice]
type priceTieredBPSPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	TieredBPSConfig               apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceTieredBPSPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredBPSPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredBPSPrice) implementsPrice() {}

type PriceTieredBPSPriceCadence string

const (
	PriceTieredBPSPriceCadenceOneTime    PriceTieredBPSPriceCadence = "one_time"
	PriceTieredBPSPriceCadenceMonthly    PriceTieredBPSPriceCadence = "monthly"
	PriceTieredBPSPriceCadenceQuarterly  PriceTieredBPSPriceCadence = "quarterly"
	PriceTieredBPSPriceCadenceSemiAnnual PriceTieredBPSPriceCadence = "semi_annual"
	PriceTieredBPSPriceCadenceAnnual     PriceTieredBPSPriceCadence = "annual"
	PriceTieredBPSPriceCadenceCustom     PriceTieredBPSPriceCadence = "custom"
)

func (r PriceTieredBPSPriceCadence) IsKnown() bool {
	switch r {
	case PriceTieredBPSPriceCadenceOneTime, PriceTieredBPSPriceCadenceMonthly, PriceTieredBPSPriceCadenceQuarterly, PriceTieredBPSPriceCadenceSemiAnnual, PriceTieredBPSPriceCadenceAnnual, PriceTieredBPSPriceCadenceCustom:
		return true
	}
	return false
}

type PriceTieredBPSPriceConversionRateConfig struct {
	ConversionRateType PriceTieredBPSPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                 `json:"unit_config"`
	JSON       priceTieredBPSPriceConversionRateConfigJSON `json:"-"`
	union      PriceTieredBPSPriceConversionRateConfigUnion
}

// priceTieredBPSPriceConversionRateConfigJSON contains the JSON metadata for the
// struct [PriceTieredBPSPriceConversionRateConfig]
type priceTieredBPSPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceTieredBPSPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceTieredBPSPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceTieredBPSPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceTieredBPSPriceConversionRateConfigUnion] interface which
// you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig],
// [PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceTieredBPSPriceConversionRateConfig) AsUnion() PriceTieredBPSPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig].
type PriceTieredBPSPriceConversionRateConfigUnion interface {
	implementsPriceTieredBPSPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceTieredBPSPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig]
type priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfig) implementsPriceTieredBPSPriceConversionRateConfig() {
}

type PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                        `json:"unit_amount,required"`
	JSON       priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigJSON contains
// the JSON metadata for the struct
// [PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig]
type priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfig) implementsPriceTieredBPSPriceConversionRateConfig() {
}

type PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                               `json:"last_unit,nullable"`
	JSON     priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceTieredBPSPriceConversionRateConfigConversionRateType string

const (
	PriceTieredBPSPriceConversionRateConfigConversionRateTypeUnit   PriceTieredBPSPriceConversionRateConfigConversionRateType = "unit"
	PriceTieredBPSPriceConversionRateConfigConversionRateTypeTiered PriceTieredBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredBPSPriceConversionRateConfigConversionRateTypeUnit, PriceTieredBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredBPSPriceModelType string

const (
	PriceTieredBPSPriceModelTypeTieredBPS PriceTieredBPSPriceModelType = "tiered_bps"
)

func (r PriceTieredBPSPriceModelType) IsKnown() bool {
	switch r {
	case PriceTieredBPSPriceModelTypeTieredBPS:
		return true
	}
	return false
}

type PriceTieredBPSPricePriceType string

const (
	PriceTieredBPSPricePriceTypeUsagePrice PriceTieredBPSPricePriceType = "usage_price"
	PriceTieredBPSPricePriceTypeFixedPrice PriceTieredBPSPricePriceType = "fixed_price"
)

func (r PriceTieredBPSPricePriceType) IsKnown() bool {
	switch r {
	case PriceTieredBPSPricePriceTypeUsagePrice, PriceTieredBPSPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceBPSPrice struct {
	ID                        string                            `json:"id,required"`
	BillableMetric            BillableMetricTiny                `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration         `json:"billing_cycle_configuration,required"`
	BPSConfig                 BPSConfig                         `json:"bps_config,required"`
	Cadence                   PriceBPSPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                           `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceBPSPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                         `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                        `json:"credit_allocation,required,nullable"`
	Currency                  string                            `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceBPSPriceModelType        `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceBPSPricePriceType        `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceBPSPriceJSON             `json:"-"`
}

// priceBPSPriceJSON contains the JSON metadata for the struct [PriceBPSPrice]
type priceBPSPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	BPSConfig                     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceBPSPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBPSPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceBPSPrice) implementsPrice() {}

type PriceBPSPriceCadence string

const (
	PriceBPSPriceCadenceOneTime    PriceBPSPriceCadence = "one_time"
	PriceBPSPriceCadenceMonthly    PriceBPSPriceCadence = "monthly"
	PriceBPSPriceCadenceQuarterly  PriceBPSPriceCadence = "quarterly"
	PriceBPSPriceCadenceSemiAnnual PriceBPSPriceCadence = "semi_annual"
	PriceBPSPriceCadenceAnnual     PriceBPSPriceCadence = "annual"
	PriceBPSPriceCadenceCustom     PriceBPSPriceCadence = "custom"
)

func (r PriceBPSPriceCadence) IsKnown() bool {
	switch r {
	case PriceBPSPriceCadenceOneTime, PriceBPSPriceCadenceMonthly, PriceBPSPriceCadenceQuarterly, PriceBPSPriceCadenceSemiAnnual, PriceBPSPriceCadenceAnnual, PriceBPSPriceCadenceCustom:
		return true
	}
	return false
}

type PriceBPSPriceConversionRateConfig struct {
	ConversionRateType PriceBPSPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                           `json:"unit_config"`
	JSON       priceBPSPriceConversionRateConfigJSON `json:"-"`
	union      PriceBPSPriceConversionRateConfigUnion
}

// priceBPSPriceConversionRateConfigJSON contains the JSON metadata for the struct
// [PriceBPSPriceConversionRateConfig]
type priceBPSPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceBPSPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceBPSPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceBPSPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceBPSPriceConversionRateConfigUnion] interface which you
// can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceBPSPriceConversionRateConfigUnitConversionRateConfig],
// [PriceBPSPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceBPSPriceConversionRateConfig) AsUnion() PriceBPSPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by [PriceBPSPriceConversionRateConfigUnitConversionRateConfig]
// or [PriceBPSPriceConversionRateConfigTieredConversionRateConfig].
type PriceBPSPriceConversionRateConfigUnion interface {
	implementsPriceBPSPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceBPSPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBPSPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBPSPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceBPSPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceBPSPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceBPSPriceConversionRateConfigUnitConversionRateConfigJSON contains the JSON
// metadata for the struct
// [PriceBPSPriceConversionRateConfigUnitConversionRateConfig]
type priceBPSPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBPSPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBPSPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBPSPriceConversionRateConfigUnitConversionRateConfig) implementsPriceBPSPriceConversionRateConfig() {
}

type PriceBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                  `json:"unit_amount,required"`
	JSON       priceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON contains
// the JSON metadata for the struct
// [PriceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBPSPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceBPSPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceBPSPriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceBPSPriceConversionRateConfigTieredConversionRateConfig]
type priceBPSPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBPSPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBPSPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBPSPriceConversionRateConfigTieredConversionRateConfig) implementsPriceBPSPriceConversionRateConfig() {
}

type PriceBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                         `json:"last_unit,nullable"`
	JSON     priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceBPSPriceConversionRateConfigConversionRateType string

const (
	PriceBPSPriceConversionRateConfigConversionRateTypeUnit   PriceBPSPriceConversionRateConfigConversionRateType = "unit"
	PriceBPSPriceConversionRateConfigConversionRateTypeTiered PriceBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBPSPriceConversionRateConfigConversionRateTypeUnit, PriceBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBPSPriceModelType string

const (
	PriceBPSPriceModelTypeBPS PriceBPSPriceModelType = "bps"
)

func (r PriceBPSPriceModelType) IsKnown() bool {
	switch r {
	case PriceBPSPriceModelTypeBPS:
		return true
	}
	return false
}

type PriceBPSPricePriceType string

const (
	PriceBPSPricePriceTypeUsagePrice PriceBPSPricePriceType = "usage_price"
	PriceBPSPricePriceTypeFixedPrice PriceBPSPricePriceType = "fixed_price"
)

func (r PriceBPSPricePriceType) IsKnown() bool {
	switch r {
	case PriceBPSPricePriceTypeUsagePrice, PriceBPSPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceBulkBPSPrice struct {
	ID                        string                                `json:"id,required"`
	BillableMetric            BillableMetricTiny                    `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration             `json:"billing_cycle_configuration,required"`
	BulkBPSConfig             BulkBPSConfig                         `json:"bulk_bps_config,required"`
	Cadence                   PriceBulkBPSPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                               `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceBulkBPSPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                             `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                            `json:"credit_allocation,required,nullable"`
	Currency                  string                                `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceBulkBPSPriceModelType    `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceBulkBPSPricePriceType    `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceBulkBPSPriceJSON         `json:"-"`
}

// priceBulkBPSPriceJSON contains the JSON metadata for the struct
// [PriceBulkBPSPrice]
type priceBulkBPSPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	BulkBPSConfig                 apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceBulkBPSPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkBPSPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkBPSPrice) implementsPrice() {}

type PriceBulkBPSPriceCadence string

const (
	PriceBulkBPSPriceCadenceOneTime    PriceBulkBPSPriceCadence = "one_time"
	PriceBulkBPSPriceCadenceMonthly    PriceBulkBPSPriceCadence = "monthly"
	PriceBulkBPSPriceCadenceQuarterly  PriceBulkBPSPriceCadence = "quarterly"
	PriceBulkBPSPriceCadenceSemiAnnual PriceBulkBPSPriceCadence = "semi_annual"
	PriceBulkBPSPriceCadenceAnnual     PriceBulkBPSPriceCadence = "annual"
	PriceBulkBPSPriceCadenceCustom     PriceBulkBPSPriceCadence = "custom"
)

func (r PriceBulkBPSPriceCadence) IsKnown() bool {
	switch r {
	case PriceBulkBPSPriceCadenceOneTime, PriceBulkBPSPriceCadenceMonthly, PriceBulkBPSPriceCadenceQuarterly, PriceBulkBPSPriceCadenceSemiAnnual, PriceBulkBPSPriceCadenceAnnual, PriceBulkBPSPriceCadenceCustom:
		return true
	}
	return false
}

type PriceBulkBPSPriceConversionRateConfig struct {
	ConversionRateType PriceBulkBPSPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                               `json:"unit_config"`
	JSON       priceBulkBPSPriceConversionRateConfigJSON `json:"-"`
	union      PriceBulkBPSPriceConversionRateConfigUnion
}

// priceBulkBPSPriceConversionRateConfigJSON contains the JSON metadata for the
// struct [PriceBulkBPSPriceConversionRateConfig]
type priceBulkBPSPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceBulkBPSPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceBulkBPSPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceBulkBPSPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceBulkBPSPriceConversionRateConfigUnion] interface which
// you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig],
// [PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceBulkBPSPriceConversionRateConfig) AsUnion() PriceBulkBPSPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig].
type PriceBulkBPSPriceConversionRateConfigUnion interface {
	implementsPriceBulkBPSPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceBulkBPSPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig]
type priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfig) implementsPriceBulkBPSPriceConversionRateConfig() {
}

type PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                      `json:"unit_amount,required"`
	JSON       priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkBPSPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig]
type priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfig) implementsPriceBulkBPSPriceConversionRateConfig() {
}

type PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                             `json:"last_unit,nullable"`
	JSON     priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkBPSPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceBulkBPSPriceConversionRateConfigConversionRateType string

const (
	PriceBulkBPSPriceConversionRateConfigConversionRateTypeUnit   PriceBulkBPSPriceConversionRateConfigConversionRateType = "unit"
	PriceBulkBPSPriceConversionRateConfigConversionRateTypeTiered PriceBulkBPSPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBulkBPSPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkBPSPriceConversionRateConfigConversionRateTypeUnit, PriceBulkBPSPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBulkBPSPriceModelType string

const (
	PriceBulkBPSPriceModelTypeBulkBPS PriceBulkBPSPriceModelType = "bulk_bps"
)

func (r PriceBulkBPSPriceModelType) IsKnown() bool {
	switch r {
	case PriceBulkBPSPriceModelTypeBulkBPS:
		return true
	}
	return false
}

type PriceBulkBPSPricePriceType string

const (
	PriceBulkBPSPricePriceTypeUsagePrice PriceBulkBPSPricePriceType = "usage_price"
	PriceBulkBPSPricePriceTypeFixedPrice PriceBulkBPSPricePriceType = "fixed_price"
)

func (r PriceBulkBPSPricePriceType) IsKnown() bool {
	switch r {
	case PriceBulkBPSPricePriceTypeUsagePrice, PriceBulkBPSPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceBulkPrice struct {
	ID                        string                             `json:"id,required"`
	BillableMetric            BillableMetricTiny                 `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration          `json:"billing_cycle_configuration,required"`
	BulkConfig                BulkConfig                         `json:"bulk_config,required"`
	Cadence                   PriceBulkPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                            `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceBulkPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                          `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                         `json:"credit_allocation,required,nullable"`
	Currency                  string                             `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceBulkPriceModelType       `json:"model_type,required"`
	Name                          string                        `json:"name,required"`
	PlanPhaseOrder                int64                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceBulkPricePriceType       `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration `json:"dimensional_price_configuration,nullable"`
	JSON                          priceBulkPriceJSON            `json:"-"`
}

// priceBulkPriceJSON contains the JSON metadata for the struct [PriceBulkPrice]
type priceBulkPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	BulkConfig                    apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceBulkPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkPrice) implementsPrice() {}

type PriceBulkPriceCadence string

const (
	PriceBulkPriceCadenceOneTime    PriceBulkPriceCadence = "one_time"
	PriceBulkPriceCadenceMonthly    PriceBulkPriceCadence = "monthly"
	PriceBulkPriceCadenceQuarterly  PriceBulkPriceCadence = "quarterly"
	PriceBulkPriceCadenceSemiAnnual PriceBulkPriceCadence = "semi_annual"
	PriceBulkPriceCadenceAnnual     PriceBulkPriceCadence = "annual"
	PriceBulkPriceCadenceCustom     PriceBulkPriceCadence = "custom"
)

func (r PriceBulkPriceCadence) IsKnown() bool {
	switch r {
	case PriceBulkPriceCadenceOneTime, PriceBulkPriceCadenceMonthly, PriceBulkPriceCadenceQuarterly, PriceBulkPriceCadenceSemiAnnual, PriceBulkPriceCadenceAnnual, PriceBulkPriceCadenceCustom:
		return true
	}
	return false
}

type PriceBulkPriceConversionRateConfig struct {
	ConversionRateType PriceBulkPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                            `json:"unit_config"`
	JSON       priceBulkPriceConversionRateConfigJSON `json:"-"`
	union      PriceBulkPriceConversionRateConfigUnion
}

// priceBulkPriceConversionRateConfigJSON contains the JSON metadata for the struct
// [PriceBulkPriceConversionRateConfig]
type priceBulkPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceBulkPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceBulkPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceBulkPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceBulkPriceConversionRateConfigUnion] interface which you
// can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceBulkPriceConversionRateConfigUnitConversionRateConfig],
// [PriceBulkPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceBulkPriceConversionRateConfig) AsUnion() PriceBulkPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by [PriceBulkPriceConversionRateConfigUnitConversionRateConfig]
// or [PriceBulkPriceConversionRateConfigTieredConversionRateConfig].
type PriceBulkPriceConversionRateConfigUnion interface {
	implementsPriceBulkPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceBulkPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceBulkPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceBulkPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceBulkPriceConversionRateConfigUnitConversionRateConfigJSON contains the JSON
// metadata for the struct
// [PriceBulkPriceConversionRateConfigUnitConversionRateConfig]
type priceBulkPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBulkPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkPriceConversionRateConfigUnitConversionRateConfig) implementsPriceBulkPriceConversionRateConfig() {
}

type PriceBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                   `json:"unit_amount,required"`
	JSON       priceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBulkPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceBulkPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceBulkPriceConversionRateConfigTieredConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceBulkPriceConversionRateConfigTieredConversionRateConfig]
type priceBulkPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBulkPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkPriceConversionRateConfigTieredConversionRateConfig) implementsPriceBulkPriceConversionRateConfig() {
}

type PriceBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                          `json:"last_unit,nullable"`
	JSON     priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceBulkPriceConversionRateConfigConversionRateType string

const (
	PriceBulkPriceConversionRateConfigConversionRateTypeUnit   PriceBulkPriceConversionRateConfigConversionRateType = "unit"
	PriceBulkPriceConversionRateConfigConversionRateTypeTiered PriceBulkPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBulkPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkPriceConversionRateConfigConversionRateTypeUnit, PriceBulkPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBulkPriceModelType string

const (
	PriceBulkPriceModelTypeBulk PriceBulkPriceModelType = "bulk"
)

func (r PriceBulkPriceModelType) IsKnown() bool {
	switch r {
	case PriceBulkPriceModelTypeBulk:
		return true
	}
	return false
}

type PriceBulkPricePriceType string

const (
	PriceBulkPricePriceTypeUsagePrice PriceBulkPricePriceType = "usage_price"
	PriceBulkPricePriceTypeFixedPrice PriceBulkPricePriceType = "fixed_price"
)

func (r PriceBulkPricePriceType) IsKnown() bool {
	switch r {
	case PriceBulkPricePriceTypeUsagePrice, PriceBulkPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceThresholdTotalAmountPrice struct {
	ID                        string                                             `json:"id,required"`
	BillableMetric            BillableMetricTiny                                 `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                          `json:"billing_cycle_configuration,required"`
	Cadence                   PriceThresholdTotalAmountPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                            `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceThresholdTotalAmountPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                          `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                         `json:"credit_allocation,required,nullable"`
	Currency                  string                                             `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                  `json:"minimum_amount,required,nullable"`
	ModelType                     PriceThresholdTotalAmountPriceModelType `json:"model_type,required"`
	Name                          string                                  `json:"name,required"`
	PlanPhaseOrder                int64                                   `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceThresholdTotalAmountPricePriceType `json:"price_type,required"`
	ThresholdTotalAmountConfig    map[string]interface{}                  `json:"threshold_total_amount_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration           `json:"dimensional_price_configuration,nullable"`
	JSON                          priceThresholdTotalAmountPriceJSON      `json:"-"`
}

// priceThresholdTotalAmountPriceJSON contains the JSON metadata for the struct
// [PriceThresholdTotalAmountPrice]
type priceThresholdTotalAmountPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	ThresholdTotalAmountConfig    apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceThresholdTotalAmountPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceThresholdTotalAmountPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceThresholdTotalAmountPrice) implementsPrice() {}

type PriceThresholdTotalAmountPriceCadence string

const (
	PriceThresholdTotalAmountPriceCadenceOneTime    PriceThresholdTotalAmountPriceCadence = "one_time"
	PriceThresholdTotalAmountPriceCadenceMonthly    PriceThresholdTotalAmountPriceCadence = "monthly"
	PriceThresholdTotalAmountPriceCadenceQuarterly  PriceThresholdTotalAmountPriceCadence = "quarterly"
	PriceThresholdTotalAmountPriceCadenceSemiAnnual PriceThresholdTotalAmountPriceCadence = "semi_annual"
	PriceThresholdTotalAmountPriceCadenceAnnual     PriceThresholdTotalAmountPriceCadence = "annual"
	PriceThresholdTotalAmountPriceCadenceCustom     PriceThresholdTotalAmountPriceCadence = "custom"
)

func (r PriceThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case PriceThresholdTotalAmountPriceCadenceOneTime, PriceThresholdTotalAmountPriceCadenceMonthly, PriceThresholdTotalAmountPriceCadenceQuarterly, PriceThresholdTotalAmountPriceCadenceSemiAnnual, PriceThresholdTotalAmountPriceCadenceAnnual, PriceThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type PriceThresholdTotalAmountPriceConversionRateConfig struct {
	ConversionRateType PriceThresholdTotalAmountPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                            `json:"unit_config"`
	JSON       priceThresholdTotalAmountPriceConversionRateConfigJSON `json:"-"`
	union      PriceThresholdTotalAmountPriceConversionRateConfigUnion
}

// priceThresholdTotalAmountPriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceThresholdTotalAmountPriceConversionRateConfig]
type priceThresholdTotalAmountPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceThresholdTotalAmountPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceThresholdTotalAmountPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceThresholdTotalAmountPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceThresholdTotalAmountPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig],
// [PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceThresholdTotalAmountPriceConversionRateConfig) AsUnion() PriceThresholdTotalAmountPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig].
type PriceThresholdTotalAmountPriceConversionRateConfigUnion interface {
	implementsPriceThresholdTotalAmountPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceThresholdTotalAmountPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig]
type priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfig) implementsPriceThresholdTotalAmountPriceConversionRateConfig() {
}

type PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                   `json:"unit_amount,required"`
	JSON       priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceThresholdTotalAmountPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig]
type priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfig) implementsPriceThresholdTotalAmountPriceConversionRateConfig() {
}

type PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                          `json:"last_unit,nullable"`
	JSON     priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceThresholdTotalAmountPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceThresholdTotalAmountPriceConversionRateConfigConversionRateType string

const (
	PriceThresholdTotalAmountPriceConversionRateConfigConversionRateTypeUnit   PriceThresholdTotalAmountPriceConversionRateConfigConversionRateType = "unit"
	PriceThresholdTotalAmountPriceConversionRateConfigConversionRateTypeTiered PriceThresholdTotalAmountPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceThresholdTotalAmountPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceThresholdTotalAmountPriceConversionRateConfigConversionRateTypeUnit, PriceThresholdTotalAmountPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceThresholdTotalAmountPriceModelType string

const (
	PriceThresholdTotalAmountPriceModelTypeThresholdTotalAmount PriceThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r PriceThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case PriceThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

type PriceThresholdTotalAmountPricePriceType string

const (
	PriceThresholdTotalAmountPricePriceTypeUsagePrice PriceThresholdTotalAmountPricePriceType = "usage_price"
	PriceThresholdTotalAmountPricePriceTypeFixedPrice PriceThresholdTotalAmountPricePriceType = "fixed_price"
)

func (r PriceThresholdTotalAmountPricePriceType) IsKnown() bool {
	switch r {
	case PriceThresholdTotalAmountPricePriceTypeUsagePrice, PriceThresholdTotalAmountPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceTieredPackagePrice struct {
	ID                        string                                      `json:"id,required"`
	BillableMetric            BillableMetricTiny                          `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                   `json:"billing_cycle_configuration,required"`
	Cadence                   PriceTieredPackagePriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                     `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceTieredPackagePriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                   `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                  `json:"credit_allocation,required,nullable"`
	Currency                  string                                      `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                           `json:"minimum_amount,required,nullable"`
	ModelType                     PriceTieredPackagePriceModelType `json:"model_type,required"`
	Name                          string                           `json:"name,required"`
	PlanPhaseOrder                int64                            `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceTieredPackagePricePriceType `json:"price_type,required"`
	TieredPackageConfig           map[string]interface{}           `json:"tiered_package_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration    `json:"dimensional_price_configuration,nullable"`
	JSON                          priceTieredPackagePriceJSON      `json:"-"`
}

// priceTieredPackagePriceJSON contains the JSON metadata for the struct
// [PriceTieredPackagePrice]
type priceTieredPackagePriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	TieredPackageConfig           apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceTieredPackagePrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackagePriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPackagePrice) implementsPrice() {}

type PriceTieredPackagePriceCadence string

const (
	PriceTieredPackagePriceCadenceOneTime    PriceTieredPackagePriceCadence = "one_time"
	PriceTieredPackagePriceCadenceMonthly    PriceTieredPackagePriceCadence = "monthly"
	PriceTieredPackagePriceCadenceQuarterly  PriceTieredPackagePriceCadence = "quarterly"
	PriceTieredPackagePriceCadenceSemiAnnual PriceTieredPackagePriceCadence = "semi_annual"
	PriceTieredPackagePriceCadenceAnnual     PriceTieredPackagePriceCadence = "annual"
	PriceTieredPackagePriceCadenceCustom     PriceTieredPackagePriceCadence = "custom"
)

func (r PriceTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case PriceTieredPackagePriceCadenceOneTime, PriceTieredPackagePriceCadenceMonthly, PriceTieredPackagePriceCadenceQuarterly, PriceTieredPackagePriceCadenceSemiAnnual, PriceTieredPackagePriceCadenceAnnual, PriceTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type PriceTieredPackagePriceConversionRateConfig struct {
	ConversionRateType PriceTieredPackagePriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                     `json:"unit_config"`
	JSON       priceTieredPackagePriceConversionRateConfigJSON `json:"-"`
	union      PriceTieredPackagePriceConversionRateConfigUnion
}

// priceTieredPackagePriceConversionRateConfigJSON contains the JSON metadata for
// the struct [PriceTieredPackagePriceConversionRateConfig]
type priceTieredPackagePriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceTieredPackagePriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceTieredPackagePriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceTieredPackagePriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceTieredPackagePriceConversionRateConfigUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig],
// [PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig].
func (r PriceTieredPackagePriceConversionRateConfig) AsUnion() PriceTieredPackagePriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig] or
// [PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig].
type PriceTieredPackagePriceConversionRateConfigUnion interface {
	implementsPriceTieredPackagePriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceTieredPackagePriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON contains
// the JSON metadata for the struct
// [PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig]
type priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfig) implementsPriceTieredPackagePriceConversionRateConfig() {
}

type PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                            `json:"unit_amount,required"`
	JSON       priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig]
type priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfig) implementsPriceTieredPackagePriceConversionRateConfig() {
}

type PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                   `json:"last_unit,nullable"`
	JSON     priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPackagePriceConversionRateConfigConversionRateType string

const (
	PriceTieredPackagePriceConversionRateConfigConversionRateTypeUnit   PriceTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	PriceTieredPackagePriceConversionRateConfigConversionRateTypeTiered PriceTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPackagePriceConversionRateConfigConversionRateTypeUnit, PriceTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredPackagePriceModelType string

const (
	PriceTieredPackagePriceModelTypeTieredPackage PriceTieredPackagePriceModelType = "tiered_package"
)

func (r PriceTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case PriceTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

type PriceTieredPackagePricePriceType string

const (
	PriceTieredPackagePricePriceTypeUsagePrice PriceTieredPackagePricePriceType = "usage_price"
	PriceTieredPackagePricePriceTypeFixedPrice PriceTieredPackagePricePriceType = "fixed_price"
)

func (r PriceTieredPackagePricePriceType) IsKnown() bool {
	switch r {
	case PriceTieredPackagePricePriceTypeUsagePrice, PriceTieredPackagePricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceGroupedTieredPrice struct {
	ID                        string                                      `json:"id,required"`
	BillableMetric            BillableMetricTiny                          `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                   `json:"billing_cycle_configuration,required"`
	Cadence                   PriceGroupedTieredPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                     `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceGroupedTieredPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                   `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                  `json:"credit_allocation,required,nullable"`
	Currency                  string                                      `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	GroupedTieredConfig         map[string]interface{}    `json:"grouped_tiered_config,required"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                           `json:"minimum_amount,required,nullable"`
	ModelType                     PriceGroupedTieredPriceModelType `json:"model_type,required"`
	Name                          string                           `json:"name,required"`
	PlanPhaseOrder                int64                            `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceGroupedTieredPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration    `json:"dimensional_price_configuration,nullable"`
	JSON                          priceGroupedTieredPriceJSON      `json:"-"`
}

// priceGroupedTieredPriceJSON contains the JSON metadata for the struct
// [PriceGroupedTieredPrice]
type priceGroupedTieredPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	GroupedTieredConfig           apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceGroupedTieredPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedTieredPrice) implementsPrice() {}

type PriceGroupedTieredPriceCadence string

const (
	PriceGroupedTieredPriceCadenceOneTime    PriceGroupedTieredPriceCadence = "one_time"
	PriceGroupedTieredPriceCadenceMonthly    PriceGroupedTieredPriceCadence = "monthly"
	PriceGroupedTieredPriceCadenceQuarterly  PriceGroupedTieredPriceCadence = "quarterly"
	PriceGroupedTieredPriceCadenceSemiAnnual PriceGroupedTieredPriceCadence = "semi_annual"
	PriceGroupedTieredPriceCadenceAnnual     PriceGroupedTieredPriceCadence = "annual"
	PriceGroupedTieredPriceCadenceCustom     PriceGroupedTieredPriceCadence = "custom"
)

func (r PriceGroupedTieredPriceCadence) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPriceCadenceOneTime, PriceGroupedTieredPriceCadenceMonthly, PriceGroupedTieredPriceCadenceQuarterly, PriceGroupedTieredPriceCadenceSemiAnnual, PriceGroupedTieredPriceCadenceAnnual, PriceGroupedTieredPriceCadenceCustom:
		return true
	}
	return false
}

type PriceGroupedTieredPriceConversionRateConfig struct {
	ConversionRateType PriceGroupedTieredPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                     `json:"unit_config"`
	JSON       priceGroupedTieredPriceConversionRateConfigJSON `json:"-"`
	union      PriceGroupedTieredPriceConversionRateConfigUnion
}

// priceGroupedTieredPriceConversionRateConfigJSON contains the JSON metadata for
// the struct [PriceGroupedTieredPriceConversionRateConfig]
type priceGroupedTieredPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceGroupedTieredPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceGroupedTieredPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceGroupedTieredPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceGroupedTieredPriceConversionRateConfigUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig],
// [PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceGroupedTieredPriceConversionRateConfig) AsUnion() PriceGroupedTieredPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig].
type PriceGroupedTieredPriceConversionRateConfigUnion interface {
	implementsPriceGroupedTieredPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceGroupedTieredPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigJSON contains
// the JSON metadata for the struct
// [PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig]
type priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfig) implementsPriceGroupedTieredPriceConversionRateConfig() {
}

type PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                            `json:"unit_amount,required"`
	JSON       priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig]
type priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfig) implementsPriceGroupedTieredPriceConversionRateConfig() {
}

type PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                   `json:"last_unit,nullable"`
	JSON     priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedTieredPriceConversionRateConfigConversionRateType string

const (
	PriceGroupedTieredPriceConversionRateConfigConversionRateTypeUnit   PriceGroupedTieredPriceConversionRateConfigConversionRateType = "unit"
	PriceGroupedTieredPriceConversionRateConfigConversionRateTypeTiered PriceGroupedTieredPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedTieredPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPriceConversionRateConfigConversionRateTypeUnit, PriceGroupedTieredPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedTieredPriceModelType string

const (
	PriceGroupedTieredPriceModelTypeGroupedTiered PriceGroupedTieredPriceModelType = "grouped_tiered"
)

func (r PriceGroupedTieredPriceModelType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPriceModelTypeGroupedTiered:
		return true
	}
	return false
}

type PriceGroupedTieredPricePriceType string

const (
	PriceGroupedTieredPricePriceTypeUsagePrice PriceGroupedTieredPricePriceType = "usage_price"
	PriceGroupedTieredPricePriceTypeFixedPrice PriceGroupedTieredPricePriceType = "fixed_price"
)

func (r PriceGroupedTieredPricePriceType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPricePriceTypeUsagePrice, PriceGroupedTieredPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceTieredWithMinimumPrice struct {
	ID                        string                                          `json:"id,required"`
	BillableMetric            BillableMetricTiny                              `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                       `json:"billing_cycle_configuration,required"`
	Cadence                   PriceTieredWithMinimumPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                         `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceTieredWithMinimumPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                       `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                      `json:"credit_allocation,required,nullable"`
	Currency                  string                                          `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                               `json:"minimum_amount,required,nullable"`
	ModelType                     PriceTieredWithMinimumPriceModelType `json:"model_type,required"`
	Name                          string                               `json:"name,required"`
	PlanPhaseOrder                int64                                `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceTieredWithMinimumPricePriceType `json:"price_type,required"`
	TieredWithMinimumConfig       map[string]interface{}               `json:"tiered_with_minimum_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration        `json:"dimensional_price_configuration,nullable"`
	JSON                          priceTieredWithMinimumPriceJSON      `json:"-"`
}

// priceTieredWithMinimumPriceJSON contains the JSON metadata for the struct
// [PriceTieredWithMinimumPrice]
type priceTieredWithMinimumPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	TieredWithMinimumConfig       apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceTieredWithMinimumPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithMinimumPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredWithMinimumPrice) implementsPrice() {}

type PriceTieredWithMinimumPriceCadence string

const (
	PriceTieredWithMinimumPriceCadenceOneTime    PriceTieredWithMinimumPriceCadence = "one_time"
	PriceTieredWithMinimumPriceCadenceMonthly    PriceTieredWithMinimumPriceCadence = "monthly"
	PriceTieredWithMinimumPriceCadenceQuarterly  PriceTieredWithMinimumPriceCadence = "quarterly"
	PriceTieredWithMinimumPriceCadenceSemiAnnual PriceTieredWithMinimumPriceCadence = "semi_annual"
	PriceTieredWithMinimumPriceCadenceAnnual     PriceTieredWithMinimumPriceCadence = "annual"
	PriceTieredWithMinimumPriceCadenceCustom     PriceTieredWithMinimumPriceCadence = "custom"
)

func (r PriceTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case PriceTieredWithMinimumPriceCadenceOneTime, PriceTieredWithMinimumPriceCadenceMonthly, PriceTieredWithMinimumPriceCadenceQuarterly, PriceTieredWithMinimumPriceCadenceSemiAnnual, PriceTieredWithMinimumPriceCadenceAnnual, PriceTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type PriceTieredWithMinimumPriceConversionRateConfig struct {
	ConversionRateType PriceTieredWithMinimumPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                         `json:"unit_config"`
	JSON       priceTieredWithMinimumPriceConversionRateConfigJSON `json:"-"`
	union      PriceTieredWithMinimumPriceConversionRateConfigUnion
}

// priceTieredWithMinimumPriceConversionRateConfigJSON contains the JSON metadata
// for the struct [PriceTieredWithMinimumPriceConversionRateConfig]
type priceTieredWithMinimumPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceTieredWithMinimumPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceTieredWithMinimumPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceTieredWithMinimumPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceTieredWithMinimumPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig],
// [PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceTieredWithMinimumPriceConversionRateConfig) AsUnion() PriceTieredWithMinimumPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig].
type PriceTieredWithMinimumPriceConversionRateConfigUnion interface {
	implementsPriceTieredWithMinimumPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceTieredWithMinimumPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig]
type priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfig) implementsPriceTieredWithMinimumPriceConversionRateConfig() {
}

type PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                `json:"unit_amount,required"`
	JSON       priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig]
type priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfig) implementsPriceTieredWithMinimumPriceConversionRateConfig() {
}

type PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                       `json:"last_unit,nullable"`
	JSON     priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceTieredWithMinimumPriceConversionRateConfigConversionRateType string

const (
	PriceTieredWithMinimumPriceConversionRateConfigConversionRateTypeUnit   PriceTieredWithMinimumPriceConversionRateConfigConversionRateType = "unit"
	PriceTieredWithMinimumPriceConversionRateConfigConversionRateTypeTiered PriceTieredWithMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredWithMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredWithMinimumPriceConversionRateConfigConversionRateTypeUnit, PriceTieredWithMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredWithMinimumPriceModelType string

const (
	PriceTieredWithMinimumPriceModelTypeTieredWithMinimum PriceTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r PriceTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case PriceTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

type PriceTieredWithMinimumPricePriceType string

const (
	PriceTieredWithMinimumPricePriceTypeUsagePrice PriceTieredWithMinimumPricePriceType = "usage_price"
	PriceTieredWithMinimumPricePriceTypeFixedPrice PriceTieredWithMinimumPricePriceType = "fixed_price"
)

func (r PriceTieredWithMinimumPricePriceType) IsKnown() bool {
	switch r {
	case PriceTieredWithMinimumPricePriceTypeUsagePrice, PriceTieredWithMinimumPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceTieredPackageWithMinimumPrice struct {
	ID                        string                                                 `json:"id,required"`
	BillableMetric            BillableMetricTiny                                     `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                              `json:"billing_cycle_configuration,required"`
	Cadence                   PriceTieredPackageWithMinimumPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                                `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceTieredPackageWithMinimumPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                              `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                             `json:"credit_allocation,required,nullable"`
	Currency                  string                                                 `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                  string                                      `json:"minimum_amount,required,nullable"`
	ModelType                      PriceTieredPackageWithMinimumPriceModelType `json:"model_type,required"`
	Name                           string                                      `json:"name,required"`
	PlanPhaseOrder                 int64                                       `json:"plan_phase_order,required,nullable"`
	PriceType                      PriceTieredPackageWithMinimumPricePriceType `json:"price_type,required"`
	TieredPackageWithMinimumConfig map[string]interface{}                      `json:"tiered_package_with_minimum_config,required"`
	DimensionalPriceConfiguration  DimensionalPriceConfiguration               `json:"dimensional_price_configuration,nullable"`
	JSON                           priceTieredPackageWithMinimumPriceJSON      `json:"-"`
}

// priceTieredPackageWithMinimumPriceJSON contains the JSON metadata for the struct
// [PriceTieredPackageWithMinimumPrice]
type priceTieredPackageWithMinimumPriceJSON struct {
	ID                             apijson.Field
	BillableMetric                 apijson.Field
	BillingCycleConfiguration      apijson.Field
	Cadence                        apijson.Field
	ConversionRate                 apijson.Field
	ConversionRateConfig           apijson.Field
	CreatedAt                      apijson.Field
	CreditAllocation               apijson.Field
	Currency                       apijson.Field
	Discount                       apijson.Field
	ExternalPriceID                apijson.Field
	FixedPriceQuantity             apijson.Field
	InvoicingCycleConfiguration    apijson.Field
	Item                           apijson.Field
	Maximum                        apijson.Field
	MaximumAmount                  apijson.Field
	Metadata                       apijson.Field
	Minimum                        apijson.Field
	MinimumAmount                  apijson.Field
	ModelType                      apijson.Field
	Name                           apijson.Field
	PlanPhaseOrder                 apijson.Field
	PriceType                      apijson.Field
	TieredPackageWithMinimumConfig apijson.Field
	DimensionalPriceConfiguration  apijson.Field
	raw                            string
	ExtraFields                    map[string]apijson.Field
}

func (r *PriceTieredPackageWithMinimumPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackageWithMinimumPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPackageWithMinimumPrice) implementsPrice() {}

type PriceTieredPackageWithMinimumPriceCadence string

const (
	PriceTieredPackageWithMinimumPriceCadenceOneTime    PriceTieredPackageWithMinimumPriceCadence = "one_time"
	PriceTieredPackageWithMinimumPriceCadenceMonthly    PriceTieredPackageWithMinimumPriceCadence = "monthly"
	PriceTieredPackageWithMinimumPriceCadenceQuarterly  PriceTieredPackageWithMinimumPriceCadence = "quarterly"
	PriceTieredPackageWithMinimumPriceCadenceSemiAnnual PriceTieredPackageWithMinimumPriceCadence = "semi_annual"
	PriceTieredPackageWithMinimumPriceCadenceAnnual     PriceTieredPackageWithMinimumPriceCadence = "annual"
	PriceTieredPackageWithMinimumPriceCadenceCustom     PriceTieredPackageWithMinimumPriceCadence = "custom"
)

func (r PriceTieredPackageWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case PriceTieredPackageWithMinimumPriceCadenceOneTime, PriceTieredPackageWithMinimumPriceCadenceMonthly, PriceTieredPackageWithMinimumPriceCadenceQuarterly, PriceTieredPackageWithMinimumPriceCadenceSemiAnnual, PriceTieredPackageWithMinimumPriceCadenceAnnual, PriceTieredPackageWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type PriceTieredPackageWithMinimumPriceConversionRateConfig struct {
	ConversionRateType PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                                `json:"unit_config"`
	JSON       priceTieredPackageWithMinimumPriceConversionRateConfigJSON `json:"-"`
	union      PriceTieredPackageWithMinimumPriceConversionRateConfigUnion
}

// priceTieredPackageWithMinimumPriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceTieredPackageWithMinimumPriceConversionRateConfig]
type priceTieredPackageWithMinimumPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceTieredPackageWithMinimumPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceTieredPackageWithMinimumPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceTieredPackageWithMinimumPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceTieredPackageWithMinimumPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig],
// [PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceTieredPackageWithMinimumPriceConversionRateConfig) AsUnion() PriceTieredPackageWithMinimumPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig]
// or
// [PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig].
type PriceTieredPackageWithMinimumPriceConversionRateConfigUnion interface {
	implementsPriceTieredPackageWithMinimumPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceTieredPackageWithMinimumPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig]
type priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfig) implementsPriceTieredPackageWithMinimumPriceConversionRateConfig() {
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                       `json:"unit_amount,required"`
	JSON       priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackageWithMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig]
type priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfig) implementsPriceTieredPackageWithMinimumPriceConversionRateConfig() {
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                              `json:"last_unit,nullable"`
	JSON     priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredPackageWithMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateType string

const (
	PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeUnit   PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateType = "unit"
	PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeTiered PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeUnit, PriceTieredPackageWithMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredPackageWithMinimumPriceModelType string

const (
	PriceTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum PriceTieredPackageWithMinimumPriceModelType = "tiered_package_with_minimum"
)

func (r PriceTieredPackageWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case PriceTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum:
		return true
	}
	return false
}

type PriceTieredPackageWithMinimumPricePriceType string

const (
	PriceTieredPackageWithMinimumPricePriceTypeUsagePrice PriceTieredPackageWithMinimumPricePriceType = "usage_price"
	PriceTieredPackageWithMinimumPricePriceTypeFixedPrice PriceTieredPackageWithMinimumPricePriceType = "fixed_price"
)

func (r PriceTieredPackageWithMinimumPricePriceType) IsKnown() bool {
	switch r {
	case PriceTieredPackageWithMinimumPricePriceTypeUsagePrice, PriceTieredPackageWithMinimumPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PricePackageWithAllocationPrice struct {
	ID                        string                                              `json:"id,required"`
	BillableMetric            BillableMetricTiny                                  `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                           `json:"billing_cycle_configuration,required"`
	Cadence                   PricePackageWithAllocationPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                             `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PricePackageWithAllocationPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                           `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                          `json:"credit_allocation,required,nullable"`
	Currency                  string                                              `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                   `json:"minimum_amount,required,nullable"`
	ModelType                     PricePackageWithAllocationPriceModelType `json:"model_type,required"`
	Name                          string                                   `json:"name,required"`
	PackageWithAllocationConfig   map[string]interface{}                   `json:"package_with_allocation_config,required"`
	PlanPhaseOrder                int64                                    `json:"plan_phase_order,required,nullable"`
	PriceType                     PricePackageWithAllocationPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration            `json:"dimensional_price_configuration,nullable"`
	JSON                          pricePackageWithAllocationPriceJSON      `json:"-"`
}

// pricePackageWithAllocationPriceJSON contains the JSON metadata for the struct
// [PricePackageWithAllocationPrice]
type pricePackageWithAllocationPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PackageWithAllocationConfig   apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PricePackageWithAllocationPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackageWithAllocationPriceJSON) RawJSON() string {
	return r.raw
}

func (r PricePackageWithAllocationPrice) implementsPrice() {}

type PricePackageWithAllocationPriceCadence string

const (
	PricePackageWithAllocationPriceCadenceOneTime    PricePackageWithAllocationPriceCadence = "one_time"
	PricePackageWithAllocationPriceCadenceMonthly    PricePackageWithAllocationPriceCadence = "monthly"
	PricePackageWithAllocationPriceCadenceQuarterly  PricePackageWithAllocationPriceCadence = "quarterly"
	PricePackageWithAllocationPriceCadenceSemiAnnual PricePackageWithAllocationPriceCadence = "semi_annual"
	PricePackageWithAllocationPriceCadenceAnnual     PricePackageWithAllocationPriceCadence = "annual"
	PricePackageWithAllocationPriceCadenceCustom     PricePackageWithAllocationPriceCadence = "custom"
)

func (r PricePackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case PricePackageWithAllocationPriceCadenceOneTime, PricePackageWithAllocationPriceCadenceMonthly, PricePackageWithAllocationPriceCadenceQuarterly, PricePackageWithAllocationPriceCadenceSemiAnnual, PricePackageWithAllocationPriceCadenceAnnual, PricePackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type PricePackageWithAllocationPriceConversionRateConfig struct {
	ConversionRateType PricePackageWithAllocationPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                             `json:"unit_config"`
	JSON       pricePackageWithAllocationPriceConversionRateConfigJSON `json:"-"`
	union      PricePackageWithAllocationPriceConversionRateConfigUnion
}

// pricePackageWithAllocationPriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PricePackageWithAllocationPriceConversionRateConfig]
type pricePackageWithAllocationPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r pricePackageWithAllocationPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PricePackageWithAllocationPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PricePackageWithAllocationPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PricePackageWithAllocationPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig],
// [PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig].
func (r PricePackageWithAllocationPriceConversionRateConfig) AsUnion() PricePackageWithAllocationPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig] or
// [PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig].
type PricePackageWithAllocationPriceConversionRateConfigUnion interface {
	implementsPricePackageWithAllocationPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PricePackageWithAllocationPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig]
type pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfig) implementsPricePackageWithAllocationPriceConversionRateConfig() {
}

type PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                    `json:"unit_amount,required"`
	JSON       pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackageWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig]
type pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfig) implementsPricePackageWithAllocationPriceConversionRateConfig() {
}

type PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                           `json:"last_unit,nullable"`
	JSON     pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r pricePackageWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PricePackageWithAllocationPriceConversionRateConfigConversionRateType string

const (
	PricePackageWithAllocationPriceConversionRateConfigConversionRateTypeUnit   PricePackageWithAllocationPriceConversionRateConfigConversionRateType = "unit"
	PricePackageWithAllocationPriceConversionRateConfigConversionRateTypeTiered PricePackageWithAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PricePackageWithAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PricePackageWithAllocationPriceConversionRateConfigConversionRateTypeUnit, PricePackageWithAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PricePackageWithAllocationPriceModelType string

const (
	PricePackageWithAllocationPriceModelTypePackageWithAllocation PricePackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r PricePackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case PricePackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

type PricePackageWithAllocationPricePriceType string

const (
	PricePackageWithAllocationPricePriceTypeUsagePrice PricePackageWithAllocationPricePriceType = "usage_price"
	PricePackageWithAllocationPricePriceTypeFixedPrice PricePackageWithAllocationPricePriceType = "fixed_price"
)

func (r PricePackageWithAllocationPricePriceType) IsKnown() bool {
	switch r {
	case PricePackageWithAllocationPricePriceTypeUsagePrice, PricePackageWithAllocationPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceUnitWithPercentPrice struct {
	ID                        string                                        `json:"id,required"`
	BillableMetric            BillableMetricTiny                            `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                     `json:"billing_cycle_configuration,required"`
	Cadence                   PriceUnitWithPercentPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                       `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceUnitWithPercentPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                     `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                    `json:"credit_allocation,required,nullable"`
	Currency                  string                                        `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                             `json:"minimum_amount,required,nullable"`
	ModelType                     PriceUnitWithPercentPriceModelType `json:"model_type,required"`
	Name                          string                             `json:"name,required"`
	PlanPhaseOrder                int64                              `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceUnitWithPercentPricePriceType `json:"price_type,required"`
	UnitWithPercentConfig         map[string]interface{}             `json:"unit_with_percent_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration      `json:"dimensional_price_configuration,nullable"`
	JSON                          priceUnitWithPercentPriceJSON      `json:"-"`
}

// priceUnitWithPercentPriceJSON contains the JSON metadata for the struct
// [PriceUnitWithPercentPrice]
type priceUnitWithPercentPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	UnitWithPercentConfig         apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceUnitWithPercentPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithPercentPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitWithPercentPrice) implementsPrice() {}

type PriceUnitWithPercentPriceCadence string

const (
	PriceUnitWithPercentPriceCadenceOneTime    PriceUnitWithPercentPriceCadence = "one_time"
	PriceUnitWithPercentPriceCadenceMonthly    PriceUnitWithPercentPriceCadence = "monthly"
	PriceUnitWithPercentPriceCadenceQuarterly  PriceUnitWithPercentPriceCadence = "quarterly"
	PriceUnitWithPercentPriceCadenceSemiAnnual PriceUnitWithPercentPriceCadence = "semi_annual"
	PriceUnitWithPercentPriceCadenceAnnual     PriceUnitWithPercentPriceCadence = "annual"
	PriceUnitWithPercentPriceCadenceCustom     PriceUnitWithPercentPriceCadence = "custom"
)

func (r PriceUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case PriceUnitWithPercentPriceCadenceOneTime, PriceUnitWithPercentPriceCadenceMonthly, PriceUnitWithPercentPriceCadenceQuarterly, PriceUnitWithPercentPriceCadenceSemiAnnual, PriceUnitWithPercentPriceCadenceAnnual, PriceUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type PriceUnitWithPercentPriceConversionRateConfig struct {
	ConversionRateType PriceUnitWithPercentPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                       `json:"unit_config"`
	JSON       priceUnitWithPercentPriceConversionRateConfigJSON `json:"-"`
	union      PriceUnitWithPercentPriceConversionRateConfigUnion
}

// priceUnitWithPercentPriceConversionRateConfigJSON contains the JSON metadata for
// the struct [PriceUnitWithPercentPriceConversionRateConfig]
type priceUnitWithPercentPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceUnitWithPercentPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceUnitWithPercentPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceUnitWithPercentPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceUnitWithPercentPriceConversionRateConfigUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig],
// [PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceUnitWithPercentPriceConversionRateConfig) AsUnion() PriceUnitWithPercentPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig].
type PriceUnitWithPercentPriceConversionRateConfigUnion interface {
	implementsPriceUnitWithPercentPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceUnitWithPercentPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig]
type priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfig) implementsPriceUnitWithPercentPriceConversionRateConfig() {
}

type PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                              `json:"unit_amount,required"`
	JSON       priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithPercentPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig]
type priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfig) implementsPriceUnitWithPercentPriceConversionRateConfig() {
}

type PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                     `json:"last_unit,nullable"`
	JSON     priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithPercentPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceUnitWithPercentPriceConversionRateConfigConversionRateType string

const (
	PriceUnitWithPercentPriceConversionRateConfigConversionRateTypeUnit   PriceUnitWithPercentPriceConversionRateConfigConversionRateType = "unit"
	PriceUnitWithPercentPriceConversionRateConfigConversionRateTypeTiered PriceUnitWithPercentPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceUnitWithPercentPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitWithPercentPriceConversionRateConfigConversionRateTypeUnit, PriceUnitWithPercentPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceUnitWithPercentPriceModelType string

const (
	PriceUnitWithPercentPriceModelTypeUnitWithPercent PriceUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r PriceUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case PriceUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

type PriceUnitWithPercentPricePriceType string

const (
	PriceUnitWithPercentPricePriceTypeUsagePrice PriceUnitWithPercentPricePriceType = "usage_price"
	PriceUnitWithPercentPricePriceTypeFixedPrice PriceUnitWithPercentPricePriceType = "fixed_price"
)

func (r PriceUnitWithPercentPricePriceType) IsKnown() bool {
	switch r {
	case PriceUnitWithPercentPricePriceTypeUsagePrice, PriceUnitWithPercentPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceMatrixWithAllocationPrice struct {
	ID                        string                                             `json:"id,required"`
	BillableMetric            BillableMetricTiny                                 `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                          `json:"billing_cycle_configuration,required"`
	Cadence                   PriceMatrixWithAllocationPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                            `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceMatrixWithAllocationPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                          `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                         `json:"credit_allocation,required,nullable"`
	Currency                  string                                             `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                   `json:"discount,required,nullable"`
	ExternalPriceID             string                     `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                    `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration  `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                   `json:"item,required"`
	MatrixWithAllocationConfig  MatrixWithAllocationConfig `json:"matrix_with_allocation_config,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                  `json:"minimum_amount,required,nullable"`
	ModelType                     PriceMatrixWithAllocationPriceModelType `json:"model_type,required"`
	Name                          string                                  `json:"name,required"`
	PlanPhaseOrder                int64                                   `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceMatrixWithAllocationPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration           `json:"dimensional_price_configuration,nullable"`
	JSON                          priceMatrixWithAllocationPriceJSON      `json:"-"`
}

// priceMatrixWithAllocationPriceJSON contains the JSON metadata for the struct
// [PriceMatrixWithAllocationPrice]
type priceMatrixWithAllocationPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	MatrixWithAllocationConfig    apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceMatrixWithAllocationPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithAllocationPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixWithAllocationPrice) implementsPrice() {}

type PriceMatrixWithAllocationPriceCadence string

const (
	PriceMatrixWithAllocationPriceCadenceOneTime    PriceMatrixWithAllocationPriceCadence = "one_time"
	PriceMatrixWithAllocationPriceCadenceMonthly    PriceMatrixWithAllocationPriceCadence = "monthly"
	PriceMatrixWithAllocationPriceCadenceQuarterly  PriceMatrixWithAllocationPriceCadence = "quarterly"
	PriceMatrixWithAllocationPriceCadenceSemiAnnual PriceMatrixWithAllocationPriceCadence = "semi_annual"
	PriceMatrixWithAllocationPriceCadenceAnnual     PriceMatrixWithAllocationPriceCadence = "annual"
	PriceMatrixWithAllocationPriceCadenceCustom     PriceMatrixWithAllocationPriceCadence = "custom"
)

func (r PriceMatrixWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case PriceMatrixWithAllocationPriceCadenceOneTime, PriceMatrixWithAllocationPriceCadenceMonthly, PriceMatrixWithAllocationPriceCadenceQuarterly, PriceMatrixWithAllocationPriceCadenceSemiAnnual, PriceMatrixWithAllocationPriceCadenceAnnual, PriceMatrixWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type PriceMatrixWithAllocationPriceConversionRateConfig struct {
	ConversionRateType PriceMatrixWithAllocationPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                            `json:"unit_config"`
	JSON       priceMatrixWithAllocationPriceConversionRateConfigJSON `json:"-"`
	union      PriceMatrixWithAllocationPriceConversionRateConfigUnion
}

// priceMatrixWithAllocationPriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceMatrixWithAllocationPriceConversionRateConfig]
type priceMatrixWithAllocationPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceMatrixWithAllocationPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceMatrixWithAllocationPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceMatrixWithAllocationPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceMatrixWithAllocationPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig],
// [PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceMatrixWithAllocationPriceConversionRateConfig) AsUnion() PriceMatrixWithAllocationPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig].
type PriceMatrixWithAllocationPriceConversionRateConfigUnion interface {
	implementsPriceMatrixWithAllocationPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceMatrixWithAllocationPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig]
type priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfig) implementsPriceMatrixWithAllocationPriceConversionRateConfig() {
}

type PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                   `json:"unit_amount,required"`
	JSON       priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig]
type priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfig) implementsPriceMatrixWithAllocationPriceConversionRateConfig() {
}

type PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                          `json:"last_unit,nullable"`
	JSON     priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixWithAllocationPriceConversionRateConfigConversionRateType string

const (
	PriceMatrixWithAllocationPriceConversionRateConfigConversionRateTypeUnit   PriceMatrixWithAllocationPriceConversionRateConfigConversionRateType = "unit"
	PriceMatrixWithAllocationPriceConversionRateConfigConversionRateTypeTiered PriceMatrixWithAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMatrixWithAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixWithAllocationPriceConversionRateConfigConversionRateTypeUnit, PriceMatrixWithAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMatrixWithAllocationPriceModelType string

const (
	PriceMatrixWithAllocationPriceModelTypeMatrixWithAllocation PriceMatrixWithAllocationPriceModelType = "matrix_with_allocation"
)

func (r PriceMatrixWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case PriceMatrixWithAllocationPriceModelTypeMatrixWithAllocation:
		return true
	}
	return false
}

type PriceMatrixWithAllocationPricePriceType string

const (
	PriceMatrixWithAllocationPricePriceTypeUsagePrice PriceMatrixWithAllocationPricePriceType = "usage_price"
	PriceMatrixWithAllocationPricePriceTypeFixedPrice PriceMatrixWithAllocationPricePriceType = "fixed_price"
)

func (r PriceMatrixWithAllocationPricePriceType) IsKnown() bool {
	switch r {
	case PriceMatrixWithAllocationPricePriceTypeUsagePrice, PriceMatrixWithAllocationPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceTieredWithProrationPrice struct {
	ID                        string                                            `json:"id,required"`
	BillableMetric            BillableMetricTiny                                `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                         `json:"billing_cycle_configuration,required"`
	Cadence                   PriceTieredWithProrationPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                           `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceTieredWithProrationPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                         `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                        `json:"credit_allocation,required,nullable"`
	Currency                  string                                            `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                 `json:"minimum_amount,required,nullable"`
	ModelType                     PriceTieredWithProrationPriceModelType `json:"model_type,required"`
	Name                          string                                 `json:"name,required"`
	PlanPhaseOrder                int64                                  `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceTieredWithProrationPricePriceType `json:"price_type,required"`
	TieredWithProrationConfig     map[string]interface{}                 `json:"tiered_with_proration_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration          `json:"dimensional_price_configuration,nullable"`
	JSON                          priceTieredWithProrationPriceJSON      `json:"-"`
}

// priceTieredWithProrationPriceJSON contains the JSON metadata for the struct
// [PriceTieredWithProrationPrice]
type priceTieredWithProrationPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	TieredWithProrationConfig     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceTieredWithProrationPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithProrationPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredWithProrationPrice) implementsPrice() {}

type PriceTieredWithProrationPriceCadence string

const (
	PriceTieredWithProrationPriceCadenceOneTime    PriceTieredWithProrationPriceCadence = "one_time"
	PriceTieredWithProrationPriceCadenceMonthly    PriceTieredWithProrationPriceCadence = "monthly"
	PriceTieredWithProrationPriceCadenceQuarterly  PriceTieredWithProrationPriceCadence = "quarterly"
	PriceTieredWithProrationPriceCadenceSemiAnnual PriceTieredWithProrationPriceCadence = "semi_annual"
	PriceTieredWithProrationPriceCadenceAnnual     PriceTieredWithProrationPriceCadence = "annual"
	PriceTieredWithProrationPriceCadenceCustom     PriceTieredWithProrationPriceCadence = "custom"
)

func (r PriceTieredWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case PriceTieredWithProrationPriceCadenceOneTime, PriceTieredWithProrationPriceCadenceMonthly, PriceTieredWithProrationPriceCadenceQuarterly, PriceTieredWithProrationPriceCadenceSemiAnnual, PriceTieredWithProrationPriceCadenceAnnual, PriceTieredWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type PriceTieredWithProrationPriceConversionRateConfig struct {
	ConversionRateType PriceTieredWithProrationPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                           `json:"unit_config"`
	JSON       priceTieredWithProrationPriceConversionRateConfigJSON `json:"-"`
	union      PriceTieredWithProrationPriceConversionRateConfigUnion
}

// priceTieredWithProrationPriceConversionRateConfigJSON contains the JSON metadata
// for the struct [PriceTieredWithProrationPriceConversionRateConfig]
type priceTieredWithProrationPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceTieredWithProrationPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceTieredWithProrationPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceTieredWithProrationPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceTieredWithProrationPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig],
// [PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceTieredWithProrationPriceConversionRateConfig) AsUnion() PriceTieredWithProrationPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig].
type PriceTieredWithProrationPriceConversionRateConfigUnion interface {
	implementsPriceTieredWithProrationPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceTieredWithProrationPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig]
type priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfig) implementsPriceTieredWithProrationPriceConversionRateConfig() {
}

type PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                  `json:"unit_amount,required"`
	JSON       priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig]
type priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfig) implementsPriceTieredWithProrationPriceConversionRateConfig() {
}

type PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                         `json:"last_unit,nullable"`
	JSON     priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceTieredWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceTieredWithProrationPriceConversionRateConfigConversionRateType string

const (
	PriceTieredWithProrationPriceConversionRateConfigConversionRateTypeUnit   PriceTieredWithProrationPriceConversionRateConfigConversionRateType = "unit"
	PriceTieredWithProrationPriceConversionRateConfigConversionRateTypeTiered PriceTieredWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceTieredWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceTieredWithProrationPriceConversionRateConfigConversionRateTypeUnit, PriceTieredWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceTieredWithProrationPriceModelType string

const (
	PriceTieredWithProrationPriceModelTypeTieredWithProration PriceTieredWithProrationPriceModelType = "tiered_with_proration"
)

func (r PriceTieredWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case PriceTieredWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

type PriceTieredWithProrationPricePriceType string

const (
	PriceTieredWithProrationPricePriceTypeUsagePrice PriceTieredWithProrationPricePriceType = "usage_price"
	PriceTieredWithProrationPricePriceTypeFixedPrice PriceTieredWithProrationPricePriceType = "fixed_price"
)

func (r PriceTieredWithProrationPricePriceType) IsKnown() bool {
	switch r {
	case PriceTieredWithProrationPricePriceTypeUsagePrice, PriceTieredWithProrationPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceUnitWithProrationPrice struct {
	ID                        string                                          `json:"id,required"`
	BillableMetric            BillableMetricTiny                              `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                       `json:"billing_cycle_configuration,required"`
	Cadence                   PriceUnitWithProrationPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                         `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceUnitWithProrationPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                       `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                      `json:"credit_allocation,required,nullable"`
	Currency                  string                                          `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                               `json:"minimum_amount,required,nullable"`
	ModelType                     PriceUnitWithProrationPriceModelType `json:"model_type,required"`
	Name                          string                               `json:"name,required"`
	PlanPhaseOrder                int64                                `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceUnitWithProrationPricePriceType `json:"price_type,required"`
	UnitWithProrationConfig       map[string]interface{}               `json:"unit_with_proration_config,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration        `json:"dimensional_price_configuration,nullable"`
	JSON                          priceUnitWithProrationPriceJSON      `json:"-"`
}

// priceUnitWithProrationPriceJSON contains the JSON metadata for the struct
// [PriceUnitWithProrationPrice]
type priceUnitWithProrationPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	UnitWithProrationConfig       apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceUnitWithProrationPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithProrationPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitWithProrationPrice) implementsPrice() {}

type PriceUnitWithProrationPriceCadence string

const (
	PriceUnitWithProrationPriceCadenceOneTime    PriceUnitWithProrationPriceCadence = "one_time"
	PriceUnitWithProrationPriceCadenceMonthly    PriceUnitWithProrationPriceCadence = "monthly"
	PriceUnitWithProrationPriceCadenceQuarterly  PriceUnitWithProrationPriceCadence = "quarterly"
	PriceUnitWithProrationPriceCadenceSemiAnnual PriceUnitWithProrationPriceCadence = "semi_annual"
	PriceUnitWithProrationPriceCadenceAnnual     PriceUnitWithProrationPriceCadence = "annual"
	PriceUnitWithProrationPriceCadenceCustom     PriceUnitWithProrationPriceCadence = "custom"
)

func (r PriceUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case PriceUnitWithProrationPriceCadenceOneTime, PriceUnitWithProrationPriceCadenceMonthly, PriceUnitWithProrationPriceCadenceQuarterly, PriceUnitWithProrationPriceCadenceSemiAnnual, PriceUnitWithProrationPriceCadenceAnnual, PriceUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type PriceUnitWithProrationPriceConversionRateConfig struct {
	ConversionRateType PriceUnitWithProrationPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                         `json:"unit_config"`
	JSON       priceUnitWithProrationPriceConversionRateConfigJSON `json:"-"`
	union      PriceUnitWithProrationPriceConversionRateConfigUnion
}

// priceUnitWithProrationPriceConversionRateConfigJSON contains the JSON metadata
// for the struct [PriceUnitWithProrationPriceConversionRateConfig]
type priceUnitWithProrationPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceUnitWithProrationPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceUnitWithProrationPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceUnitWithProrationPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceUnitWithProrationPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig],
// [PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceUnitWithProrationPriceConversionRateConfig) AsUnion() PriceUnitWithProrationPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig].
type PriceUnitWithProrationPriceConversionRateConfigUnion interface {
	implementsPriceUnitWithProrationPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceUnitWithProrationPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig]
type priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfig) implementsPriceUnitWithProrationPriceConversionRateConfig() {
}

type PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                `json:"unit_amount,required"`
	JSON       priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig]
type priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfig) implementsPriceUnitWithProrationPriceConversionRateConfig() {
}

type PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                       `json:"last_unit,nullable"`
	JSON     priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceUnitWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceUnitWithProrationPriceConversionRateConfigConversionRateType string

const (
	PriceUnitWithProrationPriceConversionRateConfigConversionRateTypeUnit   PriceUnitWithProrationPriceConversionRateConfigConversionRateType = "unit"
	PriceUnitWithProrationPriceConversionRateConfigConversionRateTypeTiered PriceUnitWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceUnitWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceUnitWithProrationPriceConversionRateConfigConversionRateTypeUnit, PriceUnitWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceUnitWithProrationPriceModelType string

const (
	PriceUnitWithProrationPriceModelTypeUnitWithProration PriceUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r PriceUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case PriceUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

type PriceUnitWithProrationPricePriceType string

const (
	PriceUnitWithProrationPricePriceTypeUsagePrice PriceUnitWithProrationPricePriceType = "usage_price"
	PriceUnitWithProrationPricePriceTypeFixedPrice PriceUnitWithProrationPricePriceType = "fixed_price"
)

func (r PriceUnitWithProrationPricePriceType) IsKnown() bool {
	switch r {
	case PriceUnitWithProrationPricePriceTypeUsagePrice, PriceUnitWithProrationPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceGroupedAllocationPrice struct {
	ID                        string                                          `json:"id,required"`
	BillableMetric            BillableMetricTiny                              `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                       `json:"billing_cycle_configuration,required"`
	Cadence                   PriceGroupedAllocationPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                         `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceGroupedAllocationPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                       `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                      `json:"credit_allocation,required,nullable"`
	Currency                  string                                          `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	GroupedAllocationConfig     map[string]interface{}    `json:"grouped_allocation_config,required"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                               `json:"minimum_amount,required,nullable"`
	ModelType                     PriceGroupedAllocationPriceModelType `json:"model_type,required"`
	Name                          string                               `json:"name,required"`
	PlanPhaseOrder                int64                                `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceGroupedAllocationPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration        `json:"dimensional_price_configuration,nullable"`
	JSON                          priceGroupedAllocationPriceJSON      `json:"-"`
}

// priceGroupedAllocationPriceJSON contains the JSON metadata for the struct
// [PriceGroupedAllocationPrice]
type priceGroupedAllocationPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	GroupedAllocationConfig       apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceGroupedAllocationPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedAllocationPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedAllocationPrice) implementsPrice() {}

type PriceGroupedAllocationPriceCadence string

const (
	PriceGroupedAllocationPriceCadenceOneTime    PriceGroupedAllocationPriceCadence = "one_time"
	PriceGroupedAllocationPriceCadenceMonthly    PriceGroupedAllocationPriceCadence = "monthly"
	PriceGroupedAllocationPriceCadenceQuarterly  PriceGroupedAllocationPriceCadence = "quarterly"
	PriceGroupedAllocationPriceCadenceSemiAnnual PriceGroupedAllocationPriceCadence = "semi_annual"
	PriceGroupedAllocationPriceCadenceAnnual     PriceGroupedAllocationPriceCadence = "annual"
	PriceGroupedAllocationPriceCadenceCustom     PriceGroupedAllocationPriceCadence = "custom"
)

func (r PriceGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case PriceGroupedAllocationPriceCadenceOneTime, PriceGroupedAllocationPriceCadenceMonthly, PriceGroupedAllocationPriceCadenceQuarterly, PriceGroupedAllocationPriceCadenceSemiAnnual, PriceGroupedAllocationPriceCadenceAnnual, PriceGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type PriceGroupedAllocationPriceConversionRateConfig struct {
	ConversionRateType PriceGroupedAllocationPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                         `json:"unit_config"`
	JSON       priceGroupedAllocationPriceConversionRateConfigJSON `json:"-"`
	union      PriceGroupedAllocationPriceConversionRateConfigUnion
}

// priceGroupedAllocationPriceConversionRateConfigJSON contains the JSON metadata
// for the struct [PriceGroupedAllocationPriceConversionRateConfig]
type priceGroupedAllocationPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceGroupedAllocationPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceGroupedAllocationPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceGroupedAllocationPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceGroupedAllocationPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig],
// [PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceGroupedAllocationPriceConversionRateConfig) AsUnion() PriceGroupedAllocationPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig].
type PriceGroupedAllocationPriceConversionRateConfigUnion interface {
	implementsPriceGroupedAllocationPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceGroupedAllocationPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig]
type priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfig) implementsPriceGroupedAllocationPriceConversionRateConfig() {
}

type PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                `json:"unit_amount,required"`
	JSON       priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedAllocationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig]
type priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfig) implementsPriceGroupedAllocationPriceConversionRateConfig() {
}

type PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                       `json:"last_unit,nullable"`
	JSON     priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedAllocationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedAllocationPriceConversionRateConfigConversionRateType string

const (
	PriceGroupedAllocationPriceConversionRateConfigConversionRateTypeUnit   PriceGroupedAllocationPriceConversionRateConfigConversionRateType = "unit"
	PriceGroupedAllocationPriceConversionRateConfigConversionRateTypeTiered PriceGroupedAllocationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedAllocationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedAllocationPriceConversionRateConfigConversionRateTypeUnit, PriceGroupedAllocationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedAllocationPriceModelType string

const (
	PriceGroupedAllocationPriceModelTypeGroupedAllocation PriceGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r PriceGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case PriceGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

type PriceGroupedAllocationPricePriceType string

const (
	PriceGroupedAllocationPricePriceTypeUsagePrice PriceGroupedAllocationPricePriceType = "usage_price"
	PriceGroupedAllocationPricePriceTypeFixedPrice PriceGroupedAllocationPricePriceType = "fixed_price"
)

func (r PriceGroupedAllocationPricePriceType) IsKnown() bool {
	switch r {
	case PriceGroupedAllocationPricePriceTypeUsagePrice, PriceGroupedAllocationPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceGroupedWithProratedMinimumPrice struct {
	ID                        string                                                   `json:"id,required"`
	BillableMetric            BillableMetricTiny                                       `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                                `json:"billing_cycle_configuration,required"`
	Cadence                   PriceGroupedWithProratedMinimumPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                                  `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceGroupedWithProratedMinimumPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                                `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                               `json:"credit_allocation,required,nullable"`
	Currency                  string                                                   `json:"currency,required"`
	// Deprecated: deprecated
	Discount                         Discount                  `json:"discount,required,nullable"`
	ExternalPriceID                  string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity               float64                   `json:"fixed_price_quantity,required,nullable"`
	GroupedWithProratedMinimumConfig map[string]interface{}    `json:"grouped_with_prorated_minimum_config,required"`
	InvoicingCycleConfiguration      BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                             ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                        `json:"minimum_amount,required,nullable"`
	ModelType                     PriceGroupedWithProratedMinimumPriceModelType `json:"model_type,required"`
	Name                          string                                        `json:"name,required"`
	PlanPhaseOrder                int64                                         `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceGroupedWithProratedMinimumPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration                 `json:"dimensional_price_configuration,nullable"`
	JSON                          priceGroupedWithProratedMinimumPriceJSON      `json:"-"`
}

// priceGroupedWithProratedMinimumPriceJSON contains the JSON metadata for the
// struct [PriceGroupedWithProratedMinimumPrice]
type priceGroupedWithProratedMinimumPriceJSON struct {
	ID                               apijson.Field
	BillableMetric                   apijson.Field
	BillingCycleConfiguration        apijson.Field
	Cadence                          apijson.Field
	ConversionRate                   apijson.Field
	ConversionRateConfig             apijson.Field
	CreatedAt                        apijson.Field
	CreditAllocation                 apijson.Field
	Currency                         apijson.Field
	Discount                         apijson.Field
	ExternalPriceID                  apijson.Field
	FixedPriceQuantity               apijson.Field
	GroupedWithProratedMinimumConfig apijson.Field
	InvoicingCycleConfiguration      apijson.Field
	Item                             apijson.Field
	Maximum                          apijson.Field
	MaximumAmount                    apijson.Field
	Metadata                         apijson.Field
	Minimum                          apijson.Field
	MinimumAmount                    apijson.Field
	ModelType                        apijson.Field
	Name                             apijson.Field
	PlanPhaseOrder                   apijson.Field
	PriceType                        apijson.Field
	DimensionalPriceConfiguration    apijson.Field
	raw                              string
	ExtraFields                      map[string]apijson.Field
}

func (r *PriceGroupedWithProratedMinimumPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithProratedMinimumPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedWithProratedMinimumPrice) implementsPrice() {}

type PriceGroupedWithProratedMinimumPriceCadence string

const (
	PriceGroupedWithProratedMinimumPriceCadenceOneTime    PriceGroupedWithProratedMinimumPriceCadence = "one_time"
	PriceGroupedWithProratedMinimumPriceCadenceMonthly    PriceGroupedWithProratedMinimumPriceCadence = "monthly"
	PriceGroupedWithProratedMinimumPriceCadenceQuarterly  PriceGroupedWithProratedMinimumPriceCadence = "quarterly"
	PriceGroupedWithProratedMinimumPriceCadenceSemiAnnual PriceGroupedWithProratedMinimumPriceCadence = "semi_annual"
	PriceGroupedWithProratedMinimumPriceCadenceAnnual     PriceGroupedWithProratedMinimumPriceCadence = "annual"
	PriceGroupedWithProratedMinimumPriceCadenceCustom     PriceGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r PriceGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case PriceGroupedWithProratedMinimumPriceCadenceOneTime, PriceGroupedWithProratedMinimumPriceCadenceMonthly, PriceGroupedWithProratedMinimumPriceCadenceQuarterly, PriceGroupedWithProratedMinimumPriceCadenceSemiAnnual, PriceGroupedWithProratedMinimumPriceCadenceAnnual, PriceGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfig struct {
	ConversionRateType PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                                  `json:"unit_config"`
	JSON       priceGroupedWithProratedMinimumPriceConversionRateConfigJSON `json:"-"`
	union      PriceGroupedWithProratedMinimumPriceConversionRateConfigUnion
}

// priceGroupedWithProratedMinimumPriceConversionRateConfigJSON contains the JSON
// metadata for the struct
// [PriceGroupedWithProratedMinimumPriceConversionRateConfig]
type priceGroupedWithProratedMinimumPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceGroupedWithProratedMinimumPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceGroupedWithProratedMinimumPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceGroupedWithProratedMinimumPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigUnion] interface which
// you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig],
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceGroupedWithProratedMinimumPriceConversionRateConfig) AsUnion() PriceGroupedWithProratedMinimumPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig]
// or
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig].
type PriceGroupedWithProratedMinimumPriceConversionRateConfigUnion interface {
	implementsPriceGroupedWithProratedMinimumPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceGroupedWithProratedMinimumPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig]
type priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfig) implementsPriceGroupedWithProratedMinimumPriceConversionRateConfig() {
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                         `json:"unit_amount,required"`
	JSON       priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithProratedMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig]
type priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfig) implementsPriceGroupedWithProratedMinimumPriceConversionRateConfig() {
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                                `json:"last_unit,nullable"`
	JSON     priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithProratedMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType string

const (
	PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeUnit   PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType = "unit"
	PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeTiered PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeUnit, PriceGroupedWithProratedMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedWithProratedMinimumPriceModelType string

const (
	PriceGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum PriceGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r PriceGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case PriceGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

type PriceGroupedWithProratedMinimumPricePriceType string

const (
	PriceGroupedWithProratedMinimumPricePriceTypeUsagePrice PriceGroupedWithProratedMinimumPricePriceType = "usage_price"
	PriceGroupedWithProratedMinimumPricePriceTypeFixedPrice PriceGroupedWithProratedMinimumPricePriceType = "fixed_price"
)

func (r PriceGroupedWithProratedMinimumPricePriceType) IsKnown() bool {
	switch r {
	case PriceGroupedWithProratedMinimumPricePriceTypeUsagePrice, PriceGroupedWithProratedMinimumPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceGroupedWithMeteredMinimumPrice struct {
	ID                        string                                                  `json:"id,required"`
	BillableMetric            BillableMetricTiny                                      `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                               `json:"billing_cycle_configuration,required"`
	Cadence                   PriceGroupedWithMeteredMinimumPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                                 `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceGroupedWithMeteredMinimumPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                               `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                              `json:"credit_allocation,required,nullable"`
	Currency                  string                                                  `json:"currency,required"`
	// Deprecated: deprecated
	Discount                        Discount                  `json:"discount,required,nullable"`
	ExternalPriceID                 string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity              float64                   `json:"fixed_price_quantity,required,nullable"`
	GroupedWithMeteredMinimumConfig map[string]interface{}    `json:"grouped_with_metered_minimum_config,required"`
	InvoicingCycleConfiguration     BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                            ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                       `json:"minimum_amount,required,nullable"`
	ModelType                     PriceGroupedWithMeteredMinimumPriceModelType `json:"model_type,required"`
	Name                          string                                       `json:"name,required"`
	PlanPhaseOrder                int64                                        `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceGroupedWithMeteredMinimumPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration                `json:"dimensional_price_configuration,nullable"`
	JSON                          priceGroupedWithMeteredMinimumPriceJSON      `json:"-"`
}

// priceGroupedWithMeteredMinimumPriceJSON contains the JSON metadata for the
// struct [PriceGroupedWithMeteredMinimumPrice]
type priceGroupedWithMeteredMinimumPriceJSON struct {
	ID                              apijson.Field
	BillableMetric                  apijson.Field
	BillingCycleConfiguration       apijson.Field
	Cadence                         apijson.Field
	ConversionRate                  apijson.Field
	ConversionRateConfig            apijson.Field
	CreatedAt                       apijson.Field
	CreditAllocation                apijson.Field
	Currency                        apijson.Field
	Discount                        apijson.Field
	ExternalPriceID                 apijson.Field
	FixedPriceQuantity              apijson.Field
	GroupedWithMeteredMinimumConfig apijson.Field
	InvoicingCycleConfiguration     apijson.Field
	Item                            apijson.Field
	Maximum                         apijson.Field
	MaximumAmount                   apijson.Field
	Metadata                        apijson.Field
	Minimum                         apijson.Field
	MinimumAmount                   apijson.Field
	ModelType                       apijson.Field
	Name                            apijson.Field
	PlanPhaseOrder                  apijson.Field
	PriceType                       apijson.Field
	DimensionalPriceConfiguration   apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *PriceGroupedWithMeteredMinimumPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithMeteredMinimumPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedWithMeteredMinimumPrice) implementsPrice() {}

type PriceGroupedWithMeteredMinimumPriceCadence string

const (
	PriceGroupedWithMeteredMinimumPriceCadenceOneTime    PriceGroupedWithMeteredMinimumPriceCadence = "one_time"
	PriceGroupedWithMeteredMinimumPriceCadenceMonthly    PriceGroupedWithMeteredMinimumPriceCadence = "monthly"
	PriceGroupedWithMeteredMinimumPriceCadenceQuarterly  PriceGroupedWithMeteredMinimumPriceCadence = "quarterly"
	PriceGroupedWithMeteredMinimumPriceCadenceSemiAnnual PriceGroupedWithMeteredMinimumPriceCadence = "semi_annual"
	PriceGroupedWithMeteredMinimumPriceCadenceAnnual     PriceGroupedWithMeteredMinimumPriceCadence = "annual"
	PriceGroupedWithMeteredMinimumPriceCadenceCustom     PriceGroupedWithMeteredMinimumPriceCadence = "custom"
)

func (r PriceGroupedWithMeteredMinimumPriceCadence) IsKnown() bool {
	switch r {
	case PriceGroupedWithMeteredMinimumPriceCadenceOneTime, PriceGroupedWithMeteredMinimumPriceCadenceMonthly, PriceGroupedWithMeteredMinimumPriceCadenceQuarterly, PriceGroupedWithMeteredMinimumPriceCadenceSemiAnnual, PriceGroupedWithMeteredMinimumPriceCadenceAnnual, PriceGroupedWithMeteredMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfig struct {
	ConversionRateType PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                                 `json:"unit_config"`
	JSON       priceGroupedWithMeteredMinimumPriceConversionRateConfigJSON `json:"-"`
	union      PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnion
}

// priceGroupedWithMeteredMinimumPriceConversionRateConfigJSON contains the JSON
// metadata for the struct
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfig]
type priceGroupedWithMeteredMinimumPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceGroupedWithMeteredMinimumPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceGroupedWithMeteredMinimumPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceGroupedWithMeteredMinimumPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig],
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceGroupedWithMeteredMinimumPriceConversionRateConfig) AsUnion() PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig]
// or
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig].
type PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnion interface {
	implementsPriceGroupedWithMeteredMinimumPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig]
type priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfig) implementsPriceGroupedWithMeteredMinimumPriceConversionRateConfig() {
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                        `json:"unit_amount,required"`
	JSON       priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithMeteredMinimumPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig]
type priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfig) implementsPriceGroupedWithMeteredMinimumPriceConversionRateConfig() {
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                               `json:"last_unit,nullable"`
	JSON     priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedWithMeteredMinimumPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType string

const (
	PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeUnit   PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType = "unit"
	PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeTiered PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeUnit, PriceGroupedWithMeteredMinimumPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedWithMeteredMinimumPriceModelType string

const (
	PriceGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum PriceGroupedWithMeteredMinimumPriceModelType = "grouped_with_metered_minimum"
)

func (r PriceGroupedWithMeteredMinimumPriceModelType) IsKnown() bool {
	switch r {
	case PriceGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum:
		return true
	}
	return false
}

type PriceGroupedWithMeteredMinimumPricePriceType string

const (
	PriceGroupedWithMeteredMinimumPricePriceTypeUsagePrice PriceGroupedWithMeteredMinimumPricePriceType = "usage_price"
	PriceGroupedWithMeteredMinimumPricePriceTypeFixedPrice PriceGroupedWithMeteredMinimumPricePriceType = "fixed_price"
)

func (r PriceGroupedWithMeteredMinimumPricePriceType) IsKnown() bool {
	switch r {
	case PriceGroupedWithMeteredMinimumPricePriceTypeUsagePrice, PriceGroupedWithMeteredMinimumPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceMatrixWithDisplayNamePrice struct {
	ID                        string                                              `json:"id,required"`
	BillableMetric            BillableMetricTiny                                  `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                           `json:"billing_cycle_configuration,required"`
	Cadence                   PriceMatrixWithDisplayNamePriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                             `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceMatrixWithDisplayNamePriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                           `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                          `json:"credit_allocation,required,nullable"`
	Currency                  string                                              `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	MatrixWithDisplayNameConfig map[string]interface{}    `json:"matrix_with_display_name_config,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                   `json:"minimum_amount,required,nullable"`
	ModelType                     PriceMatrixWithDisplayNamePriceModelType `json:"model_type,required"`
	Name                          string                                   `json:"name,required"`
	PlanPhaseOrder                int64                                    `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceMatrixWithDisplayNamePricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration            `json:"dimensional_price_configuration,nullable"`
	JSON                          priceMatrixWithDisplayNamePriceJSON      `json:"-"`
}

// priceMatrixWithDisplayNamePriceJSON contains the JSON metadata for the struct
// [PriceMatrixWithDisplayNamePrice]
type priceMatrixWithDisplayNamePriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	MatrixWithDisplayNameConfig   apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceMatrixWithDisplayNamePrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithDisplayNamePriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixWithDisplayNamePrice) implementsPrice() {}

type PriceMatrixWithDisplayNamePriceCadence string

const (
	PriceMatrixWithDisplayNamePriceCadenceOneTime    PriceMatrixWithDisplayNamePriceCadence = "one_time"
	PriceMatrixWithDisplayNamePriceCadenceMonthly    PriceMatrixWithDisplayNamePriceCadence = "monthly"
	PriceMatrixWithDisplayNamePriceCadenceQuarterly  PriceMatrixWithDisplayNamePriceCadence = "quarterly"
	PriceMatrixWithDisplayNamePriceCadenceSemiAnnual PriceMatrixWithDisplayNamePriceCadence = "semi_annual"
	PriceMatrixWithDisplayNamePriceCadenceAnnual     PriceMatrixWithDisplayNamePriceCadence = "annual"
	PriceMatrixWithDisplayNamePriceCadenceCustom     PriceMatrixWithDisplayNamePriceCadence = "custom"
)

func (r PriceMatrixWithDisplayNamePriceCadence) IsKnown() bool {
	switch r {
	case PriceMatrixWithDisplayNamePriceCadenceOneTime, PriceMatrixWithDisplayNamePriceCadenceMonthly, PriceMatrixWithDisplayNamePriceCadenceQuarterly, PriceMatrixWithDisplayNamePriceCadenceSemiAnnual, PriceMatrixWithDisplayNamePriceCadenceAnnual, PriceMatrixWithDisplayNamePriceCadenceCustom:
		return true
	}
	return false
}

type PriceMatrixWithDisplayNamePriceConversionRateConfig struct {
	ConversionRateType PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                             `json:"unit_config"`
	JSON       priceMatrixWithDisplayNamePriceConversionRateConfigJSON `json:"-"`
	union      PriceMatrixWithDisplayNamePriceConversionRateConfigUnion
}

// priceMatrixWithDisplayNamePriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceMatrixWithDisplayNamePriceConversionRateConfig]
type priceMatrixWithDisplayNamePriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceMatrixWithDisplayNamePriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceMatrixWithDisplayNamePriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceMatrixWithDisplayNamePriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceMatrixWithDisplayNamePriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig],
// [PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig].
func (r PriceMatrixWithDisplayNamePriceConversionRateConfig) AsUnion() PriceMatrixWithDisplayNamePriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig] or
// [PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig].
type PriceMatrixWithDisplayNamePriceConversionRateConfigUnion interface {
	implementsPriceMatrixWithDisplayNamePriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceMatrixWithDisplayNamePriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig]
type priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfig) implementsPriceMatrixWithDisplayNamePriceConversionRateConfig() {
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                    `json:"unit_amount,required"`
	JSON       priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithDisplayNamePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig]
type priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfig) implementsPriceMatrixWithDisplayNamePriceConversionRateConfig() {
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                           `json:"last_unit,nullable"`
	JSON     priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMatrixWithDisplayNamePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateType string

const (
	PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeUnit   PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateType = "unit"
	PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeTiered PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeUnit, PriceMatrixWithDisplayNamePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMatrixWithDisplayNamePriceModelType string

const (
	PriceMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName PriceMatrixWithDisplayNamePriceModelType = "matrix_with_display_name"
)

func (r PriceMatrixWithDisplayNamePriceModelType) IsKnown() bool {
	switch r {
	case PriceMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName:
		return true
	}
	return false
}

type PriceMatrixWithDisplayNamePricePriceType string

const (
	PriceMatrixWithDisplayNamePricePriceTypeUsagePrice PriceMatrixWithDisplayNamePricePriceType = "usage_price"
	PriceMatrixWithDisplayNamePricePriceTypeFixedPrice PriceMatrixWithDisplayNamePricePriceType = "fixed_price"
)

func (r PriceMatrixWithDisplayNamePricePriceType) IsKnown() bool {
	switch r {
	case PriceMatrixWithDisplayNamePricePriceTypeUsagePrice, PriceMatrixWithDisplayNamePricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceBulkWithProrationPrice struct {
	ID                        string                                          `json:"id,required"`
	BillableMetric            BillableMetricTiny                              `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                       `json:"billing_cycle_configuration,required"`
	BulkWithProrationConfig   map[string]interface{}                          `json:"bulk_with_proration_config,required"`
	Cadence                   PriceBulkWithProrationPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                         `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceBulkWithProrationPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                       `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                      `json:"credit_allocation,required,nullable"`
	Currency                  string                                          `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                               `json:"minimum_amount,required,nullable"`
	ModelType                     PriceBulkWithProrationPriceModelType `json:"model_type,required"`
	Name                          string                               `json:"name,required"`
	PlanPhaseOrder                int64                                `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceBulkWithProrationPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration        `json:"dimensional_price_configuration,nullable"`
	JSON                          priceBulkWithProrationPriceJSON      `json:"-"`
}

// priceBulkWithProrationPriceJSON contains the JSON metadata for the struct
// [PriceBulkWithProrationPrice]
type priceBulkWithProrationPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	BulkWithProrationConfig       apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceBulkWithProrationPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkWithProrationPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkWithProrationPrice) implementsPrice() {}

type PriceBulkWithProrationPriceCadence string

const (
	PriceBulkWithProrationPriceCadenceOneTime    PriceBulkWithProrationPriceCadence = "one_time"
	PriceBulkWithProrationPriceCadenceMonthly    PriceBulkWithProrationPriceCadence = "monthly"
	PriceBulkWithProrationPriceCadenceQuarterly  PriceBulkWithProrationPriceCadence = "quarterly"
	PriceBulkWithProrationPriceCadenceSemiAnnual PriceBulkWithProrationPriceCadence = "semi_annual"
	PriceBulkWithProrationPriceCadenceAnnual     PriceBulkWithProrationPriceCadence = "annual"
	PriceBulkWithProrationPriceCadenceCustom     PriceBulkWithProrationPriceCadence = "custom"
)

func (r PriceBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case PriceBulkWithProrationPriceCadenceOneTime, PriceBulkWithProrationPriceCadenceMonthly, PriceBulkWithProrationPriceCadenceQuarterly, PriceBulkWithProrationPriceCadenceSemiAnnual, PriceBulkWithProrationPriceCadenceAnnual, PriceBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type PriceBulkWithProrationPriceConversionRateConfig struct {
	ConversionRateType PriceBulkWithProrationPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                         `json:"unit_config"`
	JSON       priceBulkWithProrationPriceConversionRateConfigJSON `json:"-"`
	union      PriceBulkWithProrationPriceConversionRateConfigUnion
}

// priceBulkWithProrationPriceConversionRateConfigJSON contains the JSON metadata
// for the struct [PriceBulkWithProrationPriceConversionRateConfig]
type priceBulkWithProrationPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceBulkWithProrationPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceBulkWithProrationPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceBulkWithProrationPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceBulkWithProrationPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig],
// [PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceBulkWithProrationPriceConversionRateConfig) AsUnion() PriceBulkWithProrationPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig].
type PriceBulkWithProrationPriceConversionRateConfigUnion interface {
	implementsPriceBulkWithProrationPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceBulkWithProrationPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig]
type priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfig) implementsPriceBulkWithProrationPriceConversionRateConfig() {
}

type PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                `json:"unit_amount,required"`
	JSON       priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkWithProrationPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig]
type priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfig) implementsPriceBulkWithProrationPriceConversionRateConfig() {
}

type PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                       `json:"last_unit,nullable"`
	JSON     priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceBulkWithProrationPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceBulkWithProrationPriceConversionRateConfigConversionRateType string

const (
	PriceBulkWithProrationPriceConversionRateConfigConversionRateTypeUnit   PriceBulkWithProrationPriceConversionRateConfigConversionRateType = "unit"
	PriceBulkWithProrationPriceConversionRateConfigConversionRateTypeTiered PriceBulkWithProrationPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceBulkWithProrationPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceBulkWithProrationPriceConversionRateConfigConversionRateTypeUnit, PriceBulkWithProrationPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceBulkWithProrationPriceModelType string

const (
	PriceBulkWithProrationPriceModelTypeBulkWithProration PriceBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r PriceBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case PriceBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

type PriceBulkWithProrationPricePriceType string

const (
	PriceBulkWithProrationPricePriceTypeUsagePrice PriceBulkWithProrationPricePriceType = "usage_price"
	PriceBulkWithProrationPricePriceTypeFixedPrice PriceBulkWithProrationPricePriceType = "fixed_price"
)

func (r PriceBulkWithProrationPricePriceType) IsKnown() bool {
	switch r {
	case PriceBulkWithProrationPricePriceTypeUsagePrice, PriceBulkWithProrationPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceGroupedTieredPackagePrice struct {
	ID                        string                                             `json:"id,required"`
	BillableMetric            BillableMetricTiny                                 `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                          `json:"billing_cycle_configuration,required"`
	Cadence                   PriceGroupedTieredPackagePriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                            `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceGroupedTieredPackagePriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                          `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                         `json:"credit_allocation,required,nullable"`
	Currency                  string                                             `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	GroupedTieredPackageConfig  map[string]interface{}    `json:"grouped_tiered_package_config,required"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                  `json:"minimum_amount,required,nullable"`
	ModelType                     PriceGroupedTieredPackagePriceModelType `json:"model_type,required"`
	Name                          string                                  `json:"name,required"`
	PlanPhaseOrder                int64                                   `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceGroupedTieredPackagePricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration           `json:"dimensional_price_configuration,nullable"`
	JSON                          priceGroupedTieredPackagePriceJSON      `json:"-"`
}

// priceGroupedTieredPackagePriceJSON contains the JSON metadata for the struct
// [PriceGroupedTieredPackagePrice]
type priceGroupedTieredPackagePriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	GroupedTieredPackageConfig    apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceGroupedTieredPackagePrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPackagePriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedTieredPackagePrice) implementsPrice() {}

type PriceGroupedTieredPackagePriceCadence string

const (
	PriceGroupedTieredPackagePriceCadenceOneTime    PriceGroupedTieredPackagePriceCadence = "one_time"
	PriceGroupedTieredPackagePriceCadenceMonthly    PriceGroupedTieredPackagePriceCadence = "monthly"
	PriceGroupedTieredPackagePriceCadenceQuarterly  PriceGroupedTieredPackagePriceCadence = "quarterly"
	PriceGroupedTieredPackagePriceCadenceSemiAnnual PriceGroupedTieredPackagePriceCadence = "semi_annual"
	PriceGroupedTieredPackagePriceCadenceAnnual     PriceGroupedTieredPackagePriceCadence = "annual"
	PriceGroupedTieredPackagePriceCadenceCustom     PriceGroupedTieredPackagePriceCadence = "custom"
)

func (r PriceGroupedTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPackagePriceCadenceOneTime, PriceGroupedTieredPackagePriceCadenceMonthly, PriceGroupedTieredPackagePriceCadenceQuarterly, PriceGroupedTieredPackagePriceCadenceSemiAnnual, PriceGroupedTieredPackagePriceCadenceAnnual, PriceGroupedTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type PriceGroupedTieredPackagePriceConversionRateConfig struct {
	ConversionRateType PriceGroupedTieredPackagePriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                            `json:"unit_config"`
	JSON       priceGroupedTieredPackagePriceConversionRateConfigJSON `json:"-"`
	union      PriceGroupedTieredPackagePriceConversionRateConfigUnion
}

// priceGroupedTieredPackagePriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceGroupedTieredPackagePriceConversionRateConfig]
type priceGroupedTieredPackagePriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceGroupedTieredPackagePriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceGroupedTieredPackagePriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceGroupedTieredPackagePriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceGroupedTieredPackagePriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig],
// [PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig].
func (r PriceGroupedTieredPackagePriceConversionRateConfig) AsUnion() PriceGroupedTieredPackagePriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig] or
// [PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig].
type PriceGroupedTieredPackagePriceConversionRateConfigUnion interface {
	implementsPriceGroupedTieredPackagePriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceGroupedTieredPackagePriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig]
type priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfig) implementsPriceGroupedTieredPackagePriceConversionRateConfig() {
}

type PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                   `json:"unit_amount,required"`
	JSON       priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig]
type priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfig) implementsPriceGroupedTieredPackagePriceConversionRateConfig() {
}

type PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                          `json:"last_unit,nullable"`
	JSON     priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceGroupedTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceGroupedTieredPackagePriceConversionRateConfigConversionRateType string

const (
	PriceGroupedTieredPackagePriceConversionRateConfigConversionRateTypeUnit   PriceGroupedTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	PriceGroupedTieredPackagePriceConversionRateConfigConversionRateTypeTiered PriceGroupedTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceGroupedTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPackagePriceConversionRateConfigConversionRateTypeUnit, PriceGroupedTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceGroupedTieredPackagePriceModelType string

const (
	PriceGroupedTieredPackagePriceModelTypeGroupedTieredPackage PriceGroupedTieredPackagePriceModelType = "grouped_tiered_package"
)

func (r PriceGroupedTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPackagePriceModelTypeGroupedTieredPackage:
		return true
	}
	return false
}

type PriceGroupedTieredPackagePricePriceType string

const (
	PriceGroupedTieredPackagePricePriceTypeUsagePrice PriceGroupedTieredPackagePricePriceType = "usage_price"
	PriceGroupedTieredPackagePricePriceTypeFixedPrice PriceGroupedTieredPackagePricePriceType = "fixed_price"
)

func (r PriceGroupedTieredPackagePricePriceType) IsKnown() bool {
	switch r {
	case PriceGroupedTieredPackagePricePriceTypeUsagePrice, PriceGroupedTieredPackagePricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceMaxGroupTieredPackagePrice struct {
	ID                        string                                              `json:"id,required"`
	BillableMetric            BillableMetricTiny                                  `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                           `json:"billing_cycle_configuration,required"`
	Cadence                   PriceMaxGroupTieredPackagePriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                             `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceMaxGroupTieredPackagePriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                           `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                          `json:"credit_allocation,required,nullable"`
	Currency                  string                                              `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	MaxGroupTieredPackageConfig map[string]interface{}    `json:"max_group_tiered_package_config,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                   `json:"minimum_amount,required,nullable"`
	ModelType                     PriceMaxGroupTieredPackagePriceModelType `json:"model_type,required"`
	Name                          string                                   `json:"name,required"`
	PlanPhaseOrder                int64                                    `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceMaxGroupTieredPackagePricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration            `json:"dimensional_price_configuration,nullable"`
	JSON                          priceMaxGroupTieredPackagePriceJSON      `json:"-"`
}

// priceMaxGroupTieredPackagePriceJSON contains the JSON metadata for the struct
// [PriceMaxGroupTieredPackagePrice]
type priceMaxGroupTieredPackagePriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	MaxGroupTieredPackageConfig   apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceMaxGroupTieredPackagePrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMaxGroupTieredPackagePriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceMaxGroupTieredPackagePrice) implementsPrice() {}

type PriceMaxGroupTieredPackagePriceCadence string

const (
	PriceMaxGroupTieredPackagePriceCadenceOneTime    PriceMaxGroupTieredPackagePriceCadence = "one_time"
	PriceMaxGroupTieredPackagePriceCadenceMonthly    PriceMaxGroupTieredPackagePriceCadence = "monthly"
	PriceMaxGroupTieredPackagePriceCadenceQuarterly  PriceMaxGroupTieredPackagePriceCadence = "quarterly"
	PriceMaxGroupTieredPackagePriceCadenceSemiAnnual PriceMaxGroupTieredPackagePriceCadence = "semi_annual"
	PriceMaxGroupTieredPackagePriceCadenceAnnual     PriceMaxGroupTieredPackagePriceCadence = "annual"
	PriceMaxGroupTieredPackagePriceCadenceCustom     PriceMaxGroupTieredPackagePriceCadence = "custom"
)

func (r PriceMaxGroupTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case PriceMaxGroupTieredPackagePriceCadenceOneTime, PriceMaxGroupTieredPackagePriceCadenceMonthly, PriceMaxGroupTieredPackagePriceCadenceQuarterly, PriceMaxGroupTieredPackagePriceCadenceSemiAnnual, PriceMaxGroupTieredPackagePriceCadenceAnnual, PriceMaxGroupTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type PriceMaxGroupTieredPackagePriceConversionRateConfig struct {
	ConversionRateType PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                             `json:"unit_config"`
	JSON       priceMaxGroupTieredPackagePriceConversionRateConfigJSON `json:"-"`
	union      PriceMaxGroupTieredPackagePriceConversionRateConfigUnion
}

// priceMaxGroupTieredPackagePriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceMaxGroupTieredPackagePriceConversionRateConfig]
type priceMaxGroupTieredPackagePriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceMaxGroupTieredPackagePriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceMaxGroupTieredPackagePriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceMaxGroupTieredPackagePriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceMaxGroupTieredPackagePriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig],
// [PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig].
func (r PriceMaxGroupTieredPackagePriceConversionRateConfig) AsUnion() PriceMaxGroupTieredPackagePriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig] or
// [PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig].
type PriceMaxGroupTieredPackagePriceConversionRateConfigUnion interface {
	implementsPriceMaxGroupTieredPackagePriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceMaxGroupTieredPackagePriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig]
type priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfig) implementsPriceMaxGroupTieredPackagePriceConversionRateConfig() {
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                    `json:"unit_amount,required"`
	JSON       priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMaxGroupTieredPackagePriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig]
type priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfig) implementsPriceMaxGroupTieredPackagePriceConversionRateConfig() {
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                           `json:"last_unit,nullable"`
	JSON     priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceMaxGroupTieredPackagePriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateType string

const (
	PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeUnit   PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateType = "unit"
	PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeTiered PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeUnit, PriceMaxGroupTieredPackagePriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceMaxGroupTieredPackagePriceModelType string

const (
	PriceMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage PriceMaxGroupTieredPackagePriceModelType = "max_group_tiered_package"
)

func (r PriceMaxGroupTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case PriceMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage:
		return true
	}
	return false
}

type PriceMaxGroupTieredPackagePricePriceType string

const (
	PriceMaxGroupTieredPackagePricePriceTypeUsagePrice PriceMaxGroupTieredPackagePricePriceType = "usage_price"
	PriceMaxGroupTieredPackagePricePriceTypeFixedPrice PriceMaxGroupTieredPackagePricePriceType = "fixed_price"
)

func (r PriceMaxGroupTieredPackagePricePriceType) IsKnown() bool {
	switch r {
	case PriceMaxGroupTieredPackagePricePriceTypeUsagePrice, PriceMaxGroupTieredPackagePricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceScalableMatrixWithUnitPricingPrice struct {
	ID                        string                                                      `json:"id,required"`
	BillableMetric            BillableMetricTiny                                          `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                                   `json:"billing_cycle_configuration,required"`
	Cadence                   PriceScalableMatrixWithUnitPricingPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                                     `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceScalableMatrixWithUnitPricingPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                                   `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                                  `json:"credit_allocation,required,nullable"`
	Currency                  string                                                      `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                       string                                           `json:"minimum_amount,required,nullable"`
	ModelType                           PriceScalableMatrixWithUnitPricingPriceModelType `json:"model_type,required"`
	Name                                string                                           `json:"name,required"`
	PlanPhaseOrder                      int64                                            `json:"plan_phase_order,required,nullable"`
	PriceType                           PriceScalableMatrixWithUnitPricingPricePriceType `json:"price_type,required"`
	ScalableMatrixWithUnitPricingConfig map[string]interface{}                           `json:"scalable_matrix_with_unit_pricing_config,required"`
	DimensionalPriceConfiguration       DimensionalPriceConfiguration                    `json:"dimensional_price_configuration,nullable"`
	JSON                                priceScalableMatrixWithUnitPricingPriceJSON      `json:"-"`
}

// priceScalableMatrixWithUnitPricingPriceJSON contains the JSON metadata for the
// struct [PriceScalableMatrixWithUnitPricingPrice]
type priceScalableMatrixWithUnitPricingPriceJSON struct {
	ID                                  apijson.Field
	BillableMetric                      apijson.Field
	BillingCycleConfiguration           apijson.Field
	Cadence                             apijson.Field
	ConversionRate                      apijson.Field
	ConversionRateConfig                apijson.Field
	CreatedAt                           apijson.Field
	CreditAllocation                    apijson.Field
	Currency                            apijson.Field
	Discount                            apijson.Field
	ExternalPriceID                     apijson.Field
	FixedPriceQuantity                  apijson.Field
	InvoicingCycleConfiguration         apijson.Field
	Item                                apijson.Field
	Maximum                             apijson.Field
	MaximumAmount                       apijson.Field
	Metadata                            apijson.Field
	Minimum                             apijson.Field
	MinimumAmount                       apijson.Field
	ModelType                           apijson.Field
	Name                                apijson.Field
	PlanPhaseOrder                      apijson.Field
	PriceType                           apijson.Field
	ScalableMatrixWithUnitPricingConfig apijson.Field
	DimensionalPriceConfiguration       apijson.Field
	raw                                 string
	ExtraFields                         map[string]apijson.Field
}

func (r *PriceScalableMatrixWithUnitPricingPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithUnitPricingPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceScalableMatrixWithUnitPricingPrice) implementsPrice() {}

type PriceScalableMatrixWithUnitPricingPriceCadence string

const (
	PriceScalableMatrixWithUnitPricingPriceCadenceOneTime    PriceScalableMatrixWithUnitPricingPriceCadence = "one_time"
	PriceScalableMatrixWithUnitPricingPriceCadenceMonthly    PriceScalableMatrixWithUnitPricingPriceCadence = "monthly"
	PriceScalableMatrixWithUnitPricingPriceCadenceQuarterly  PriceScalableMatrixWithUnitPricingPriceCadence = "quarterly"
	PriceScalableMatrixWithUnitPricingPriceCadenceSemiAnnual PriceScalableMatrixWithUnitPricingPriceCadence = "semi_annual"
	PriceScalableMatrixWithUnitPricingPriceCadenceAnnual     PriceScalableMatrixWithUnitPricingPriceCadence = "annual"
	PriceScalableMatrixWithUnitPricingPriceCadenceCustom     PriceScalableMatrixWithUnitPricingPriceCadence = "custom"
)

func (r PriceScalableMatrixWithUnitPricingPriceCadence) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithUnitPricingPriceCadenceOneTime, PriceScalableMatrixWithUnitPricingPriceCadenceMonthly, PriceScalableMatrixWithUnitPricingPriceCadenceQuarterly, PriceScalableMatrixWithUnitPricingPriceCadenceSemiAnnual, PriceScalableMatrixWithUnitPricingPriceCadenceAnnual, PriceScalableMatrixWithUnitPricingPriceCadenceCustom:
		return true
	}
	return false
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfig struct {
	ConversionRateType PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                                     `json:"unit_config"`
	JSON       priceScalableMatrixWithUnitPricingPriceConversionRateConfigJSON `json:"-"`
	union      PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnion
}

// priceScalableMatrixWithUnitPricingPriceConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfig]
type priceScalableMatrixWithUnitPricingPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceScalableMatrixWithUnitPricingPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceScalableMatrixWithUnitPricingPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceScalableMatrixWithUnitPricingPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig],
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceScalableMatrixWithUnitPricingPriceConversionRateConfig) AsUnion() PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig]
// or
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig].
type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnion interface {
	implementsPriceScalableMatrixWithUnitPricingPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig]
type priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfig) implementsPriceScalableMatrixWithUnitPricingPriceConversionRateConfig() {
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                            `json:"unit_amount,required"`
	JSON       priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithUnitPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig]
type priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfig) implementsPriceScalableMatrixWithUnitPricingPriceConversionRateConfig() {
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                                   `json:"last_unit,nullable"`
	JSON     priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithUnitPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType string

const (
	PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeUnit   PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType = "unit"
	PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeTiered PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeUnit, PriceScalableMatrixWithUnitPricingPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceScalableMatrixWithUnitPricingPriceModelType string

const (
	PriceScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing PriceScalableMatrixWithUnitPricingPriceModelType = "scalable_matrix_with_unit_pricing"
)

func (r PriceScalableMatrixWithUnitPricingPriceModelType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing:
		return true
	}
	return false
}

type PriceScalableMatrixWithUnitPricingPricePriceType string

const (
	PriceScalableMatrixWithUnitPricingPricePriceTypeUsagePrice PriceScalableMatrixWithUnitPricingPricePriceType = "usage_price"
	PriceScalableMatrixWithUnitPricingPricePriceTypeFixedPrice PriceScalableMatrixWithUnitPricingPricePriceType = "fixed_price"
)

func (r PriceScalableMatrixWithUnitPricingPricePriceType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithUnitPricingPricePriceTypeUsagePrice, PriceScalableMatrixWithUnitPricingPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceScalableMatrixWithTieredPricingPrice struct {
	ID                        string                                                        `json:"id,required"`
	BillableMetric            BillableMetricTiny                                            `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration BillingCycleConfiguration                                     `json:"billing_cycle_configuration,required"`
	Cadence                   PriceScalableMatrixWithTieredPricingPriceCadence              `json:"cadence,required"`
	ConversionRate            float64                                                       `json:"conversion_rate,required,nullable"`
	ConversionRateConfig      PriceScalableMatrixWithTieredPricingPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                 time.Time                                                     `json:"created_at,required" format:"date-time"`
	CreditAllocation          Allocation                                                    `json:"credit_allocation,required,nullable"`
	Currency                  string                                                        `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                         string                                             `json:"minimum_amount,required,nullable"`
	ModelType                             PriceScalableMatrixWithTieredPricingPriceModelType `json:"model_type,required"`
	Name                                  string                                             `json:"name,required"`
	PlanPhaseOrder                        int64                                              `json:"plan_phase_order,required,nullable"`
	PriceType                             PriceScalableMatrixWithTieredPricingPricePriceType `json:"price_type,required"`
	ScalableMatrixWithTieredPricingConfig map[string]interface{}                             `json:"scalable_matrix_with_tiered_pricing_config,required"`
	DimensionalPriceConfiguration         DimensionalPriceConfiguration                      `json:"dimensional_price_configuration,nullable"`
	JSON                                  priceScalableMatrixWithTieredPricingPriceJSON      `json:"-"`
}

// priceScalableMatrixWithTieredPricingPriceJSON contains the JSON metadata for the
// struct [PriceScalableMatrixWithTieredPricingPrice]
type priceScalableMatrixWithTieredPricingPriceJSON struct {
	ID                                    apijson.Field
	BillableMetric                        apijson.Field
	BillingCycleConfiguration             apijson.Field
	Cadence                               apijson.Field
	ConversionRate                        apijson.Field
	ConversionRateConfig                  apijson.Field
	CreatedAt                             apijson.Field
	CreditAllocation                      apijson.Field
	Currency                              apijson.Field
	Discount                              apijson.Field
	ExternalPriceID                       apijson.Field
	FixedPriceQuantity                    apijson.Field
	InvoicingCycleConfiguration           apijson.Field
	Item                                  apijson.Field
	Maximum                               apijson.Field
	MaximumAmount                         apijson.Field
	Metadata                              apijson.Field
	Minimum                               apijson.Field
	MinimumAmount                         apijson.Field
	ModelType                             apijson.Field
	Name                                  apijson.Field
	PlanPhaseOrder                        apijson.Field
	PriceType                             apijson.Field
	ScalableMatrixWithTieredPricingConfig apijson.Field
	DimensionalPriceConfiguration         apijson.Field
	raw                                   string
	ExtraFields                           map[string]apijson.Field
}

func (r *PriceScalableMatrixWithTieredPricingPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithTieredPricingPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceScalableMatrixWithTieredPricingPrice) implementsPrice() {}

type PriceScalableMatrixWithTieredPricingPriceCadence string

const (
	PriceScalableMatrixWithTieredPricingPriceCadenceOneTime    PriceScalableMatrixWithTieredPricingPriceCadence = "one_time"
	PriceScalableMatrixWithTieredPricingPriceCadenceMonthly    PriceScalableMatrixWithTieredPricingPriceCadence = "monthly"
	PriceScalableMatrixWithTieredPricingPriceCadenceQuarterly  PriceScalableMatrixWithTieredPricingPriceCadence = "quarterly"
	PriceScalableMatrixWithTieredPricingPriceCadenceSemiAnnual PriceScalableMatrixWithTieredPricingPriceCadence = "semi_annual"
	PriceScalableMatrixWithTieredPricingPriceCadenceAnnual     PriceScalableMatrixWithTieredPricingPriceCadence = "annual"
	PriceScalableMatrixWithTieredPricingPriceCadenceCustom     PriceScalableMatrixWithTieredPricingPriceCadence = "custom"
)

func (r PriceScalableMatrixWithTieredPricingPriceCadence) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithTieredPricingPriceCadenceOneTime, PriceScalableMatrixWithTieredPricingPriceCadenceMonthly, PriceScalableMatrixWithTieredPricingPriceCadenceQuarterly, PriceScalableMatrixWithTieredPricingPriceCadenceSemiAnnual, PriceScalableMatrixWithTieredPricingPriceCadenceAnnual, PriceScalableMatrixWithTieredPricingPriceCadenceCustom:
		return true
	}
	return false
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfig struct {
	ConversionRateType PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                                       `json:"unit_config"`
	JSON       priceScalableMatrixWithTieredPricingPriceConversionRateConfigJSON `json:"-"`
	union      PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnion
}

// priceScalableMatrixWithTieredPricingPriceConversionRateConfigJSON contains the
// JSON metadata for the struct
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfig]
type priceScalableMatrixWithTieredPricingPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceScalableMatrixWithTieredPricingPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceScalableMatrixWithTieredPricingPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceScalableMatrixWithTieredPricingPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig],
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceScalableMatrixWithTieredPricingPriceConversionRateConfig) AsUnion() PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig]
// or
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig].
type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnion interface {
	implementsPriceScalableMatrixWithTieredPricingPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig]
type priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfig) implementsPriceScalableMatrixWithTieredPricingPriceConversionRateConfig() {
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                              `json:"unit_amount,required"`
	JSON       priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithTieredPricingPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig]
type priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfig) implementsPriceScalableMatrixWithTieredPricingPriceConversionRateConfig() {
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                                     `json:"last_unit,nullable"`
	JSON     priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceScalableMatrixWithTieredPricingPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType string

const (
	PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeUnit   PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType = "unit"
	PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeTiered PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeUnit, PriceScalableMatrixWithTieredPricingPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceScalableMatrixWithTieredPricingPriceModelType string

const (
	PriceScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing PriceScalableMatrixWithTieredPricingPriceModelType = "scalable_matrix_with_tiered_pricing"
)

func (r PriceScalableMatrixWithTieredPricingPriceModelType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing:
		return true
	}
	return false
}

type PriceScalableMatrixWithTieredPricingPricePriceType string

const (
	PriceScalableMatrixWithTieredPricingPricePriceTypeUsagePrice PriceScalableMatrixWithTieredPricingPricePriceType = "usage_price"
	PriceScalableMatrixWithTieredPricingPricePriceTypeFixedPrice PriceScalableMatrixWithTieredPricingPricePriceType = "fixed_price"
)

func (r PriceScalableMatrixWithTieredPricingPricePriceType) IsKnown() bool {
	switch r {
	case PriceScalableMatrixWithTieredPricingPricePriceTypeUsagePrice, PriceScalableMatrixWithTieredPricingPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceCumulativeGroupedBulkPrice struct {
	ID                          string                                              `json:"id,required"`
	BillableMetric              BillableMetricTiny                                  `json:"billable_metric,required,nullable"`
	BillingCycleConfiguration   BillingCycleConfiguration                           `json:"billing_cycle_configuration,required"`
	Cadence                     PriceCumulativeGroupedBulkPriceCadence              `json:"cadence,required"`
	ConversionRate              float64                                             `json:"conversion_rate,required,nullable"`
	ConversionRateConfig        PriceCumulativeGroupedBulkPriceConversionRateConfig `json:"conversion_rate_config,required,nullable"`
	CreatedAt                   time.Time                                           `json:"created_at,required" format:"date-time"`
	CreditAllocation            Allocation                                          `json:"credit_allocation,required,nullable"`
	CumulativeGroupedBulkConfig map[string]interface{}                              `json:"cumulative_grouped_bulk_config,required"`
	Currency                    string                                              `json:"currency,required"`
	// Deprecated: deprecated
	Discount                    Discount                  `json:"discount,required,nullable"`
	ExternalPriceID             string                    `json:"external_price_id,required,nullable"`
	FixedPriceQuantity          float64                   `json:"fixed_price_quantity,required,nullable"`
	InvoicingCycleConfiguration BillingCycleConfiguration `json:"invoicing_cycle_configuration,required,nullable"`
	Item                        ItemSlim                  `json:"item,required"`
	// Deprecated: deprecated
	Maximum Maximum `json:"maximum,required,nullable"`
	// Deprecated: deprecated
	MaximumAmount string `json:"maximum_amount,required,nullable"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// Deprecated: deprecated
	Minimum Minimum `json:"minimum,required,nullable"`
	// Deprecated: deprecated
	MinimumAmount                 string                                   `json:"minimum_amount,required,nullable"`
	ModelType                     PriceCumulativeGroupedBulkPriceModelType `json:"model_type,required"`
	Name                          string                                   `json:"name,required"`
	PlanPhaseOrder                int64                                    `json:"plan_phase_order,required,nullable"`
	PriceType                     PriceCumulativeGroupedBulkPricePriceType `json:"price_type,required"`
	DimensionalPriceConfiguration DimensionalPriceConfiguration            `json:"dimensional_price_configuration,nullable"`
	JSON                          priceCumulativeGroupedBulkPriceJSON      `json:"-"`
}

// priceCumulativeGroupedBulkPriceJSON contains the JSON metadata for the struct
// [PriceCumulativeGroupedBulkPrice]
type priceCumulativeGroupedBulkPriceJSON struct {
	ID                            apijson.Field
	BillableMetric                apijson.Field
	BillingCycleConfiguration     apijson.Field
	Cadence                       apijson.Field
	ConversionRate                apijson.Field
	ConversionRateConfig          apijson.Field
	CreatedAt                     apijson.Field
	CreditAllocation              apijson.Field
	CumulativeGroupedBulkConfig   apijson.Field
	Currency                      apijson.Field
	Discount                      apijson.Field
	ExternalPriceID               apijson.Field
	FixedPriceQuantity            apijson.Field
	InvoicingCycleConfiguration   apijson.Field
	Item                          apijson.Field
	Maximum                       apijson.Field
	MaximumAmount                 apijson.Field
	Metadata                      apijson.Field
	Minimum                       apijson.Field
	MinimumAmount                 apijson.Field
	ModelType                     apijson.Field
	Name                          apijson.Field
	PlanPhaseOrder                apijson.Field
	PriceType                     apijson.Field
	DimensionalPriceConfiguration apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceCumulativeGroupedBulkPrice) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceCumulativeGroupedBulkPriceJSON) RawJSON() string {
	return r.raw
}

func (r PriceCumulativeGroupedBulkPrice) implementsPrice() {}

type PriceCumulativeGroupedBulkPriceCadence string

const (
	PriceCumulativeGroupedBulkPriceCadenceOneTime    PriceCumulativeGroupedBulkPriceCadence = "one_time"
	PriceCumulativeGroupedBulkPriceCadenceMonthly    PriceCumulativeGroupedBulkPriceCadence = "monthly"
	PriceCumulativeGroupedBulkPriceCadenceQuarterly  PriceCumulativeGroupedBulkPriceCadence = "quarterly"
	PriceCumulativeGroupedBulkPriceCadenceSemiAnnual PriceCumulativeGroupedBulkPriceCadence = "semi_annual"
	PriceCumulativeGroupedBulkPriceCadenceAnnual     PriceCumulativeGroupedBulkPriceCadence = "annual"
	PriceCumulativeGroupedBulkPriceCadenceCustom     PriceCumulativeGroupedBulkPriceCadence = "custom"
)

func (r PriceCumulativeGroupedBulkPriceCadence) IsKnown() bool {
	switch r {
	case PriceCumulativeGroupedBulkPriceCadenceOneTime, PriceCumulativeGroupedBulkPriceCadenceMonthly, PriceCumulativeGroupedBulkPriceCadenceQuarterly, PriceCumulativeGroupedBulkPriceCadenceSemiAnnual, PriceCumulativeGroupedBulkPriceCadenceAnnual, PriceCumulativeGroupedBulkPriceCadenceCustom:
		return true
	}
	return false
}

type PriceCumulativeGroupedBulkPriceConversionRateConfig struct {
	ConversionRateType PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	// This field can have the runtime type of
	// [PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig].
	TieredConfig interface{} `json:"tiered_config"`
	// This field can have the runtime type of
	// [PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig].
	UnitConfig interface{}                                             `json:"unit_config"`
	JSON       priceCumulativeGroupedBulkPriceConversionRateConfigJSON `json:"-"`
	union      PriceCumulativeGroupedBulkPriceConversionRateConfigUnion
}

// priceCumulativeGroupedBulkPriceConversionRateConfigJSON contains the JSON
// metadata for the struct [PriceCumulativeGroupedBulkPriceConversionRateConfig]
type priceCumulativeGroupedBulkPriceConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r priceCumulativeGroupedBulkPriceConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r *PriceCumulativeGroupedBulkPriceConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	*r = PriceCumulativeGroupedBulkPriceConversionRateConfig{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [PriceCumulativeGroupedBulkPriceConversionRateConfigUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig],
// [PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig].
func (r PriceCumulativeGroupedBulkPriceConversionRateConfig) AsUnion() PriceCumulativeGroupedBulkPriceConversionRateConfigUnion {
	return r.union
}

// Union satisfied by
// [PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig] or
// [PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig].
type PriceCumulativeGroupedBulkPriceConversionRateConfigUnion interface {
	implementsPriceCumulativeGroupedBulkPriceConversionRateConfig()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*PriceCumulativeGroupedBulkPriceConversionRateConfigUnion)(nil)).Elem(),
		"conversion_rate_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig{}),
			DiscriminatorValue: "unit",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig{}),
			DiscriminatorValue: "tiered",
		},
	)
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig struct {
	ConversionRateType PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	UnitConfig         PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig         `json:"unit_config,required"`
	JSON               priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigJSON               `json:"-"`
}

// priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig]
type priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	UnitConfig         apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfig) implementsPriceCumulativeGroupedBulkPriceConversionRateConfig() {
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType string

const (
	PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType = "unit"
)

func (r PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigConversionRateTypeUnit:
		return true
	}
	return false
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig struct {
	// Amount per unit of overage
	UnitAmount string                                                                                    `json:"unit_amount,required"`
	JSON       priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON `json:"-"`
}

// priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON
// contains the JSON metadata for the struct
// [PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig]
type priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceCumulativeGroupedBulkPriceConversionRateConfigUnitConversionRateConfigUnitConfigJSON) RawJSON() string {
	return r.raw
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig struct {
	ConversionRateType PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType `json:"conversion_rate_type,required"`
	TieredConfig       PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig       `json:"tiered_config,required"`
	JSON               priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigJSON               `json:"-"`
}

// priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigJSON
// contains the JSON metadata for the struct
// [PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig]
type priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigJSON struct {
	ConversionRateType apijson.Field
	TieredConfig       apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigJSON) RawJSON() string {
	return r.raw
}

func (r PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfig) implementsPriceCumulativeGroupedBulkPriceConversionRateConfig() {
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType string

const (
	PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType = "tiered"
)

func (r PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier `json:"tiers,required"`
	JSON  priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON   `json:"-"`
}

// priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON
// contains the JSON metadata for the struct
// [PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig]
type priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigJSON) RawJSON() string {
	return r.raw
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit of overage
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64                                                                                           `json:"last_unit,nullable"`
	JSON     priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON `json:"-"`
}

// priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON
// contains the JSON metadata for the struct
// [PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier]
type priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *PriceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceCumulativeGroupedBulkPriceConversionRateConfigTieredConversionRateConfigTieredConfigTierJSON) RawJSON() string {
	return r.raw
}

type PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateType string

const (
	PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeUnit   PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateType = "unit"
	PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeTiered PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateType = "tiered"
)

func (r PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateType) IsKnown() bool {
	switch r {
	case PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeUnit, PriceCumulativeGroupedBulkPriceConversionRateConfigConversionRateTypeTiered:
		return true
	}
	return false
}

type PriceCumulativeGroupedBulkPriceModelType string

const (
	PriceCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk PriceCumulativeGroupedBulkPriceModelType = "cumulative_grouped_bulk"
)

func (r PriceCumulativeGroupedBulkPriceModelType) IsKnown() bool {
	switch r {
	case PriceCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk:
		return true
	}
	return false
}

type PriceCumulativeGroupedBulkPricePriceType string

const (
	PriceCumulativeGroupedBulkPricePriceTypeUsagePrice PriceCumulativeGroupedBulkPricePriceType = "usage_price"
	PriceCumulativeGroupedBulkPricePriceTypeFixedPrice PriceCumulativeGroupedBulkPricePriceType = "fixed_price"
)

func (r PriceCumulativeGroupedBulkPricePriceType) IsKnown() bool {
	switch r {
	case PriceCumulativeGroupedBulkPricePriceTypeUsagePrice, PriceCumulativeGroupedBulkPricePriceTypeFixedPrice:
		return true
	}
	return false
}

type PriceCadence string

const (
	PriceCadenceOneTime    PriceCadence = "one_time"
	PriceCadenceMonthly    PriceCadence = "monthly"
	PriceCadenceQuarterly  PriceCadence = "quarterly"
	PriceCadenceSemiAnnual PriceCadence = "semi_annual"
	PriceCadenceAnnual     PriceCadence = "annual"
	PriceCadenceCustom     PriceCadence = "custom"
)

func (r PriceCadence) IsKnown() bool {
	switch r {
	case PriceCadenceOneTime, PriceCadenceMonthly, PriceCadenceQuarterly, PriceCadenceSemiAnnual, PriceCadenceAnnual, PriceCadenceCustom:
		return true
	}
	return false
}

type PriceModelType string

const (
	PriceModelTypeUnit                            PriceModelType = "unit"
	PriceModelTypePackage                         PriceModelType = "package"
	PriceModelTypeMatrix                          PriceModelType = "matrix"
	PriceModelTypeTiered                          PriceModelType = "tiered"
	PriceModelTypeTieredBPS                       PriceModelType = "tiered_bps"
	PriceModelTypeBPS                             PriceModelType = "bps"
	PriceModelTypeBulkBPS                         PriceModelType = "bulk_bps"
	PriceModelTypeBulk                            PriceModelType = "bulk"
	PriceModelTypeThresholdTotalAmount            PriceModelType = "threshold_total_amount"
	PriceModelTypeTieredPackage                   PriceModelType = "tiered_package"
	PriceModelTypeGroupedTiered                   PriceModelType = "grouped_tiered"
	PriceModelTypeTieredWithMinimum               PriceModelType = "tiered_with_minimum"
	PriceModelTypeTieredPackageWithMinimum        PriceModelType = "tiered_package_with_minimum"
	PriceModelTypePackageWithAllocation           PriceModelType = "package_with_allocation"
	PriceModelTypeUnitWithPercent                 PriceModelType = "unit_with_percent"
	PriceModelTypeMatrixWithAllocation            PriceModelType = "matrix_with_allocation"
	PriceModelTypeTieredWithProration             PriceModelType = "tiered_with_proration"
	PriceModelTypeUnitWithProration               PriceModelType = "unit_with_proration"
	PriceModelTypeGroupedAllocation               PriceModelType = "grouped_allocation"
	PriceModelTypeGroupedWithProratedMinimum      PriceModelType = "grouped_with_prorated_minimum"
	PriceModelTypeGroupedWithMeteredMinimum       PriceModelType = "grouped_with_metered_minimum"
	PriceModelTypeMatrixWithDisplayName           PriceModelType = "matrix_with_display_name"
	PriceModelTypeBulkWithProration               PriceModelType = "bulk_with_proration"
	PriceModelTypeGroupedTieredPackage            PriceModelType = "grouped_tiered_package"
	PriceModelTypeMaxGroupTieredPackage           PriceModelType = "max_group_tiered_package"
	PriceModelTypeScalableMatrixWithUnitPricing   PriceModelType = "scalable_matrix_with_unit_pricing"
	PriceModelTypeScalableMatrixWithTieredPricing PriceModelType = "scalable_matrix_with_tiered_pricing"
	PriceModelTypeCumulativeGroupedBulk           PriceModelType = "cumulative_grouped_bulk"
)

func (r PriceModelType) IsKnown() bool {
	switch r {
	case PriceModelTypeUnit, PriceModelTypePackage, PriceModelTypeMatrix, PriceModelTypeTiered, PriceModelTypeTieredBPS, PriceModelTypeBPS, PriceModelTypeBulkBPS, PriceModelTypeBulk, PriceModelTypeThresholdTotalAmount, PriceModelTypeTieredPackage, PriceModelTypeGroupedTiered, PriceModelTypeTieredWithMinimum, PriceModelTypeTieredPackageWithMinimum, PriceModelTypePackageWithAllocation, PriceModelTypeUnitWithPercent, PriceModelTypeMatrixWithAllocation, PriceModelTypeTieredWithProration, PriceModelTypeUnitWithProration, PriceModelTypeGroupedAllocation, PriceModelTypeGroupedWithProratedMinimum, PriceModelTypeGroupedWithMeteredMinimum, PriceModelTypeMatrixWithDisplayName, PriceModelTypeBulkWithProration, PriceModelTypeGroupedTieredPackage, PriceModelTypeMaxGroupTieredPackage, PriceModelTypeScalableMatrixWithUnitPricing, PriceModelTypeScalableMatrixWithTieredPricing, PriceModelTypeCumulativeGroupedBulk:
		return true
	}
	return false
}

type PricePriceType string

const (
	PricePriceTypeUsagePrice PricePriceType = "usage_price"
	PricePriceTypeFixedPrice PricePriceType = "fixed_price"
)

func (r PricePriceType) IsKnown() bool {
	switch r {
	case PricePriceTypeUsagePrice, PricePriceTypeFixedPrice:
		return true
	}
	return false
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type PriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []FixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string          `json:"usage_customer_ids,required,nullable"`
	JSON             priceIntervalJSON `json:"-"`
}

// priceIntervalJSON contains the JSON metadata for the struct [PriceInterval]
type priceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *PriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r priceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubLineItemGrouping struct {
	Key string `json:"key,required"`
	// No value indicates the default group
	Value string                  `json:"value,required,nullable"`
	JSON  subLineItemGroupingJSON `json:"-"`
}

// subLineItemGroupingJSON contains the JSON metadata for the struct
// [SubLineItemGrouping]
type subLineItemGroupingJSON struct {
	Key         apijson.Field
	Value       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubLineItemGrouping) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subLineItemGroupingJSON) RawJSON() string {
	return r.raw
}

type SubLineItemMatrixConfig struct {
	// The ordered dimension values for this line item.
	DimensionValues []string                    `json:"dimension_values,required"`
	JSON            subLineItemMatrixConfigJSON `json:"-"`
}

// subLineItemMatrixConfigJSON contains the JSON metadata for the struct
// [SubLineItemMatrixConfig]
type subLineItemMatrixConfigJSON struct {
	DimensionValues apijson.Field
	raw             string
	ExtraFields     map[string]apijson.Field
}

func (r *SubLineItemMatrixConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subLineItemMatrixConfigJSON) RawJSON() string {
	return r.raw
}

type SubscriptionChangeMinified struct {
	ID   string                         `json:"id,required"`
	JSON subscriptionChangeMinifiedJSON `json:"-"`
}

// subscriptionChangeMinifiedJSON contains the JSON metadata for the struct
// [SubscriptionChangeMinified]
type subscriptionChangeMinifiedJSON struct {
	ID          apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionChangeMinified) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionChangeMinifiedJSON) RawJSON() string {
	return r.raw
}

type SubscriptionMinified struct {
	ID   string                   `json:"id,required"`
	JSON subscriptionMinifiedJSON `json:"-"`
}

// subscriptionMinifiedJSON contains the JSON metadata for the struct
// [SubscriptionMinified]
type subscriptionMinifiedJSON struct {
	ID          apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionMinified) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionMinifiedJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTrialInfo struct {
	EndDate time.Time                 `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionTrialInfoJSON `json:"-"`
}

// subscriptionTrialInfoJSON contains the JSON metadata for the struct
// [SubscriptionTrialInfo]
type subscriptionTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTrialInfoJSON) RawJSON() string {
	return r.raw
}

type TaxAmount struct {
	// The amount of additional tax incurred by this tax rate.
	Amount string `json:"amount,required"`
	// The human-readable description of the applied tax rate.
	TaxRateDescription string `json:"tax_rate_description,required"`
	// The tax rate percentage, out of 100.
	TaxRatePercentage string        `json:"tax_rate_percentage,required,nullable"`
	JSON              taxAmountJSON `json:"-"`
}

// taxAmountJSON contains the JSON metadata for the struct [TaxAmount]
type taxAmountJSON struct {
	Amount             apijson.Field
	TaxRateDescription apijson.Field
	TaxRatePercentage  apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *TaxAmount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r taxAmountJSON) RawJSON() string {
	return r.raw
}

type Tier struct {
	// Exclusive tier starting value
	FirstUnit float64 `json:"first_unit,required"`
	// Amount per unit
	UnitAmount string `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit float64  `json:"last_unit,nullable"`
	JSON     tierJSON `json:"-"`
}

// tierJSON contains the JSON metadata for the struct [Tier]
type tierJSON struct {
	FirstUnit   apijson.Field
	UnitAmount  apijson.Field
	LastUnit    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *Tier) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r tierJSON) RawJSON() string {
	return r.raw
}

type TierParam struct {
	// Exclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Inclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r TierParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type TierConfig struct {
	FirstUnit  float64        `json:"first_unit,required"`
	LastUnit   float64        `json:"last_unit,required,nullable"`
	UnitAmount string         `json:"unit_amount,required"`
	JSON       tierConfigJSON `json:"-"`
}

// tierConfigJSON contains the JSON metadata for the struct [TierConfig]
type tierConfigJSON struct {
	FirstUnit   apijson.Field
	LastUnit    apijson.Field
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *TierConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r tierConfigJSON) RawJSON() string {
	return r.raw
}

type TierSubLineItem struct {
	// The total amount for this sub line item.
	Amount     string              `json:"amount,required"`
	Grouping   SubLineItemGrouping `json:"grouping,required,nullable"`
	Name       string              `json:"name,required"`
	Quantity   float64             `json:"quantity,required"`
	TierConfig TierConfig          `json:"tier_config,required"`
	Type       TierSubLineItemType `json:"type,required"`
	JSON       tierSubLineItemJSON `json:"-"`
}

// tierSubLineItemJSON contains the JSON metadata for the struct [TierSubLineItem]
type tierSubLineItemJSON struct {
	Amount      apijson.Field
	Grouping    apijson.Field
	Name        apijson.Field
	Quantity    apijson.Field
	TierConfig  apijson.Field
	Type        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *TierSubLineItem) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r tierSubLineItemJSON) RawJSON() string {
	return r.raw
}

func (r TierSubLineItem) ImplementsInvoiceLineItemsSubLineItem() {}

func (r TierSubLineItem) ImplementsInvoiceLineItemNewResponseSubLineItem() {}

func (r TierSubLineItem) ImplementsInvoiceFetchUpcomingResponseLineItemsSubLineItem() {}

type TierSubLineItemType string

const (
	TierSubLineItemTypeTier TierSubLineItemType = "tier"
)

func (r TierSubLineItemType) IsKnown() bool {
	switch r {
	case TierSubLineItemTypeTier:
		return true
	}
	return false
}

type TieredBPSConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers []BPSTier           `json:"tiers,required"`
	JSON  tieredBPSConfigJSON `json:"-"`
}

// tieredBPSConfigJSON contains the JSON metadata for the struct [TieredBPSConfig]
type tieredBPSConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *TieredBPSConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r tieredBPSConfigJSON) RawJSON() string {
	return r.raw
}

type TieredBPSConfigParam struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]BPSTierParam] `json:"tiers,required"`
}

func (r TieredBPSConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type TieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers []Tier           `json:"tiers,required"`
	JSON  tieredConfigJSON `json:"-"`
}

// tieredConfigJSON contains the JSON metadata for the struct [TieredConfig]
type tieredConfigJSON struct {
	Tiers       apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *TieredConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r tieredConfigJSON) RawJSON() string {
	return r.raw
}

type TieredConfigParam struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]TierParam] `json:"tiers,required"`
}

func (r TieredConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type TransformPriceFilter struct {
	// The property of the price to filter on.
	Field TransformPriceFilterField `json:"field,required"`
	// Should prices that match the filter be included or excluded.
	Operator TransformPriceFilterOperator `json:"operator,required"`
	// The IDs or values that match this filter.
	Values []string                 `json:"values,required"`
	JSON   transformPriceFilterJSON `json:"-"`
}

// transformPriceFilterJSON contains the JSON metadata for the struct
// [TransformPriceFilter]
type transformPriceFilterJSON struct {
	Field       apijson.Field
	Operator    apijson.Field
	Values      apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *TransformPriceFilter) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r transformPriceFilterJSON) RawJSON() string {
	return r.raw
}

// The property of the price to filter on.
type TransformPriceFilterField string

const (
	TransformPriceFilterFieldPriceID       TransformPriceFilterField = "price_id"
	TransformPriceFilterFieldItemID        TransformPriceFilterField = "item_id"
	TransformPriceFilterFieldPriceType     TransformPriceFilterField = "price_type"
	TransformPriceFilterFieldCurrency      TransformPriceFilterField = "currency"
	TransformPriceFilterFieldPricingUnitID TransformPriceFilterField = "pricing_unit_id"
)

func (r TransformPriceFilterField) IsKnown() bool {
	switch r {
	case TransformPriceFilterFieldPriceID, TransformPriceFilterFieldItemID, TransformPriceFilterFieldPriceType, TransformPriceFilterFieldCurrency, TransformPriceFilterFieldPricingUnitID:
		return true
	}
	return false
}

// Should prices that match the filter be included or excluded.
type TransformPriceFilterOperator string

const (
	TransformPriceFilterOperatorIncludes TransformPriceFilterOperator = "includes"
	TransformPriceFilterOperatorExcludes TransformPriceFilterOperator = "excludes"
)

func (r TransformPriceFilterOperator) IsKnown() bool {
	switch r {
	case TransformPriceFilterOperatorIncludes, TransformPriceFilterOperatorExcludes:
		return true
	}
	return false
}

type TransformPriceFilterParam struct {
	// The property of the price to filter on.
	Field param.Field[TransformPriceFilterField] `json:"field,required"`
	// Should prices that match the filter be included or excluded.
	Operator param.Field[TransformPriceFilterOperator] `json:"operator,required"`
	// The IDs or values that match this filter.
	Values param.Field[[]string] `json:"values,required"`
}

func (r TransformPriceFilterParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type TrialDiscount struct {
	DiscountType TrialDiscountDiscountType `json:"discount_type,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,nullable"`
	// The filters that determine which prices to apply this discount to.
	Filters []TransformPriceFilter `json:"filters,nullable"`
	Reason  string                 `json:"reason,nullable"`
	// Only available if discount_type is `trial`
	TrialAmountDiscount string `json:"trial_amount_discount,nullable"`
	// Only available if discount_type is `trial`
	TrialPercentageDiscount float64           `json:"trial_percentage_discount,nullable"`
	JSON                    trialDiscountJSON `json:"-"`
}

// trialDiscountJSON contains the JSON metadata for the struct [TrialDiscount]
type trialDiscountJSON struct {
	DiscountType            apijson.Field
	AppliesToPriceIDs       apijson.Field
	Filters                 apijson.Field
	Reason                  apijson.Field
	TrialAmountDiscount     apijson.Field
	TrialPercentageDiscount apijson.Field
	raw                     string
	ExtraFields             map[string]apijson.Field
}

func (r *TrialDiscount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r trialDiscountJSON) RawJSON() string {
	return r.raw
}

func (r TrialDiscount) ImplementsDiscount() {}

func (r TrialDiscount) ImplementsInvoiceLevelDiscount() {}

type TrialDiscountDiscountType string

const (
	TrialDiscountDiscountTypeTrial TrialDiscountDiscountType = "trial"
)

func (r TrialDiscountDiscountType) IsKnown() bool {
	switch r {
	case TrialDiscountDiscountTypeTrial:
		return true
	}
	return false
}

type TrialDiscountParam struct {
	DiscountType param.Field[TrialDiscountDiscountType] `json:"discount_type,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// The filters that determine which prices to apply this discount to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	Reason  param.Field[string]                      `json:"reason"`
	// Only available if discount_type is `trial`
	TrialAmountDiscount param.Field[string] `json:"trial_amount_discount"`
	// Only available if discount_type is `trial`
	TrialPercentageDiscount param.Field[float64] `json:"trial_percentage_discount"`
}

func (r TrialDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r TrialDiscountParam) ImplementsDiscountUnionParam() {}

type UnitConfig struct {
	// Rate per unit of usage
	UnitAmount string         `json:"unit_amount,required"`
	JSON       unitConfigJSON `json:"-"`
}

// unitConfigJSON contains the JSON metadata for the struct [UnitConfig]
type unitConfigJSON struct {
	UnitAmount  apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *UnitConfig) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r unitConfigJSON) RawJSON() string {
	return r.raw
}

type UnitConfigParam struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r UnitConfigParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type UsageDiscount struct {
	DiscountType UsageDiscountDiscountType `json:"discount_type,required"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64 `json:"usage_discount,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,nullable"`
	// The filters that determine which prices to apply this discount to.
	Filters []TransformPriceFilter `json:"filters,nullable"`
	Reason  string                 `json:"reason,nullable"`
	JSON    usageDiscountJSON      `json:"-"`
}

// usageDiscountJSON contains the JSON metadata for the struct [UsageDiscount]
type usageDiscountJSON struct {
	DiscountType      apijson.Field
	UsageDiscount     apijson.Field
	AppliesToPriceIDs apijson.Field
	Filters           apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *UsageDiscount) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r usageDiscountJSON) RawJSON() string {
	return r.raw
}

func (r UsageDiscount) ImplementsDiscount() {}

type UsageDiscountDiscountType string

const (
	UsageDiscountDiscountTypeUsage UsageDiscountDiscountType = "usage"
)

func (r UsageDiscountDiscountType) IsKnown() bool {
	switch r {
	case UsageDiscountDiscountTypeUsage:
		return true
	}
	return false
}

type UsageDiscountParam struct {
	DiscountType param.Field[UsageDiscountDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount param.Field[float64] `json:"usage_discount,required"`
	// List of price_ids that this discount applies to. For plan/plan phase discounts,
	// this can be a subset of prices.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids"`
	// The filters that determine which prices to apply this discount to.
	Filters param.Field[[]TransformPriceFilterParam] `json:"filters"`
	Reason  param.Field[string]                      `json:"reason"`
}

func (r UsageDiscountParam) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r UsageDiscountParam) ImplementsDiscountUnionParam() {}

type UsageDiscountInterval struct {
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              UsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The filters that determine which prices this discount interval applies to.
	Filters []TransformPriceFilter `json:"filters,required"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                   `json:"usage_discount,required"`
	JSON          usageDiscountIntervalJSON `json:"-"`
}

// usageDiscountIntervalJSON contains the JSON metadata for the struct
// [UsageDiscountInterval]
type usageDiscountIntervalJSON struct {
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	Filters                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *UsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r usageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r UsageDiscountInterval) ImplementsSubscriptionDiscountInterval() {}

func (r UsageDiscountInterval) ImplementsMutatedSubscriptionDiscountInterval() {}

type UsageDiscountIntervalDiscountType string

const (
	UsageDiscountIntervalDiscountTypeUsage UsageDiscountIntervalDiscountType = "usage"
)

func (r UsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case UsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}
