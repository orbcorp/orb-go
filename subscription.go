// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

package orb

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"reflect"
	"time"

	"github.com/orbcorp/orb-go/internal/apijson"
	"github.com/orbcorp/orb-go/internal/apiquery"
	"github.com/orbcorp/orb-go/internal/param"
	"github.com/orbcorp/orb-go/internal/requestconfig"
	"github.com/orbcorp/orb-go/option"
	"github.com/orbcorp/orb-go/packages/pagination"
	"github.com/orbcorp/orb-go/shared"
	"github.com/tidwall/gjson"
)

// SubscriptionService contains methods and other services that help with
// interacting with the orb API.
//
// Note, unlike clients, this service does not read variables from the environment
// automatically. You should not instantiate this service directly, and instead use
// the [NewSubscriptionService] method instead.
type SubscriptionService struct {
	Options []option.RequestOption
}

// NewSubscriptionService generates a new service that applies the given options to
// each request. These options are applied after the parent client's options (if
// there is one), and before any request-specific options.
func NewSubscriptionService(opts ...option.RequestOption) (r *SubscriptionService) {
	r = &SubscriptionService{}
	r.Options = opts
	return
}

// A subscription represents the purchase of a plan by a customer. The customer is
// identified by either the `customer_id` or the `external_customer_id`, and
// exactly one of these fields must be provided.
//
// By default, subscriptions begin on the day that they're created and renew
// automatically for each billing cycle at the cadence that's configured in the
// plan definition.
//
// The default configuration for subscriptions in Orb is **In-advance billing** and
// **Beginning of month alignment** (see
// [Subscription](/core-concepts##subscription) for more details).
//
// In order to change the alignment behavior, Orb also supports billing
// subscriptions on the day of the month they are created. If
// `align_billing_with_subscription_start_date = true` is specified, subscriptions
// have billing cycles that are aligned with their `start_date`. For example, a
// subscription that begins on January 15th will have a billing cycle from January
// 15th to February 15th. Every subsequent billing cycle will continue to start and
// invoice on the 15th.
//
// If the "day" value is greater than the number of days in the month, the next
// billing cycle will start at the end of the month. For example, if the start_date
// is January 31st, the next billing cycle will start on February 28th.
//
// If a customer was created with a currency, Orb only allows subscribing the
// customer to a plan with a matching `invoicing_currency`. If the customer does
// not have a currency set, on subscription creation, we set the customer's
// currency to be the `invoicing_currency` of the plan.
//
// ## Customize your customer's subscriptions
//
// Prices and adjustments in a plan can be added, removed, or replaced for the
// subscription being created. This is useful when a customer has prices that
// differ from the default prices for a specific plan.
//
// <Note>
// This feature is only available for accounts that have migrated to Subscription Overrides Version 2. You can find your
// Subscription Overrides Version at the bottom of your [Plans page](https://app.withorb.com/plans)
// </Note>
//
// ### Adding Prices
//
// To add prices, provide a list of objects with the key `add_prices`. An object in
// the list must specify an existing add-on price with a `price_id` or
// `external_price_id` field, or create a new add-on price by including an object
// with the key `price`, identical to what would be used in the request body for
// the [create price endpoint](/api-reference/price/create-price). See the
// [Price resource](/product-catalog/price-configuration) for the specification of
// different price model configurations possible in this object.
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the price should be added to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. This is equivalent to creating a price interval with the
// [add/edit price intervals endpoint](/api-reference/price-interval/add-or-edit-price-intervals).
// If unspecified, the start or end date of the phase or subscription will be used.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference this price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Removing Prices
//
// To remove prices, provide a list of objects with the key `remove_prices`. An
// object in the list must specify a plan price with either a `price_id` or
// `external_price_id` field.
//
// ### Replacing Prices
//
// To replace prices, provide a list of objects with the key `replace_prices`. An
// object in the list must specify a plan price to replace with the
// `replaces_price_id` key, and it must specify a price to replace it with by
// either referencing an existing add-on price with a `price_id` or
// `external_price_id` field, or by creating a new add-on price by including an
// object with the key `price`, identical to what would be used in the request body
// for the [create price endpoint](/api-reference/price/create-price). See the
// [Price resource](/product-catalog/price-configuration) for the specification of
// different price model configurations possible in this object.
//
// For fixed fees, an object in the list can supply a `fixed_price_quantity`
// instead of a `price`, `price_id`, or `external_price_id` field. This will update
// only the quantity for the price, similar to the
// [Update price quantity](/api-reference/subscription/update-price-quantity)
// endpoint.
//
// The replacement price will have the same phase, if applicable, and the same
// start and end dates as the price it replaces.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference the replacement price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Adding adjustments
//
// To add adjustments, provide a list of objects with the key `add_adjustments`. An
// object in the list must include an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](/api-reference/price-interval/add-or-edit-price-intervals).
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the adjustment should be added
// to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. If unspecified, the start or end date of the phase or subscription
// will be used.
//
// ### Removing adjustments
//
// To remove adjustments, provide a list of objects with the key
// `remove_adjustments`. An object in the list must include a key, `adjustment_id`,
// with the ID of the adjustment to be removed.
//
// ### Replacing adjustments
//
// To replace adjustments, provide a list of objects with the key
// `replace_adjustments`. An object in the list must specify a plan adjustment to
// replace with the `replaces_adjustment_id` key, and it must specify an adjustment
// to replace it with by including an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](/api-reference/price-interval/add-or-edit-price-intervals).
//
// The replacement adjustment will have the same phase, if applicable, and the same
// start and end dates as the adjustment it replaces.
//
// ## Price overrides (DEPRECATED)
//
// <Note>
// Price overrides are being phased out in favor adding/removing/replacing prices. (See
// [Customize your customer's subscriptions](/api-reference/subscription/create-subscription))
// </Note>
//
// Price overrides are used to update some or all prices in a plan for the specific
// subscription being created. This is useful when a new customer has negotiated a
// rate that is unique to the customer.
//
// To override prices, provide a list of objects with the key `price_overrides`.
// The price object in the list of overrides is expected to contain the existing
// price id, the `model_type` and configuration. (See the
// [Price resource](/product-catalog/price-configuration) for the specification of
// different price model configurations.) The numerical values can be updated, but
// the billable metric, cadence, type, and name of a price can not be overridden.
//
// ### Maximums and Minimums
//
// Minimums and maximums, much like price overrides, can be useful when a new
// customer has negotiated a new or different minimum or maximum spend cap than the
// default for a given price. If one exists for a price and null is provided for
// the minimum/maximum override on creation, then there will be no minimum/maximum
// on the new subscription. If no value is provided, then the default price maximum
// or minimum is used.
//
// To add a minimum for a specific price, add `minimum_amount` to the specific
// price in the `price_overrides` object.
//
// To add a maximum for a specific price, add `maximum_amount` to the specific
// price in the `price_overrides` object.
//
// ### Minimum override example
//
// Price minimum override example:
//
// ```json
//
//	{
//	  ...
//	  "id": "price_id",
//	  "model_type": "unit",
//	  "unit_config": {
//	    "unit_amount": "0.50"
//	  },
//	  "minimum_amount": "100.00"
//	  ...
//	}
//
// ```
//
// # Removing an existing minimum example
//
// ```json
//
//	{
//	  ...
//	  "id": "price_id",
//	  "model_type": "unit",
//	  "unit_config": {
//	    "unit_amount": "0.50"
//	  },
//	  "minimum_amount": null
//	  ...
//	}
//
// ```
//
// ### Discounts
//
// Discounts, like price overrides, can be useful when a new customer has
// negotiated a new or different discount than the default for a price. If a
// discount exists for a price and a null discount is provided on creation, then
// there will be no discount on the new subscription.
//
// To add a discount for a specific price, add `discount` to the price in the
// `price_overrides` object. Discount should be a dictionary of the format:
//
// ```ts
//
//	{
//	  "discount_type": "amount" | "percentage" | "usage",
//	  "amount_discount": string,
//	  "percentage_discount": string,
//	  "usage_discount": string
//	}
//
// ```
//
// where either `amount_discount`, `percentage_discount`, or `usage_discount` is
// provided.
//
// # Price discount example
//
// ```json
//
//	{
//	  ...
//	  "id": "price_id",
//	  "model_type": "unit",
//	  "unit_config": {
//	    "unit_amount": "0.50"
//	  },
//	  "discount": {"discount_type": "amount", "amount_discount": "175"},
//	}
//
// ```
//
// # Removing an existing discount example
//
// ```json
//
//	{
//	  "customer_id": "customer_id",
//	  "plan_id": "plan_id",
//	  "discount": null,
//	  "price_overrides": [ ... ]
//	  ...
//	}
//
// ```
//
// ## Threshold Billing
//
// Orb supports invoicing for a subscription when a preconfigured usage threshold
// is hit. To enable threshold billing, pass in an `invoicing_threshold`, which is
// specified in the subscription's invoicing currency, when creating a
// subscription. E.g. pass in `10.00` to issue an invoice when usage amounts hit
// $10.00 for a subscription that invoices in USD.
func (r *SubscriptionService) New(ctx context.Context, body SubscriptionNewParams, opts ...option.RequestOption) (res *SubscriptionNewResponse, err error) {
	opts = append(r.Options[:], opts...)
	path := "subscriptions"
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to update the `metadata`, `net terms`,
// `auto_collection`, `invoicing_threshold`, and `default_invoice_memo` properties
// on a subscription.
func (r *SubscriptionService) Update(ctx context.Context, subscriptionID string, body SubscriptionUpdateParams, opts ...option.RequestOption) (res *Subscription, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPut, path, body, &res, opts...)
	return
}

// This endpoint returns a list of all subscriptions for an account as a
// [paginated](/api-reference/pagination) list, ordered starting from the most
// recently created subscription. For a full discussion of the subscription
// resource, see [Subscription](/core-concepts##subscription).
//
// Subscriptions can be filtered for a specific customer by using either the
// customer_id or external_customer_id query parameters. To filter subscriptions
// for multiple customers, use the customer_id[] or external_customer_id[] query
// parameters.
func (r *SubscriptionService) List(ctx context.Context, query SubscriptionListParams, opts ...option.RequestOption) (res *pagination.Page[Subscription], err error) {
	var raw *http.Response
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithResponseInto(&raw)}, opts...)
	path := "subscriptions"
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodGet, path, query, &res, opts...)
	if err != nil {
		return nil, err
	}
	err = cfg.Execute()
	if err != nil {
		return nil, err
	}
	res.SetPageConfig(cfg, raw)
	return res, nil
}

// This endpoint returns a list of all subscriptions for an account as a
// [paginated](/api-reference/pagination) list, ordered starting from the most
// recently created subscription. For a full discussion of the subscription
// resource, see [Subscription](/core-concepts##subscription).
//
// Subscriptions can be filtered for a specific customer by using either the
// customer_id or external_customer_id query parameters. To filter subscriptions
// for multiple customers, use the customer_id[] or external_customer_id[] query
// parameters.
func (r *SubscriptionService) ListAutoPaging(ctx context.Context, query SubscriptionListParams, opts ...option.RequestOption) *pagination.PageAutoPager[Subscription] {
	return pagination.NewPageAutoPager(r.List(ctx, query, opts...))
}

// This endpoint can be used to cancel an existing subscription. It returns the
// serialized subscription object with an `end_date` parameter that signifies when
// the subscription will transition to an ended state.
//
// The body parameter `cancel_option` determines the cancellation behavior. Orb
// supports three cancellation options:
//
//   - `end_of_subscription_term`: stops the subscription from auto-renewing.
//     Subscriptions that have been cancelled with this option can still incur
//     charges for the remainder of their term:
//
//   - Issuing this cancellation request for a monthly subscription will keep the
//     subscription active until the start of the subsequent month, and potentially
//     issue an invoice for any usage charges incurred in the intervening period.
//
//   - Issuing this cancellation request for a quarterly subscription will keep the
//     subscription active until the end of the quarter and potentially issue an
//     invoice for any usage charges incurred in the intervening period.
//
//   - Issuing this cancellation request for a yearly subscription will keep the
//     subscription active for the full year. For example, a yearly subscription
//     starting on 2021-11-01 and cancelled on 2021-12-08 will remain active until
//     2022-11-01 and potentially issue charges in the intervening months for any
//     recurring monthly usage charges in its plan.
//
//   - **Note**: If a subscription's plan contains prices with difference cadences,
//     the end of term date will be determined by the largest cadence value. For
//     example, cancelling end of term for a subscription with a quarterly fixed
//     fee with a monthly usage fee will result in the subscription ending at the
//     end of the quarter.
//
//   - `immediate`: ends the subscription immediately, setting the `end_date` to the
//     current time:
//
//   - Subscriptions that have been cancelled with this option will be invoiced
//     immediately. This invoice will include any usage fees incurred in the
//     billing period up to the cancellation, along with any prorated recurring
//     fees for the billing period, if applicable.
//
//   - **Note**: If the subscription has a recurring fee that was paid in-advance,
//     the prorated amount for the remaining time period will be added to the
//     [customer's balance](list-balance-transactions) upon immediate cancellation.
//     However, if the customer is ineligible to use the customer balance, the
//     subscription cannot be cancelled immediately.
//
//   - `requested_date`: ends the subscription on a specified date, which requires a
//     `cancellation_date` to be passed in. If no timezone is provided, the
//     customer's timezone is used. For example, a subscription starting on January
//     1st with a monthly price can be set to be cancelled on the first of any month
//     after January 1st (e.g. March 1st, April 1st, May 1st). A subscription with
//     multiple prices with different cadences defines the "term" to be the highest
//     cadence of the prices.
//
// Upcoming subscriptions are only eligible for immediate cancellation, which will
// set the `end_date` equal to the `start_date` upon cancellation.
//
// ## Backdated cancellations
//
// Orb allows you to cancel a subscription in the past as long as there are no paid
// invoices between the `requested_date` and the current time. If the cancellation
// is after the latest issued invoice, Orb will generate a balance refund for the
// current period. If the cancellation is before the most recently issued invoice,
// Orb will void the intervening invoice and generate a new one based on the new
// dates for the subscription. See the section on
// [cancellation behaviors](/product-catalog/creating-subscriptions#cancellation-behaviors).
func (r *SubscriptionService) Cancel(ctx context.Context, subscriptionID string, body SubscriptionCancelParams, opts ...option.RequestOption) (res *SubscriptionCancelResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/cancel", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint is used to fetch a [Subscription](/core-concepts##subscription)
// given an identifier.
func (r *SubscriptionService) Fetch(ctx context.Context, subscriptionID string, opts ...option.RequestOption) (res *Subscription, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, nil, &res, opts...)
	return
}

// This endpoint is used to fetch a day-by-day snapshot of a subscription's costs
// in Orb, calculated by applying pricing information to the underlying usage (see
// the [subscription usage endpoint](fetch-subscription-usage) to fetch usage per
// metric, in usage units rather than a currency).
//
// The semantics of this endpoint exactly mirror those of
// [fetching a customer's costs](fetch-customer-costs). Use this endpoint to limit
// your analysis of costs to a specific subscription for the customer (e.g. to
// de-aggregate costs when a customer's subscription has started and stopped on the
// same day).
func (r *SubscriptionService) FetchCosts(ctx context.Context, subscriptionID string, query SubscriptionFetchCostsParams, opts ...option.RequestOption) (res *SubscriptionFetchCostsResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/costs", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, query, &res, opts...)
	return
}

// This endpoint returns a [paginated](/api-reference/pagination) list of all plans
// associated with a subscription along with their start and end dates. This list
// contains the subscription's initial plan along with past and future plan
// changes.
func (r *SubscriptionService) FetchSchedule(ctx context.Context, subscriptionID string, query SubscriptionFetchScheduleParams, opts ...option.RequestOption) (res *pagination.Page[SubscriptionFetchScheduleResponse], err error) {
	var raw *http.Response
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithResponseInto(&raw)}, opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/schedule", subscriptionID)
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodGet, path, query, &res, opts...)
	if err != nil {
		return nil, err
	}
	err = cfg.Execute()
	if err != nil {
		return nil, err
	}
	res.SetPageConfig(cfg, raw)
	return res, nil
}

// This endpoint returns a [paginated](/api-reference/pagination) list of all plans
// associated with a subscription along with their start and end dates. This list
// contains the subscription's initial plan along with past and future plan
// changes.
func (r *SubscriptionService) FetchScheduleAutoPaging(ctx context.Context, subscriptionID string, query SubscriptionFetchScheduleParams, opts ...option.RequestOption) *pagination.PageAutoPager[SubscriptionFetchScheduleResponse] {
	return pagination.NewPageAutoPager(r.FetchSchedule(ctx, subscriptionID, query, opts...))
}

// This endpoint is used to fetch a subscription's usage in Orb. Especially when
// combined with optional query parameters, this endpoint is a powerful way to
// build visualizations on top of Orb's event data and metrics.
//
// With no query parameters specified, this endpoint returns usage for the
// subscription's _current billing period_ across each billable metric that
// participates in the subscription. Usage quantities returned are the result of
// evaluating the metric definition for the entirety of the customer's billing
// period.
//
// ### Default response shape
//
// Orb returns a `data` array with an object corresponding to each billable metric.
// Nested within this object is a `usage` array which has a `quantity` value and a
// corresponding `timeframe_start` and `timeframe_end`. The `quantity` value
// represents the calculated usage value for the billable metric over the specified
// timeframe (inclusive of the `timeframe_start` timestamp and exclusive of the
// `timeframe_end` timestamp).
//
// Orb will include _every_ window in the response starting from the beginning of
// the billing period, even when there were no events (and therefore no usage) in
// the window. This increases the size of the response but prevents the caller from
// filling in gaps and handling cumbersome time-based logic.
//
// The query parameters in this endpoint serve to override this behavior and
// provide some key functionality, as listed below. Note that this functionality
// can also be used _in conjunction_ with each other, e.g. to display grouped usage
// on a custom timeframe.
//
// ## Custom timeframe
//
// In order to view usage for a custom timeframe rather than the current billing
// period, specify a `timeframe_start` and `timeframe_end`. This will calculate
// quantities for usage incurred between timeframe_start (inclusive) and
// timeframe_end (exclusive), i.e. `[timeframe_start, timeframe_end)`.
//
// Note:
//
//   - These timestamps must be specified in ISO 8601 format and UTC timezone, e.g.
//     `2022-02-01T05:00:00Z`.
//   - Both parameters must be specified if either is specified.
//
// ## Grouping by custom attributes
//
// In order to view a single metric grouped by a specific _attribute_ that each
// event is tagged with (e.g. `cluster`), you must additionally specify a
// `billable_metric_id` and a `group_by` key. The `group_by` key denotes the event
// property on which to group.
//
// When returning grouped usage, only usage for `billable_metric_id` is returned,
// and a separate object in the `data` array is returned for each value of the
// `group_by` key present in your events. The `quantity` value is the result of
// evaluating the billable metric for events filtered to a single value of the
// `group_by` key.
//
// Orb expects that events that match the billable metric will contain values in
// the `properties` dictionary that correspond to the `group_by` key specified. By
// default, Orb will not return a `null` group (i.e. events that match the metric
// but do not have the key set). Currently, it is only possible to view usage
// grouped by a single attribute at a time.
//
// When viewing grouped usage, Orb uses pagination to limit the response size to
// 1000 groups by default. If there are more groups for a given subscription,
// pagination metadata in the response can be used to fetch all of the data.
//
// The following example shows usage for an "API Requests" billable metric grouped
// by `region`. Note the extra `metric_group` dictionary in the response, which
// provides metadata about the group:
//
// ```json
//
//	{
//	    "data": [
//	        {
//	            "usage": [
//	                {
//	                    "quantity": 0.19291,
//	                    "timeframe_start": "2021-10-01T07:00:00Z",
//	                    "timeframe_end": "2021-10-02T07:00:00Z",
//	                },
//	                ...
//	            ],
//	            "metric_group": {
//	                "property_key": "region",
//	                "property_value": "asia/pacific"
//	            },
//	            "billable_metric": {
//	                "id": "Fe9pbpMk86xpwdGB",
//	                "name": "API Requests"
//	            },
//	            "view_mode": "periodic"
//	        },
//	        ...
//	    ]
//	}
//
// ```
//
// ## Windowed usage
//
// The `granularity` parameter can be used to _window_ the usage `quantity` value
// into periods. When not specified, usage is returned for the entirety of the time
// range.
//
// When `granularity = day` is specified with a timeframe longer than a day, Orb
// will return a `quantity` value for each full day between `timeframe_start` and
// `timeframe_end`. Note that the days are demarcated by the _customer's local
// midnight_.
//
// For example, with `timeframe_start = 2022-02-01T05:00:00Z`,
// `timeframe_end = 2022-02-04T01:00:00Z` and `granularity=day`, the following
// windows will be returned for a customer in the `America/Los_Angeles` timezone
// since local midnight is `08:00` UTC:
//
// - `[2022-02-01T05:00:00Z, 2022-02-01T08:00:00Z)`
// - `[2022-02-01T08:00:00, 2022-02-02T08:00:00Z)`
// - `[2022-02-02T08:00:00, 2022-02-03T08:00:00Z)`
// - `[2022-02-03T08:00:00, 2022-02-04T01:00:00Z)`
//
// ```json
//
//	{
//	    "data": [
//	        {
//	            "billable_metric": {
//	                "id": "Q8w89wjTtBdejXKsm",
//	                "name": "API Requests"
//	            },
//	            "usage": [
//	                {
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-01T08:00:00+00:00",
//	                    "timeframe_start": "2022-02-01T05:00:00+00:00"
//	                },
//	                {
//
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-02T08:00:00+00:00",
//	                    "timeframe_start": "2022-02-01T08:00:00+00:00"
//	                },
//	                {
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-03T08:00:00+00:00",
//	                    "timeframe_start": "2022-02-02T08:00:00+00:00"
//	                },
//	                {
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-04T01:00:00+00:00",
//	                    "timeframe_start": "2022-02-03T08:00:00+00:00"
//	                }
//	            ],
//	            "view_mode": "periodic"
//	        },
//	        ...
//	    ]
//	}
//
// ```
//
// ## Decomposable vs. non-decomposable metrics
//
// Billable metrics fall into one of two categories: decomposable and
// non-decomposable. A decomposable billable metric, such as a sum or a count, can
// be displayed and aggregated across arbitrary timescales. On the other hand, a
// non-decomposable metric is not meaningful when only a slice of the billing
// window is considered.
//
// As an example, if we have a billable metric that's defined to count unique
// users, displaying a graph of unique users for each day is not representative of
// the billable metric value over the month (days could have an overlapping set of
// 'unique' users). Instead, what's useful for any given day is the number of
// unique users in the billing period so far, which are the _cumulative_ unique
// users.
//
// Accordingly, this endpoint returns treats these two types of metrics differently
// when `group_by` is specified:
//
//   - Decomposable metrics can be grouped by any event property.
//   - Non-decomposable metrics can only be grouped by the corresponding price's
//     invoice grouping key. If no invoice grouping key is present, the metric does
//     not support `group_by`.
//
// ## Matrix prices
//
// When a billable metric is attached to a price that uses matrix pricing, it's
// important to view usage grouped by those matrix dimensions. In this case, use
// the query parameters `first_dimension_key`, `first_dimension_value` and
// `second_dimension_key`, `second_dimension_value` while filtering to a specific
// `billable_metric_id`.
//
// For example, if your compute metric has a separate unit price (i.e. a matrix
// pricing model) per `region` and `provider`, your request might provide the
// following parameters:
//
// - `first_dimension_key`: `region`
// - `first_dimension_value`: `us-east-1`
// - `second_dimension_key`: `provider`
// - `second_dimension_value`: `aws`
func (r *SubscriptionService) FetchUsage(ctx context.Context, subscriptionID string, query SubscriptionFetchUsageParams, opts ...option.RequestOption) (res *SubscriptionUsage, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/usage", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, query, &res, opts...)
	return
}

// This endpoint is used to add and edit subscription
// [price intervals](/api-reference/price-interval/add-or-edit-price-intervals). By
// making modifications to a subscription’s price intervals, you can
// [flexibly and atomically control the billing behavior of a subscription](/product-catalog/modifying-subscriptions).
//
// ## Adding price intervals
//
// Prices can be added as price intervals to a subscription by specifying them in
// the `add` array. A `price_id` or `external_price_id` from an add-on price or
// previously removed plan price can be specified to reuse an existing price
// definition (however, please note that prices from other plans cannot be added to
// the subscription). Additionally, a new price can be specified using the `price`
// field — this price will be created automatically.
//
// A `start_date` must be specified for the price interval. This is the date when
// the price will start billing on the subscription, so this will notably result in
// an immediate charge at this time for any billed in advance fixed fees. The
// `end_date` will default to null, resulting in a price interval that will bill on
// a continually recurring basis. Both of these dates can be set in the past or the
// future and Orb will generate or modify invoices to ensure the subscription’s
// invoicing behavior is correct.
//
// Additionally, a discount, minimum, or maximum can be specified on the price
// interval. This will only apply to this price interval, not any other price
// intervals on the subscription.
//
// ## Adjustment intervals
//
// An adjustment interval represents the time period that a particular adjustment
// (a discount, minimum, or maximum) applies to the prices on a subscription.
// Adjustment intervals can be added to a subscription by specifying them in the
// `add_adjustments` array, or modified via the `edit_adjustments` array. When
// creating an adjustment interval, you'll need to provide the definition of the
// new adjustment (the type of adjustment, and which prices it applies to), as well
// as the start and end dates for the adjustment interval. The start and end dates
// of an existing adjustment interval can be edited via the `edit_adjustments`
// field (just like price intervals). (To "change" the amount of a discount,
// minimum, or maximum, then, you'll need to end the existing interval, and create
// a new adjustment interval with the new amount and a start date that matches the
// end date of the previous interval.)
//
// ## Editing price intervals
//
// Price intervals can be adjusted by specifying edits to make in the `edit` array.
// A `price_interval_id` to edit must be specified — this can be retrieved from the
// `price_intervals` field on the subscription.
//
// A new `start_date` or `end_date` can be specified to change the range of the
// price interval, which will modify past or future invoices to ensure correctness.
// If either of these dates are unspecified, they will default to the existing date
// on the price interval. To remove a price interval entirely from a subscription,
// set the `end_date` to be equivalent to the `start_date`.
//
// ## Fixed fee quantity transitions
//
// The fixed fee quantity transitions for a fixed fee price interval can also be
// specified when adding or editing by passing an array for
// `fixed_fee_quantity_transitions`. A fixed fee quantity transition must have a
// `quantity` and an `effective_date`, which is the date after which the new
// quantity will be used for billing. If a fixed fee quantity transition is
// scheduled at a billing period boundary, the full quantity will be billed on an
// invoice with the other prices on the subscription. If the fixed fee quantity
// transition is scheduled mid-billing period, the difference between the existing
// quantity and quantity specified in the transition will be prorated for the rest
// of the billing period and billed immediately, which will generate a new invoice.
//
// Notably, the list of fixed fee quantity transitions passed will overwrite the
// existing fixed fee quantity transitions on the price interval, so the entire
// list of transitions must be specified to add additional transitions. The
// existing list of transitions can be retrieved using the
// `fixed_fee_quantity_transitions` property on a subscription’s serialized price
// intervals.
func (r *SubscriptionService) PriceIntervals(ctx context.Context, subscriptionID string, body SubscriptionPriceIntervalsParams, opts ...option.RequestOption) (res *SubscriptionPriceIntervalsResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/price_intervals", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to change an existing subscription's plan. It returns
// the serialized updated subscription object.
//
// The body parameter `change_option` determines when the plan change occurrs. Orb
// supports three options:
//
//   - `end_of_subscription_term`: changes the plan at the end of the existing plan's
//     term.
//   - Issuing this plan change request for a monthly subscription will keep the
//     existing plan active until the start of the subsequent month. Issuing this
//     plan change request for a yearly subscription will keep the existing plan
//     active for the full year. Charges incurred in the remaining period will be
//     invoiced as normal.
//   - Example: The plan is billed monthly on the 1st of the month, the request is
//     made on January 15th, so the plan will be changed on February 1st, and
//     invoice will be issued on February 1st for the last month of the original
//     plan.
//   - `immediate`: changes the plan immediately.
//   - Subscriptions that have their plan changed with this option will move to the
//     new plan immediately, and be invoiced immediately.
//   - This invoice will include any usage fees incurred in the billing period up
//     to the change, along with any prorated recurring fees for the billing
//     period, if applicable.
//   - Example: The plan is billed monthly on the 1st of the month, the request is
//     made on January 15th, so the plan will be changed on January 15th, and an
//     invoice will be issued for the partial month, from January 1 to January 15,
//     on the original plan.
//   - `requested_date`: changes the plan on the requested date (`change_date`).
//   - If no timezone is provided, the customer's timezone is used. The
//     `change_date` body parameter is required if this option is chosen.
//   - Example: The plan is billed monthly on the 1st of the month, the request is
//     made on January 15th, with a requested `change_date` of February 15th, so
//     the plan will be changed on February 15th, and invoices will be issued on
//     February 1st and February 15th.
//
// Note that one of `plan_id` or `external_plan_id` is required in the request body
// for this operation.
//
// ## Customize your customer's subscriptions
//
// Prices and adjustments in a plan can be added, removed, or replaced on the
// subscription when you schedule the plan change. This is useful when a customer
// has prices that differ from the default prices for a specific plan.
//
// <Note>
// This feature is only available for accounts that have migrated to Subscription Overrides Version 2. You can find your
// Subscription Overrides Version at the bottom of your [Plans page](https://app.withorb.com/plans)
// </Note>
//
// ### Adding Prices
//
// To add prices, provide a list of objects with the key `add_prices`. An object in
// the list must specify an existing add-on price with a `price_id` or
// `external_price_id` field, or create a new add-on price by including an object
// with the key `price`, identical to what would be used in the request body for
// the [create price endpoint](/api-reference/price/create-price). See the
// [Price resource](/product-catalog/price-configuration) for the specification of
// different price model configurations possible in this object.
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the price should be added to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. If `start_date` is unspecified, the start of the phase / plan change
// time will be used. If `end_date` is unspecified, it will finish at the end of
// the phase / have no end time.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference this price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Removing Prices
//
// To remove prices, provide a list of objects with the key `remove_prices`. An
// object in the list must specify a plan price with either a `price_id` or
// `external_price_id` field.
//
// ### Replacing Prices
//
// To replace prices, provide a list of objects with the key `replace_prices`. An
// object in the list must specify a plan price to replace with the
// `replaces_price_id` key, and it must specify a price to replace it with by
// either referencing an existing add-on price with a `price_id` or
// `external_price_id` field, or by creating a new add-on price by including an
// object with the key `price`, identical to what would be used in the request body
// for the [create price endpoint](/api-reference/price/create-price). See the
// [Price resource](/product-catalog/price-configuration) for the specification of
// different price model configurations possible in this object.
//
// For fixed fees, an object in the list can supply a `fixed_price_quantity`
// instead of a `price`, `price_id`, or `external_price_id` field. This will update
// only the quantity for the price, similar to the
// [Update price quantity](/api-reference/subscription/update-price-quantity)
// endpoint.
//
// The replacement price will have the same phase, if applicable, and the same
// start and end dates as the price it replaces.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference the replacement price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Adding adjustments
//
// To add adjustments, provide a list of objects with the key `add_adjustments`. An
// object in the list must include an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](/api-reference/price-interval/add-or-edit-price-intervals).
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the adjustment should be added
// to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. If `start_date` is unspecified, the start of the phase / plan change
// time will be used. If `end_date` is unspecified, it will finish at the end of
// the phase / have no end time.
//
// ### Removing adjustments
//
// To remove adjustments, provide a list of objects with the key
// `remove_adjustments`. An object in the list must include a key, `adjustment_id`,
// with the ID of the adjustment to be removed.
//
// ### Replacing adjustments
//
// To replace adjustments, provide a list of objects with the key
// `replace_adjustments`. An object in the list must specify a plan adjustment to
// replace with the `replaces_adjustment_id` key, and it must specify an adjustment
// to replace it with by including an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](/api-reference/price-interval/add-or-edit-price-intervals).
//
// The replacement adjustment will have the same phase, if applicable, and the same
// start and end dates as the adjustment it replaces.
//
// ## Price overrides (DEPRECATED)
//
// <Note>
// Price overrides are being phased out in favor adding/removing/replacing prices. (See
// [Customize your customer's subscriptions](/api-reference/subscription/schedule-plan-change))
// </Note>
//
// Price overrides are used to update some or all prices in a plan for the specific
// subscription being created. This is useful when a new customer has negotiated a
// rate that is unique to the customer.
//
// To override prices, provide a list of objects with the key `price_overrides`.
// The price object in the list of overrides is expected to contain the existing
// price id, the `model_type` and configuration. (See the
// [Price resource](/product-catalog/price-configuration) for the specification of
// different price model configurations.) The numerical values can be updated, but
// the billable metric, cadence, type, and name of a price can not be overridden.
//
// ### Maximums, and minimums
//
// Price overrides are used to update some or all prices in the target plan.
// Minimums and maximums, much like price overrides, can be useful when a new
// customer has negotiated a new or different minimum or maximum spend cap than the
// default for the plan. The request format for maximums and minimums is the same
// as those in [subscription creation](create-subscription).
//
// ## Scheduling multiple plan changes
//
// When scheduling multiple plan changes with the same date, the latest plan change
// on that day takes effect.
//
// ## Prorations for in-advance fees
//
// By default, Orb calculates the prorated difference in any fixed fees when making
// a plan change, adjusting the customer balance as needed. For details on this
// behavior, see
// [Modifying subscriptions](/product-catalog/modifying-subscriptions#prorations-for-in-advance-fees).
func (r *SubscriptionService) SchedulePlanChange(ctx context.Context, subscriptionID string, body SubscriptionSchedulePlanChangeParams, opts ...option.RequestOption) (res *SubscriptionSchedulePlanChangeResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/schedule_plan_change", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// Manually trigger a phase, effective the given date (or the current time, if not
// specified).
func (r *SubscriptionService) TriggerPhase(ctx context.Context, subscriptionID string, body SubscriptionTriggerPhaseParams, opts ...option.RequestOption) (res *SubscriptionTriggerPhaseResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/trigger_phase", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to unschedule any pending cancellations for a
// subscription.
//
// To be eligible, the subscription must currently be active and have a future
// cancellation. This operation will turn on auto-renew, ensuring that the
// subscription does not end at the currently scheduled cancellation time.
func (r *SubscriptionService) UnscheduleCancellation(ctx context.Context, subscriptionID string, opts ...option.RequestOption) (res *SubscriptionUnscheduleCancellationResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/unschedule_cancellation", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, nil, &res, opts...)
	return
}

// This endpoint can be used to clear scheduled updates to the quantity for a fixed
// fee.
//
// If there are no updates scheduled, a request validation error will be returned
// with a 400 status code.
func (r *SubscriptionService) UnscheduleFixedFeeQuantityUpdates(ctx context.Context, subscriptionID string, body SubscriptionUnscheduleFixedFeeQuantityUpdatesParams, opts ...option.RequestOption) (res *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/unschedule_fixed_fee_quantity_updates", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to unschedule any pending plan changes on an existing
// subscription.
func (r *SubscriptionService) UnschedulePendingPlanChanges(ctx context.Context, subscriptionID string, opts ...option.RequestOption) (res *SubscriptionUnschedulePendingPlanChangesResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/unschedule_pending_plan_changes", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, nil, &res, opts...)
	return
}

// This endpoint can be used to update the quantity for a fixed fee.
//
// To be eligible, the subscription must currently be active and the price
// specified must be a fixed fee (not usage-based). This operation will immediately
// update the quantity for the fee, or if a `effective_date` is passed in, will
// update the quantity on the requested date at midnight in the customer's
// timezone.
//
// In order to change the fixed fee quantity as of the next draft invoice for this
// subscription, pass `change_option=upcoming_invoice` without an `effective_date`
// specified.
//
// If the fee is an in-advance fixed fee, it will also issue an immediate invoice
// for the difference for the remainder of the billing period.
func (r *SubscriptionService) UpdateFixedFeeQuantity(ctx context.Context, subscriptionID string, body SubscriptionUpdateFixedFeeQuantityParams, opts ...option.RequestOption) (res *SubscriptionUpdateFixedFeeQuantityResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/update_fixed_fee_quantity", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint is used to update the trial end date for a subscription. The new
// trial end date must be within the time range of the current plan (i.e. the new
// trial end date must be on or after the subscription's start date on the current
// plan, and on or before the subscription end date).
//
// In order to retroactively remove a trial completely, the end date can be set to
// the transition date of the subscription to this plan (or, if this is the first
// plan for this subscription, the subscription's start date). In order to end a
// trial immediately, the keyword `immediate` can be provided as the trial end
// date.
//
// By default, Orb will shift only the trial end date (and price intervals that
// start or end on the previous trial end date), and leave all other future price
// intervals untouched. If the `shift` parameter is set to `true`, Orb will shift
// all subsequent price and adjustment intervals by the same amount as the trial
// end date shift (so, e.g., if a plan change is scheduled or an add-on price was
// added, that change will be pushed back by the same amount of time the trial is
// extended).
func (r *SubscriptionService) UpdateTrial(ctx context.Context, subscriptionID string, body SubscriptionUpdateTrialParams, opts ...option.RequestOption) (res *SubscriptionUpdateTrialResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/update_trial", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// A [subscription](/core-concepts#subscription) represents the purchase of a plan
// by a customer.
//
// By default, subscriptions begin on the day that they're created and renew
// automatically for each billing cycle at the cadence that's configured in the
// plan definition.
//
// Subscriptions also default to **beginning of month alignment**, which means the
// first invoice issued for the subscription will have pro-rated charges between
// the `start_date` and the first of the following month. Subsequent billing
// periods will always start and end on a month boundary (e.g. subsequent month
// starts for monthly billing).
//
// Depending on the plan configuration, any _flat_ recurring fees will be billed
// either at the beginning (in-advance) or end (in-arrears) of each billing cycle.
// Plans default to **in-advance billing**. Usage-based fees are billed in arrears
// as usage is accumulated. In the normal course of events, you can expect an
// invoice to contain usage-based charges for the previous period, and a recurring
// fee for the following period.
type Subscription struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                        `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                              `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                 `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionPriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time             `json:"start_date,required" format:"date-time"`
	Status    SubscriptionStatus    `json:"status,required"`
	TrialInfo SubscriptionTrialInfo `json:"trial_info,required"`
	JSON      subscriptionJSON      `json:"-"`
}

// subscriptionJSON contains the JSON metadata for the struct [Subscription]
type subscriptionJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *Subscription) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionAdjustmentInterval struct {
	ID         string                                    `json:"id,required"`
	Adjustment SubscriptionAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionAdjustmentIntervalJSON `json:"-"`
}

// subscriptionAdjustmentIntervalJSON contains the JSON metadata for the struct
// [SubscriptionAdjustmentInterval]
type subscriptionAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionAdjustmentIntervalsAdjustment struct {
	ID             string                                                  `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                       `json:"usage_discount"`
	JSON          subscriptionAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionAdjustmentIntervalsAdjustmentUnion
}

// subscriptionAdjustmentIntervalsAdjustmentJSON contains the JSON metadata for the
// struct [SubscriptionAdjustmentIntervalsAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionAdjustmentIntervalsAdjustment) AsUnion() SubscriptionAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment] or
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                       `json:"usage_discount,required"`
	JSON          subscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                   `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                         `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                            `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON contains
// the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                            `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON contains
// the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                           `json:"year,nullable"`
	JSON subscriptionBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionBillingCycleAnchorConfigurationJSON contains the JSON metadata for
// the struct [SubscriptionBillingCycleAnchorConfiguration]
type subscriptionBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                               `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                          `json:"usage_discount"`
	JSON          subscriptionDiscountIntervalJSON `json:"-"`
	union         SubscriptionDiscountIntervalsUnion
}

// subscriptionDiscountIntervalJSON contains the JSON metadata for the struct
// [SubscriptionDiscountInterval]
type subscriptionDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionDiscountIntervalsUnion] interface which you can
// cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionDiscountIntervalsAmountDiscountInterval],
// [SubscriptionDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionDiscountInterval) AsUnion() SubscriptionDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by [SubscriptionDiscountIntervalsAmountDiscountInterval],
// [SubscriptionDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionDiscountIntervalsUsageDiscountInterval].
type SubscriptionDiscountIntervalsUnion interface {
	implementsSubscriptionDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                        `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                               `json:"start_date,required" format:"date-time"`
	JSON      subscriptionDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionDiscountIntervalsAmountDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionDiscountIntervalsAmountDiscountInterval]
type subscriptionDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionDiscountIntervalsAmountDiscountInterval) implementsSubscriptionDiscountInterval() {
}

type SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                            `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionDiscountIntervalsPercentageDiscountIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionDiscountIntervalsPercentageDiscountInterval]
type subscriptionDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionDiscountInterval() {
}

type SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                       `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                `json:"usage_discount,required"`
	JSON          subscriptionDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionDiscountIntervalsUsageDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionDiscountIntervalsUsageDiscountInterval]
type subscriptionDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionDiscountIntervalsUsageDiscountInterval) implementsSubscriptionDiscountInterval() {
}

type SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionDiscountIntervalsDiscountType string

const (
	SubscriptionDiscountIntervalsDiscountTypeAmount     SubscriptionDiscountIntervalsDiscountType = "amount"
	SubscriptionDiscountIntervalsDiscountTypePercentage SubscriptionDiscountIntervalsDiscountType = "percentage"
	SubscriptionDiscountIntervalsDiscountTypeUsage      SubscriptionDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsDiscountTypeAmount, SubscriptionDiscountIntervalsDiscountTypePercentage, SubscriptionDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                   `json:"price_id,required"`
	Quantity  float64                                  `json:"quantity,required"`
	StartDate time.Time                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionFixedFeeQuantityScheduleJSON contains the JSON metadata for the
// struct [SubscriptionFixedFeeQuantitySchedule]
type subscriptionFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionMaximumIntervalJSON `json:"-"`
}

// subscriptionMaximumIntervalJSON contains the JSON metadata for the struct
// [SubscriptionMaximumInterval]
type subscriptionMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionMinimumIntervalJSON `json:"-"`
}

// subscriptionMinimumIntervalJSON contains the JSON metadata for the struct
// [SubscriptionMinimumInterval]
type subscriptionMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionPriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionPriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                      `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionPriceIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalJSON contains the JSON metadata for the struct
// [SubscriptionPriceInterval]
type subscriptionPriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionPriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                   `json:"price_id,required"`
	Quantity      int64                                                    `json:"quantity,required"`
	JSON          subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON contains the JSON
// metadata for the struct [SubscriptionPriceIntervalsFixedFeeQuantityTransition]
type subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionRedeemedCoupon struct {
	CouponID  string                         `json:"coupon_id,required"`
	EndDate   time.Time                      `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                      `json:"start_date,required" format:"date-time"`
	JSON      subscriptionRedeemedCouponJSON `json:"-"`
}

// subscriptionRedeemedCouponJSON contains the JSON metadata for the struct
// [SubscriptionRedeemedCoupon]
type subscriptionRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive   SubscriptionStatus = "active"
	SubscriptionStatusEnded    SubscriptionStatus = "ended"
	SubscriptionStatusUpcoming SubscriptionStatus = "upcoming"
)

func (r SubscriptionStatus) IsKnown() bool {
	switch r {
	case SubscriptionStatusActive, SubscriptionStatusEnded, SubscriptionStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionTrialInfo struct {
	EndDate time.Time                 `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionTrialInfoJSON `json:"-"`
}

// subscriptionTrialInfoJSON contains the JSON metadata for the struct
// [SubscriptionTrialInfo]
type subscriptionTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsage struct {
	// This field can have the runtime type of
	// [[]SubscriptionUsageUngroupedSubscriptionUsageData],
	// [[]SubscriptionUsageGroupedSubscriptionUsageData].
	Data               interface{}               `json:"data,required"`
	PaginationMetadata shared.PaginationMetadata `json:"pagination_metadata,nullable"`
	JSON               subscriptionUsageJSON     `json:"-"`
	union              SubscriptionUsageUnion
}

// subscriptionUsageJSON contains the JSON metadata for the struct
// [SubscriptionUsage]
type subscriptionUsageJSON struct {
	Data               apijson.Field
	PaginationMetadata apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUsageJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUsage) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUsage{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionUsageUnion] interface which you can cast to the
// specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUsageUngroupedSubscriptionUsage],
// [SubscriptionUsageGroupedSubscriptionUsage].
func (r SubscriptionUsage) AsUnion() SubscriptionUsageUnion {
	return r.union
}

// Union satisfied by [SubscriptionUsageUngroupedSubscriptionUsage] or
// [SubscriptionUsageGroupedSubscriptionUsage].
type SubscriptionUsageUnion interface {
	implementsSubscriptionUsage()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUsageUnion)(nil)).Elem(),
		"",
		apijson.UnionVariant{
			TypeFilter: gjson.JSON,
			Type:       reflect.TypeOf(SubscriptionUsageUngroupedSubscriptionUsage{}),
		},
		apijson.UnionVariant{
			TypeFilter: gjson.JSON,
			Type:       reflect.TypeOf(SubscriptionUsageGroupedSubscriptionUsage{}),
		},
	)
}

type SubscriptionUsageUngroupedSubscriptionUsage struct {
	Data []SubscriptionUsageUngroupedSubscriptionUsageData `json:"data,required"`
	JSON subscriptionUsageUngroupedSubscriptionUsageJSON   `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageJSON contains the JSON metadata for
// the struct [SubscriptionUsageUngroupedSubscriptionUsage]
type subscriptionUsageUngroupedSubscriptionUsageJSON struct {
	Data        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUsageUngroupedSubscriptionUsage) implementsSubscriptionUsage() {}

type SubscriptionUsageUngroupedSubscriptionUsageData struct {
	BillableMetric SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric `json:"billable_metric,required"`
	Usage          []SubscriptionUsageUngroupedSubscriptionUsageDataUsage        `json:"usage,required"`
	ViewMode       SubscriptionUsageUngroupedSubscriptionUsageDataViewMode       `json:"view_mode,required"`
	JSON           subscriptionUsageUngroupedSubscriptionUsageDataJSON           `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageDataJSON contains the JSON metadata
// for the struct [SubscriptionUsageUngroupedSubscriptionUsageData]
type subscriptionUsageUngroupedSubscriptionUsageDataJSON struct {
	BillableMetric apijson.Field
	Usage          apijson.Field
	ViewMode       apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsageData) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageDataJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric struct {
	ID   string                                                            `json:"id,required"`
	Name string                                                            `json:"name,required"`
	JSON subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON contains the
// JSON metadata for the struct
// [SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric]
type subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageUngroupedSubscriptionUsageDataUsage struct {
	Quantity       float64                                                  `json:"quantity,required"`
	TimeframeEnd   time.Time                                                `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time                                                `json:"timeframe_start,required" format:"date-time"`
	JSON           subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON contains the JSON
// metadata for the struct [SubscriptionUsageUngroupedSubscriptionUsageDataUsage]
type subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON struct {
	Quantity       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsageDataUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageUngroupedSubscriptionUsageDataViewMode string

const (
	SubscriptionUsageUngroupedSubscriptionUsageDataViewModePeriodic   SubscriptionUsageUngroupedSubscriptionUsageDataViewMode = "periodic"
	SubscriptionUsageUngroupedSubscriptionUsageDataViewModeCumulative SubscriptionUsageUngroupedSubscriptionUsageDataViewMode = "cumulative"
)

func (r SubscriptionUsageUngroupedSubscriptionUsageDataViewMode) IsKnown() bool {
	switch r {
	case SubscriptionUsageUngroupedSubscriptionUsageDataViewModePeriodic, SubscriptionUsageUngroupedSubscriptionUsageDataViewModeCumulative:
		return true
	}
	return false
}

type SubscriptionUsageGroupedSubscriptionUsage struct {
	Data               []SubscriptionUsageGroupedSubscriptionUsageData `json:"data,required"`
	PaginationMetadata shared.PaginationMetadata                       `json:"pagination_metadata,nullable"`
	JSON               subscriptionUsageGroupedSubscriptionUsageJSON   `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageJSON contains the JSON metadata for the
// struct [SubscriptionUsageGroupedSubscriptionUsage]
type subscriptionUsageGroupedSubscriptionUsageJSON struct {
	Data               apijson.Field
	PaginationMetadata apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUsageGroupedSubscriptionUsage) implementsSubscriptionUsage() {}

type SubscriptionUsageGroupedSubscriptionUsageData struct {
	BillableMetric SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric `json:"billable_metric,required"`
	MetricGroup    SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup    `json:"metric_group,required"`
	Usage          []SubscriptionUsageGroupedSubscriptionUsageDataUsage        `json:"usage,required"`
	ViewMode       SubscriptionUsageGroupedSubscriptionUsageDataViewMode       `json:"view_mode,required"`
	JSON           subscriptionUsageGroupedSubscriptionUsageDataJSON           `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataJSON contains the JSON metadata for
// the struct [SubscriptionUsageGroupedSubscriptionUsageData]
type subscriptionUsageGroupedSubscriptionUsageDataJSON struct {
	BillableMetric apijson.Field
	MetricGroup    apijson.Field
	Usage          apijson.Field
	ViewMode       apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageData) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric struct {
	ID   string                                                          `json:"id,required"`
	Name string                                                          `json:"name,required"`
	JSON subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON contains the
// JSON metadata for the struct
// [SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric]
type subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup struct {
	PropertyKey   string                                                       `json:"property_key,required"`
	PropertyValue string                                                       `json:"property_value,required"`
	JSON          subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON contains the JSON
// metadata for the struct
// [SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup]
type subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON struct {
	PropertyKey   apijson.Field
	PropertyValue apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataUsage struct {
	Quantity       float64                                                `json:"quantity,required"`
	TimeframeEnd   time.Time                                              `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time                                              `json:"timeframe_start,required" format:"date-time"`
	JSON           subscriptionUsageGroupedSubscriptionUsageDataUsageJSON `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataUsageJSON contains the JSON
// metadata for the struct [SubscriptionUsageGroupedSubscriptionUsageDataUsage]
type subscriptionUsageGroupedSubscriptionUsageDataUsageJSON struct {
	Quantity       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageDataUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataUsageJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataViewMode string

const (
	SubscriptionUsageGroupedSubscriptionUsageDataViewModePeriodic   SubscriptionUsageGroupedSubscriptionUsageDataViewMode = "periodic"
	SubscriptionUsageGroupedSubscriptionUsageDataViewModeCumulative SubscriptionUsageGroupedSubscriptionUsageDataViewMode = "cumulative"
)

func (r SubscriptionUsageGroupedSubscriptionUsageDataViewMode) IsKnown() bool {
	switch r {
	case SubscriptionUsageGroupedSubscriptionUsageDataViewModePeriodic, SubscriptionUsageGroupedSubscriptionUsageDataViewModeCumulative:
		return true
	}
	return false
}

type Subscriptions struct {
	Data               []Subscription            `json:"data,required"`
	PaginationMetadata shared.PaginationMetadata `json:"pagination_metadata,required"`
	JSON               subscriptionsJSON         `json:"-"`
}

// subscriptionsJSON contains the JSON metadata for the struct [Subscriptions]
type subscriptionsJSON struct {
	Data               apijson.Field
	PaginationMetadata apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *Subscriptions) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionsJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionNewResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                   `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionNewResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionNewResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                         `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionNewResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                            `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionNewResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionNewResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionNewResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionNewResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                        `json:"start_date,required" format:"date-time"`
	Status    SubscriptionNewResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionNewResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionNewResponseJSON      `json:"-"`
}

// subscriptionNewResponseJSON contains the JSON metadata for the struct
// [SubscriptionNewResponse]
type subscriptionNewResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionNewResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseAdjustmentInterval struct {
	ID         string                                               `json:"id,required"`
	Adjustment SubscriptionNewResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseAdjustmentInterval]
type subscriptionNewResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                             `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                  `json:"usage_discount"`
	JSON          subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON contains the JSON
// metadata for the struct [SubscriptionNewResponseAdjustmentIntervalsAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionNewResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionNewResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                  `json:"usage_discount,required"`
	JSON          subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                              `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                    `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                        `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                      `json:"year,nullable"`
	JSON subscriptionNewResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionNewResponseBillingCycleAnchorConfigurationJSON contains the JSON
// metadata for the struct [SubscriptionNewResponseBillingCycleAnchorConfiguration]
type subscriptionNewResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                     `json:"usage_discount"`
	JSON          subscriptionNewResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionNewResponseDiscountIntervalsUnion
}

// subscriptionNewResponseDiscountIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseDiscountInterval]
type subscriptionNewResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionNewResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionNewResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionNewResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionNewResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionNewResponseDiscountInterval) AsUnion() SubscriptionNewResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionNewResponseDiscountIntervalsUnion interface {
	implementsSubscriptionNewResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionNewResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                   `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionNewResponseDiscountInterval() {
}

type SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                       `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionNewResponseDiscountInterval() {
}

type SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                           `json:"usage_discount,required"`
	JSON          subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionNewResponseDiscountInterval() {
}

type SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionNewResponseDiscountIntervalsDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsDiscountTypeAmount     SubscriptionNewResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionNewResponseDiscountIntervalsDiscountTypePercentage SubscriptionNewResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionNewResponseDiscountIntervalsDiscountTypeUsage      SubscriptionNewResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionNewResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsDiscountTypeAmount, SubscriptionNewResponseDiscountIntervalsDiscountTypePercentage, SubscriptionNewResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionNewResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                           `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                              `json:"price_id,required"`
	Quantity  float64                                             `json:"quantity,required"`
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionNewResponseFixedFeeQuantityScheduleJSON contains the JSON metadata
// for the struct [SubscriptionNewResponseFixedFeeQuantitySchedule]
type subscriptionNewResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                  `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionNewResponseMaximumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseMaximumInterval]
type subscriptionNewResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                  `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionNewResponseMinimumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseMinimumInterval]
type subscriptionNewResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionNewResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                 `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionNewResponsePriceIntervalJSON `json:"-"`
}

// subscriptionNewResponsePriceIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponsePriceInterval]
type subscriptionNewResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionNewResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                           `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                              `json:"price_id,required"`
	Quantity      int64                                                               `json:"quantity,required"`
	JSON          subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON contains the
// JSON metadata for the struct
// [SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseRedeemedCoupon struct {
	CouponID  string                                    `json:"coupon_id,required"`
	EndDate   time.Time                                 `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionNewResponseRedeemedCouponJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseRedeemedCoupon]
type subscriptionNewResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseStatus string

const (
	SubscriptionNewResponseStatusActive   SubscriptionNewResponseStatus = "active"
	SubscriptionNewResponseStatusEnded    SubscriptionNewResponseStatus = "ended"
	SubscriptionNewResponseStatusUpcoming SubscriptionNewResponseStatus = "upcoming"
)

func (r SubscriptionNewResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseStatusActive, SubscriptionNewResponseStatusEnded, SubscriptionNewResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionNewResponseTrialInfo struct {
	EndDate time.Time                            `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionNewResponseTrialInfoJSON `json:"-"`
}

// subscriptionNewResponseTrialInfoJSON contains the JSON metadata for the struct
// [SubscriptionNewResponseTrialInfo]
type subscriptionNewResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionCancelResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                      `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionCancelResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionCancelResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                            `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionCancelResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                               `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionCancelResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionCancelResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionCancelResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionCancelResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                           `json:"start_date,required" format:"date-time"`
	Status    SubscriptionCancelResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionCancelResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionCancelResponseJSON      `json:"-"`
}

// subscriptionCancelResponseJSON contains the JSON metadata for the struct
// [SubscriptionCancelResponse]
type subscriptionCancelResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionCancelResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseAdjustmentInterval struct {
	ID         string                                                  `json:"id,required"`
	Adjustment SubscriptionCancelResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalJSON contains the JSON metadata for
// the struct [SubscriptionCancelResponseAdjustmentInterval]
type subscriptionCancelResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                     `json:"usage_discount"`
	JSON          subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON contains the JSON
// metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionCancelResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                     `json:"usage_discount,required"`
	JSON          subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                           `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionCancelResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                         `json:"year,nullable"`
	JSON subscriptionCancelResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionCancelResponseBillingCycleAnchorConfigurationJSON contains the JSON
// metadata for the struct
// [SubscriptionCancelResponseBillingCycleAnchorConfiguration]
type subscriptionCancelResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                        `json:"usage_discount"`
	JSON          subscriptionCancelResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionCancelResponseDiscountIntervalsUnion
}

// subscriptionCancelResponseDiscountIntervalJSON contains the JSON metadata for
// the struct [SubscriptionCancelResponseDiscountInterval]
type subscriptionCancelResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionCancelResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionCancelResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionCancelResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionCancelResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionCancelResponseDiscountInterval) AsUnion() SubscriptionCancelResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionCancelResponseDiscountIntervalsUnion interface {
	implementsSubscriptionCancelResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionCancelResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionCancelResponseDiscountInterval() {
}

type SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionCancelResponseDiscountInterval() {
}

type SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                              `json:"usage_discount,required"`
	JSON          subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionCancelResponseDiscountInterval() {
}

type SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionCancelResponseDiscountIntervalsDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsDiscountTypeAmount     SubscriptionCancelResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionCancelResponseDiscountIntervalsDiscountTypePercentage SubscriptionCancelResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionCancelResponseDiscountIntervalsDiscountTypeUsage      SubscriptionCancelResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionCancelResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsDiscountTypeAmount, SubscriptionCancelResponseDiscountIntervalsDiscountTypePercentage, SubscriptionCancelResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionCancelResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                              `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                 `json:"price_id,required"`
	Quantity  float64                                                `json:"quantity,required"`
	StartDate time.Time                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionCancelResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct [SubscriptionCancelResponseFixedFeeQuantitySchedule]
type subscriptionCancelResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionCancelResponseMaximumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseMaximumInterval]
type subscriptionCancelResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionCancelResponseMinimumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseMinimumInterval]
type subscriptionCancelResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionCancelResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                    `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionCancelResponsePriceIntervalJSON `json:"-"`
}

// subscriptionCancelResponsePriceIntervalJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponsePriceInterval]
type subscriptionCancelResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionCancelResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                              `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                 `json:"price_id,required"`
	Quantity      int64                                                                  `json:"quantity,required"`
	JSON          subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON contains
// the JSON metadata for the struct
// [SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseRedeemedCoupon struct {
	CouponID  string                                       `json:"coupon_id,required"`
	EndDate   time.Time                                    `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionCancelResponseRedeemedCouponJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseRedeemedCoupon]
type subscriptionCancelResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseStatus string

const (
	SubscriptionCancelResponseStatusActive   SubscriptionCancelResponseStatus = "active"
	SubscriptionCancelResponseStatusEnded    SubscriptionCancelResponseStatus = "ended"
	SubscriptionCancelResponseStatusUpcoming SubscriptionCancelResponseStatus = "upcoming"
)

func (r SubscriptionCancelResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseStatusActive, SubscriptionCancelResponseStatusEnded, SubscriptionCancelResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionCancelResponseTrialInfo struct {
	EndDate time.Time                               `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionCancelResponseTrialInfoJSON `json:"-"`
}

// subscriptionCancelResponseTrialInfoJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseTrialInfo]
type subscriptionCancelResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchCostsResponse struct {
	Data []SubscriptionFetchCostsResponseData `json:"data,required"`
	JSON subscriptionFetchCostsResponseJSON   `json:"-"`
}

// subscriptionFetchCostsResponseJSON contains the JSON metadata for the struct
// [SubscriptionFetchCostsResponse]
type subscriptionFetchCostsResponseJSON struct {
	Data        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFetchCostsResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchCostsResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchCostsResponseData struct {
	PerPriceCosts []SubscriptionFetchCostsResponseDataPerPriceCost `json:"per_price_costs,required"`
	// Total costs for the timeframe, excluding any minimums and discounts.
	Subtotal       string    `json:"subtotal,required"`
	TimeframeEnd   time.Time `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time `json:"timeframe_start,required" format:"date-time"`
	// Total costs for the timeframe, including any minimums and discounts.
	Total string                                 `json:"total,required"`
	JSON  subscriptionFetchCostsResponseDataJSON `json:"-"`
}

// subscriptionFetchCostsResponseDataJSON contains the JSON metadata for the struct
// [SubscriptionFetchCostsResponseData]
type subscriptionFetchCostsResponseDataJSON struct {
	PerPriceCosts  apijson.Field
	Subtotal       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	Total          apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionFetchCostsResponseData) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchCostsResponseDataJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchCostsResponseDataPerPriceCost struct {
	// The price object
	Price Price `json:"price,required"`
	// The price the cost is associated with
	PriceID string `json:"price_id,required"`
	// Price's contributions for the timeframe, excluding any minimums and discounts.
	Subtotal string `json:"subtotal,required"`
	// Price's contributions for the timeframe, including minimums and discounts.
	Total string `json:"total,required"`
	// The price's quantity for the timeframe
	Quantity float64                                            `json:"quantity,nullable"`
	JSON     subscriptionFetchCostsResponseDataPerPriceCostJSON `json:"-"`
}

// subscriptionFetchCostsResponseDataPerPriceCostJSON contains the JSON metadata
// for the struct [SubscriptionFetchCostsResponseDataPerPriceCost]
type subscriptionFetchCostsResponseDataPerPriceCostJSON struct {
	Price       apijson.Field
	PriceID     apijson.Field
	Subtotal    apijson.Field
	Total       apijson.Field
	Quantity    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFetchCostsResponseDataPerPriceCost) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchCostsResponseDataPerPriceCostJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchScheduleResponse struct {
	CreatedAt time.Time                             `json:"created_at,required" format:"date-time"`
	EndDate   time.Time                             `json:"end_date,required,nullable" format:"date-time"`
	Plan      SubscriptionFetchScheduleResponsePlan `json:"plan,required"`
	StartDate time.Time                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionFetchScheduleResponseJSON `json:"-"`
}

// subscriptionFetchScheduleResponseJSON contains the JSON metadata for the struct
// [SubscriptionFetchScheduleResponse]
type subscriptionFetchScheduleResponseJSON struct {
	CreatedAt   apijson.Field
	EndDate     apijson.Field
	Plan        apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFetchScheduleResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchScheduleResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchScheduleResponsePlan struct {
	ID string `json:"id,required,nullable"`
	// An optional user-defined ID for this plan resource, used throughout the system
	// as an alias for this Plan. Use this field to identify a plan by an existing
	// identifier in your system.
	ExternalPlanID string                                    `json:"external_plan_id,required,nullable"`
	Name           string                                    `json:"name,required,nullable"`
	JSON           subscriptionFetchScheduleResponsePlanJSON `json:"-"`
}

// subscriptionFetchScheduleResponsePlanJSON contains the JSON metadata for the
// struct [SubscriptionFetchScheduleResponsePlan]
type subscriptionFetchScheduleResponsePlanJSON struct {
	ID             apijson.Field
	ExternalPlanID apijson.Field
	Name           apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionFetchScheduleResponsePlan) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchScheduleResponsePlanJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionPriceIntervalsResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                              `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionPriceIntervalsResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                       `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionPriceIntervalsResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionPriceIntervalsResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionPriceIntervalsResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionPriceIntervalsResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                   `json:"start_date,required" format:"date-time"`
	Status    SubscriptionPriceIntervalsResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionPriceIntervalsResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionPriceIntervalsResponseJSON      `json:"-"`
}

// subscriptionPriceIntervalsResponseJSON contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponse]
type subscriptionPriceIntervalsResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseAdjustmentInterval struct {
	ID         string                                                          `json:"id,required"`
	Adjustment SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalJSON contains the JSON
// metadata for the struct [SubscriptionPriceIntervalsResponseAdjustmentInterval]
type subscriptionPriceIntervalsResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                        `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                             `json:"usage_discount"`
	JSON          subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON contains the
// JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                        `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                             `json:"usage_discount,required"`
	JSON          subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                         `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                               `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                   `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                        `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                        `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                 `json:"year,nullable"`
	JSON subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON contains
// the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration]
type subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                `json:"usage_discount"`
	JSON          subscriptionPriceIntervalsResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionPriceIntervalsResponseDiscountIntervalsUnion
}

// subscriptionPriceIntervalsResponseDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionPriceIntervalsResponseDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionPriceIntervalsResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionPriceIntervalsResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionPriceIntervalsResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionPriceIntervalsResponseDiscountInterval) AsUnion() SubscriptionPriceIntervalsResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval]
// or [SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionPriceIntervalsResponseDiscountIntervalsUnion interface {
	implementsSubscriptionPriceIntervalsResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionPriceIntervalsResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                              `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionPriceIntervalsResponseDiscountInterval() {
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionPriceIntervalsResponseDiscountInterval() {
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                      `json:"usage_discount,required"`
	JSON          subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionPriceIntervalsResponseDiscountInterval() {
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeAmount     SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypePercentage SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeUsage      SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeAmount, SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypePercentage, SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                      `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                         `json:"price_id,required"`
	Quantity  float64                                                        `json:"quantity,required"`
	StartDate time.Time                                                      `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct
// [SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule]
type subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseMaximumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponseMaximumInterval]
type subscriptionPriceIntervalsResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseMinimumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponseMinimumInterval]
type subscriptionPriceIntervalsResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionPriceIntervalsResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                            `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionPriceIntervalsResponsePriceIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponsePriceIntervalJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponsePriceInterval]
type subscriptionPriceIntervalsResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                      `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                         `json:"price_id,required"`
	Quantity      int64                                                                          `json:"quantity,required"`
	JSON          subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseRedeemedCoupon struct {
	CouponID  string                                               `json:"coupon_id,required"`
	EndDate   time.Time                                            `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                            `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseRedeemedCouponJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponseRedeemedCoupon]
type subscriptionPriceIntervalsResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseStatus string

const (
	SubscriptionPriceIntervalsResponseStatusActive   SubscriptionPriceIntervalsResponseStatus = "active"
	SubscriptionPriceIntervalsResponseStatusEnded    SubscriptionPriceIntervalsResponseStatus = "ended"
	SubscriptionPriceIntervalsResponseStatusUpcoming SubscriptionPriceIntervalsResponseStatus = "upcoming"
)

func (r SubscriptionPriceIntervalsResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseStatusActive, SubscriptionPriceIntervalsResponseStatusEnded, SubscriptionPriceIntervalsResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseTrialInfo struct {
	EndDate time.Time                                       `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionPriceIntervalsResponseTrialInfoJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseTrialInfoJSON contains the JSON metadata for
// the struct [SubscriptionPriceIntervalsResponseTrialInfo]
type subscriptionPriceIntervalsResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionSchedulePlanChangeResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                  `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionSchedulePlanChangeResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                        `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                           `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionSchedulePlanChangeResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionSchedulePlanChangeResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionSchedulePlanChangeResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionSchedulePlanChangeResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                       `json:"start_date,required" format:"date-time"`
	Status    SubscriptionSchedulePlanChangeResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionSchedulePlanChangeResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionSchedulePlanChangeResponseJSON      `json:"-"`
}

// subscriptionSchedulePlanChangeResponseJSON contains the JSON metadata for the
// struct [SubscriptionSchedulePlanChangeResponse]
type subscriptionSchedulePlanChangeResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseAdjustmentInterval struct {
	ID         string                                                              `json:"id,required"`
	Adjustment SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentInterval]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                            `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                 `json:"usage_discount"`
	JSON          subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON contains
// the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                 `json:"usage_discount,required"`
	JSON          subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                   `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                            `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                            `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                     `json:"year,nullable"`
	JSON subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration]
type subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                         `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                    `json:"usage_discount"`
	JSON          subscriptionSchedulePlanChangeResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionSchedulePlanChangeResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionSchedulePlanChangeResponseDiscountInterval) AsUnion() SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion interface {
	implementsSubscriptionSchedulePlanChangeResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionSchedulePlanChangeResponseDiscountInterval() {
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionSchedulePlanChangeResponseDiscountInterval() {
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                 `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                          `json:"usage_discount,required"`
	JSON          subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionSchedulePlanChangeResponseDiscountInterval() {
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeAmount     SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypePercentage SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeUsage      SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeAmount, SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypePercentage, SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                          `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                             `json:"price_id,required"`
	Quantity  float64                                                            `json:"quantity,required"`
	StartDate time.Time                                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON contains the
// JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule]
type subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseMaximumIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseMaximumInterval]
type subscriptionSchedulePlanChangeResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseMinimumIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseMinimumInterval]
type subscriptionSchedulePlanChangeResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionSchedulePlanChangeResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                                `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionSchedulePlanChangeResponsePriceIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponsePriceIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponsePriceInterval]
type subscriptionSchedulePlanChangeResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                          `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                             `json:"price_id,required"`
	Quantity      int64                                                                              `json:"quantity,required"`
	JSON          subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseRedeemedCoupon struct {
	CouponID  string                                                   `json:"coupon_id,required"`
	EndDate   time.Time                                                `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseRedeemedCouponJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseRedeemedCoupon]
type subscriptionSchedulePlanChangeResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseStatus string

const (
	SubscriptionSchedulePlanChangeResponseStatusActive   SubscriptionSchedulePlanChangeResponseStatus = "active"
	SubscriptionSchedulePlanChangeResponseStatusEnded    SubscriptionSchedulePlanChangeResponseStatus = "ended"
	SubscriptionSchedulePlanChangeResponseStatusUpcoming SubscriptionSchedulePlanChangeResponseStatus = "upcoming"
)

func (r SubscriptionSchedulePlanChangeResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseStatusActive, SubscriptionSchedulePlanChangeResponseStatusEnded, SubscriptionSchedulePlanChangeResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseTrialInfo struct {
	EndDate time.Time                                           `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionSchedulePlanChangeResponseTrialInfoJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseTrialInfoJSON contains the JSON metadata
// for the struct [SubscriptionSchedulePlanChangeResponseTrialInfo]
type subscriptionSchedulePlanChangeResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionTriggerPhaseResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                            `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionTriggerPhaseResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                  `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                     `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionTriggerPhaseResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionTriggerPhaseResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionTriggerPhaseResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionTriggerPhaseResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                 `json:"start_date,required" format:"date-time"`
	Status    SubscriptionTriggerPhaseResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionTriggerPhaseResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionTriggerPhaseResponseJSON      `json:"-"`
}

// subscriptionTriggerPhaseResponseJSON contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponse]
type subscriptionTriggerPhaseResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseAdjustmentInterval struct {
	ID         string                                                        `json:"id,required"`
	Adjustment SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalJSON contains the JSON
// metadata for the struct [SubscriptionTriggerPhaseResponseAdjustmentInterval]
type subscriptionTriggerPhaseResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                      `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                           `json:"usage_discount"`
	JSON          subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON contains the
// JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                           `json:"usage_discount,required"`
	JSON          subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                           `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                 `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                      `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                      `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                               `json:"year,nullable"`
	JSON subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON contains the
// JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration]
type subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                   `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                              `json:"usage_discount"`
	JSON          subscriptionTriggerPhaseResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionTriggerPhaseResponseDiscountIntervalsUnion
}

// subscriptionTriggerPhaseResponseDiscountIntervalJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionTriggerPhaseResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionTriggerPhaseResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionTriggerPhaseResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionTriggerPhaseResponseDiscountInterval) AsUnion() SubscriptionTriggerPhaseResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionTriggerPhaseResponseDiscountIntervalsUnion interface {
	implementsSubscriptionTriggerPhaseResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionTriggerPhaseResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                            `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionTriggerPhaseResponseDiscountInterval() {
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionTriggerPhaseResponseDiscountInterval() {
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                    `json:"usage_discount,required"`
	JSON          subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionTriggerPhaseResponseDiscountInterval() {
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeAmount     SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypePercentage SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeUsage      SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeAmount, SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypePercentage, SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                       `json:"price_id,required"`
	Quantity  float64                                                      `json:"quantity,required"`
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct
// [SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule]
type subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseMaximumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseMaximumInterval]
type subscriptionTriggerPhaseResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseMinimumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseMinimumInterval]
type subscriptionTriggerPhaseResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionTriggerPhaseResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                          `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionTriggerPhaseResponsePriceIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponsePriceIntervalJSON contains the JSON metadata for
// the struct [SubscriptionTriggerPhaseResponsePriceInterval]
type subscriptionTriggerPhaseResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                    `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                       `json:"price_id,required"`
	Quantity      int64                                                                        `json:"quantity,required"`
	JSON          subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseRedeemedCoupon struct {
	CouponID  string                                             `json:"coupon_id,required"`
	EndDate   time.Time                                          `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseRedeemedCouponJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseRedeemedCoupon]
type subscriptionTriggerPhaseResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseStatus string

const (
	SubscriptionTriggerPhaseResponseStatusActive   SubscriptionTriggerPhaseResponseStatus = "active"
	SubscriptionTriggerPhaseResponseStatusEnded    SubscriptionTriggerPhaseResponseStatus = "ended"
	SubscriptionTriggerPhaseResponseStatusUpcoming SubscriptionTriggerPhaseResponseStatus = "upcoming"
)

func (r SubscriptionTriggerPhaseResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseStatusActive, SubscriptionTriggerPhaseResponseStatusEnded, SubscriptionTriggerPhaseResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseTrialInfo struct {
	EndDate time.Time                                     `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionTriggerPhaseResponseTrialInfoJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseTrialInfoJSON contains the JSON metadata for the
// struct [SubscriptionTriggerPhaseResponseTrialInfo]
type subscriptionTriggerPhaseResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUnscheduleCancellationResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                      `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUnscheduleCancellationResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                            `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                               `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUnscheduleCancellationResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUnscheduleCancellationResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUnscheduleCancellationResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUnscheduleCancellationResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUnscheduleCancellationResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUnscheduleCancellationResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUnscheduleCancellationResponseJSON      `json:"-"`
}

// subscriptionUnscheduleCancellationResponseJSON contains the JSON metadata for
// the struct [SubscriptionUnscheduleCancellationResponse]
type subscriptionUnscheduleCancellationResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseAdjustmentInterval struct {
	ID         string                                                                  `json:"id,required"`
	Adjustment SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentInterval]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                     `json:"usage_discount"`
	JSON          subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                     `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                           `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                         `json:"year,nullable"`
	JSON subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration]
type subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                        `json:"usage_discount"`
	JSON          subscriptionUnscheduleCancellationResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleCancellationResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUnscheduleCancellationResponseDiscountInterval) AsUnion() SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUnscheduleCancellationResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUnscheduleCancellationResponseDiscountInterval() {
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUnscheduleCancellationResponseDiscountInterval() {
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                              `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUnscheduleCancellationResponseDiscountInterval() {
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypePercentage SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                              `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                 `json:"price_id,required"`
	Quantity  float64                                                                `json:"quantity,required"`
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON contains
// the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule]
type subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseMaximumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseMaximumInterval]
type subscriptionUnscheduleCancellationResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseMinimumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseMinimumInterval]
type subscriptionUnscheduleCancellationResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUnscheduleCancellationResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                                    `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionUnscheduleCancellationResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponsePriceIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponsePriceInterval]
type subscriptionUnscheduleCancellationResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                              `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                 `json:"price_id,required"`
	Quantity      int64                                                                                  `json:"quantity,required"`
	JSON          subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseRedeemedCoupon struct {
	CouponID  string                                                       `json:"coupon_id,required"`
	EndDate   time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseRedeemedCouponJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseRedeemedCoupon]
type subscriptionUnscheduleCancellationResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseStatus string

const (
	SubscriptionUnscheduleCancellationResponseStatusActive   SubscriptionUnscheduleCancellationResponseStatus = "active"
	SubscriptionUnscheduleCancellationResponseStatusEnded    SubscriptionUnscheduleCancellationResponseStatus = "ended"
	SubscriptionUnscheduleCancellationResponseStatusUpcoming SubscriptionUnscheduleCancellationResponseStatus = "upcoming"
)

func (r SubscriptionUnscheduleCancellationResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseStatusActive, SubscriptionUnscheduleCancellationResponseStatusEnded, SubscriptionUnscheduleCancellationResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseTrialInfo struct {
	EndDate time.Time                                               `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUnscheduleCancellationResponseTrialInfoJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseTrialInfoJSON contains the JSON
// metadata for the struct [SubscriptionUnscheduleCancellationResponseTrialInfo]
type subscriptionUnscheduleCancellationResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                                 `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                                       `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                                          `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                                      `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON      `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON contains the JSON
// metadata for the struct [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval struct {
	ID         string                                                                             `json:"id,required"`
	Adjustment SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                           `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                `json:"usage_discount"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                                           `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                                `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                                      `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                           `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                           `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                                    `json:"year,nullable"`
	JSON subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                                        `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                   `json:"usage_discount"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval) AsUnion() SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                 `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                            `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                                         `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypePercentage SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                                         `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                            `json:"price_id,required"`
	Quantity  float64                                                                           `json:"quantity,required"`
	StartDate time.Time                                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                                               `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                                         `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                            `json:"price_id,required"`
	Quantity      int64                                                                                             `json:"quantity,required"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon struct {
	CouponID  string                                                                  `json:"coupon_id,required"`
	EndDate   time.Time                                                               `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                               `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON contains
// the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusActive   SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus = "active"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusEnded    SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus = "ended"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusUpcoming SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus = "upcoming"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusActive, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusEnded, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo struct {
	EndDate time.Time                                                          `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON contains the
// JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                            `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                                  `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                                     `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUnschedulePendingPlanChangesResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                                 `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUnschedulePendingPlanChangesResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUnschedulePendingPlanChangesResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseJSON      `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseJSON contains the JSON metadata
// for the struct [SubscriptionUnschedulePendingPlanChangesResponse]
type subscriptionUnschedulePendingPlanChangesResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval struct {
	ID         string                                                                        `json:"id,required"`
	Adjustment SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                           `json:"usage_discount"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                           `json:"usage_discount,required"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                                           `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                                 `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                      `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                      `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                               `json:"year,nullable"`
	JSON subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration]
type subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                                   `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                              `json:"usage_discount"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval) AsUnion() SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                            `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval() {
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval() {
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                                    `json:"usage_discount,required"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval() {
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypePercentage SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                                    `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                       `json:"price_id,required"`
	Quantity  float64                                                                      `json:"quantity,required"`
	StartDate time.Time                                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule]
type subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval]
type subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval]
type subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUnschedulePendingPlanChangesResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                                          `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponsePriceInterval]
type subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                                    `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                       `json:"price_id,required"`
	Quantity      int64                                                                                        `json:"quantity,required"`
	JSON          subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon struct {
	CouponID  string                                                             `json:"coupon_id,required"`
	EndDate   time.Time                                                          `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon]
type subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseStatus string

const (
	SubscriptionUnschedulePendingPlanChangesResponseStatusActive   SubscriptionUnschedulePendingPlanChangesResponseStatus = "active"
	SubscriptionUnschedulePendingPlanChangesResponseStatusEnded    SubscriptionUnschedulePendingPlanChangesResponseStatus = "ended"
	SubscriptionUnschedulePendingPlanChangesResponseStatusUpcoming SubscriptionUnschedulePendingPlanChangesResponseStatus = "upcoming"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseStatusActive, SubscriptionUnschedulePendingPlanChangesResponseStatusEnded, SubscriptionUnschedulePendingPlanChangesResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseTrialInfo struct {
	EndDate time.Time                                                     `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON contains the JSON
// metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseTrialInfo]
type subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                      `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                            `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                               `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUpdateFixedFeeQuantityResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUpdateFixedFeeQuantityResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUpdateFixedFeeQuantityResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseJSON      `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseJSON contains the JSON metadata for
// the struct [SubscriptionUpdateFixedFeeQuantityResponse]
type subscriptionUpdateFixedFeeQuantityResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval struct {
	ID         string                                                                  `json:"id,required"`
	Adjustment SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                     `json:"usage_discount"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                     `json:"usage_discount,required"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                           `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                         `json:"year,nullable"`
	JSON subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration]
type subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                        `json:"usage_discount"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval) AsUnion() SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval() {
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval() {
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                              `json:"usage_discount,required"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval() {
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypePercentage SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                              `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                 `json:"price_id,required"`
	Quantity  float64                                                                `json:"quantity,required"`
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON contains
// the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule]
type subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval]
type subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval]
type subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUpdateFixedFeeQuantityResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                                    `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponsePriceInterval]
type subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                              `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                 `json:"price_id,required"`
	Quantity      int64                                                                                  `json:"quantity,required"`
	JSON          subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon struct {
	CouponID  string                                                       `json:"coupon_id,required"`
	EndDate   time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon]
type subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseStatus string

const (
	SubscriptionUpdateFixedFeeQuantityResponseStatusActive   SubscriptionUpdateFixedFeeQuantityResponseStatus = "active"
	SubscriptionUpdateFixedFeeQuantityResponseStatusEnded    SubscriptionUpdateFixedFeeQuantityResponseStatus = "ended"
	SubscriptionUpdateFixedFeeQuantityResponseStatusUpcoming SubscriptionUpdateFixedFeeQuantityResponseStatus = "upcoming"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseStatusActive, SubscriptionUpdateFixedFeeQuantityResponseStatusEnded, SubscriptionUpdateFixedFeeQuantityResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseTrialInfo struct {
	EndDate time.Time                                               `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON contains the JSON
// metadata for the struct [SubscriptionUpdateFixedFeeQuantityResponseTrialInfo]
type subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUpdateTrialResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                           `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See [Timezone localization](/essentials/timezones) for
	// information on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUpdateTrialResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                 `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                    `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUpdateTrialResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUpdateTrialResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](/core-concepts#plan-and-price) resource represents a plan that can be
	// subscribed to by a customer. Plans define the billing behavior of the
	// subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUpdateTrialResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUpdateTrialResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUpdateTrialResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUpdateTrialResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUpdateTrialResponseJSON      `json:"-"`
}

// subscriptionUpdateTrialResponseJSON contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponse]
type subscriptionUpdateTrialResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseAdjustmentInterval struct {
	ID         string                                                       `json:"id,required"`
	Adjustment SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseAdjustmentInterval]
type subscriptionUpdateTrialResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                          `json:"usage_discount"`
	JSON          subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON contains the
// JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
// or
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment].
type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment struct {
	ID             string                                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                          `json:"usage_discount,required"`
	JSON          subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment struct {
	ID             string                                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                            `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment struct {
	ID             string                                                                                                          `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhasePercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment struct {
	ID             string                                                                                               `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                     `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment struct {
	ID             string                                                                                               `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                     `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPlanPhaseMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                              `json:"year,nullable"`
	JSON subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON contains the
// JSON metadata for the struct
// [SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration]
type subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                             `json:"usage_discount"`
	JSON          subscriptionUpdateTrialResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUpdateTrialResponseDiscountIntervalsUnion
}

// subscriptionUpdateTrialResponseDiscountIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUpdateTrialResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateTrialResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateTrialResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionUpdateTrialResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUpdateTrialResponseDiscountInterval) AsUnion() SubscriptionUpdateTrialResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUpdateTrialResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUpdateTrialResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateTrialResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                  `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUpdateTrialResponseDiscountInterval() {
}

type SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                               `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                      `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUpdateTrialResponseDiscountInterval() {
}

type SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                   `json:"usage_discount,required"`
	JSON          subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUpdateTrialResponseDiscountInterval() {
}

type SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypePercentage SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                   `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                      `json:"price_id,required"`
	Quantity  float64                                                     `json:"quantity,required"`
	StartDate time.Time                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule]
type subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseMaximumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseMaximumInterval]
type subscriptionUpdateTrialResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseMinimumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseMinimumInterval]
type subscriptionUpdateTrialResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUpdateTrialResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// An additional filter to apply to usage queries.
	Filter string `json:"filter,required,nullable"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// For more on the types of prices, see
	// [the core concepts documentation](/core-concepts#plan-and-price)
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this price interval.
	UsageCustomerIDs []string                                         `json:"usage_customer_ids,required,nullable"`
	JSON             subscriptionUpdateTrialResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponsePriceIntervalJSON contains the JSON metadata for
// the struct [SubscriptionUpdateTrialResponsePriceInterval]
type subscriptionUpdateTrialResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	Filter                        apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	UsageCustomerIDs              apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                   `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                      `json:"price_id,required"`
	Quantity      int64                                                                       `json:"quantity,required"`
	JSON          subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseRedeemedCoupon struct {
	CouponID  string                                            `json:"coupon_id,required"`
	EndDate   time.Time                                         `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUpdateTrialResponseRedeemedCouponJSON contains the JSON metadata for
// the struct [SubscriptionUpdateTrialResponseRedeemedCoupon]
type subscriptionUpdateTrialResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseStatus string

const (
	SubscriptionUpdateTrialResponseStatusActive   SubscriptionUpdateTrialResponseStatus = "active"
	SubscriptionUpdateTrialResponseStatusEnded    SubscriptionUpdateTrialResponseStatus = "ended"
	SubscriptionUpdateTrialResponseStatusUpcoming SubscriptionUpdateTrialResponseStatus = "upcoming"
)

func (r SubscriptionUpdateTrialResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseStatusActive, SubscriptionUpdateTrialResponseStatusEnded, SubscriptionUpdateTrialResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseTrialInfo struct {
	EndDate time.Time                                    `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUpdateTrialResponseTrialInfoJSON `json:"-"`
}

// subscriptionUpdateTrialResponseTrialInfoJSON contains the JSON metadata for the
// struct [SubscriptionUpdateTrialResponseTrialInfo]
type subscriptionUpdateTrialResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewParams struct {
	// Additional adjustments to be added to the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	AddAdjustments param.Field[[]shared.AddSubscriptionAdjustmentParams] `json:"add_adjustments"`
	// Additional prices to be added to the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	AddPrices                             param.Field[[]shared.AddSubscriptionPriceParams] `json:"add_prices"`
	AlignBillingWithSubscriptionStartDate param.Field[bool]                                `json:"align_billing_with_subscription_start_date"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. If not specified, this
	// defaults to the behavior configured for this customer.
	AutoCollection                  param.Field[bool]                                                 `json:"auto_collection"`
	AwsRegion                       param.Field[string]                                               `json:"aws_region"`
	BillingCycleAnchorConfiguration param.Field[SubscriptionNewParamsBillingCycleAnchorConfiguration] `json:"billing_cycle_anchor_configuration"`
	// Redemption code to be used for this subscription. If the coupon cannot be found
	// by its redemption code, or cannot be redeemed, an error response will be
	// returned and the subscription creation or plan change will not be scheduled.
	CouponRedemptionCode param.Field[string]  `json:"coupon_redemption_code"`
	CreditsOverageRate   param.Field[float64] `json:"credits_overage_rate"`
	CustomerID           param.Field[string]  `json:"customer_id"`
	// Determines the default memo on this subscription's invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo             param.Field[string]                                   `json:"default_invoice_memo"`
	EndDate                        param.Field[time.Time]                                `json:"end_date" format:"date-time"`
	ExternalCustomerID             param.Field[string]                                   `json:"external_customer_id"`
	ExternalMarketplace            param.Field[SubscriptionNewParamsExternalMarketplace] `json:"external_marketplace"`
	ExternalMarketplaceReportingID param.Field[string]                                   `json:"external_marketplace_reporting_id"`
	// The external_plan_id of the plan that the given subscription should be switched
	// to. Note that either this property or `plan_id` must be specified.
	ExternalPlanID param.Field[string] `json:"external_plan_id"`
	// An additional filter to apply to usage queries. This filter must be expressed as
	// a boolean
	// [computed property](/extensibility/advanced-metrics#computed-properties). If
	// null, usage queries will not include any additional filter.
	Filter param.Field[string] `json:"filter"`
	// The phase of the plan to start with
	InitialPhaseOrder param.Field[int64] `json:"initial_phase_order"`
	// When this subscription's accrued usage reaches this threshold, an invoice will
	// be issued for the subscription. If not specified, invoices will only be issued
	// at the end of the billing period.
	InvoicingThreshold param.Field[string] `json:"invoicing_threshold"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// The net terms determines the difference between the invoice date and the issue
	// date for the invoice. If you intend the invoice to be due on issue, set this
	// to 0. If not provided, this defaults to the value specified in the plan.
	NetTerms               param.Field[int64]   `json:"net_terms"`
	PerCreditOverageAmount param.Field[float64] `json:"per_credit_overage_amount"`
	// The plan that the given subscription should be switched to. Note that either
	// this property or `external_plan_id` must be specified.
	PlanID param.Field[string] `json:"plan_id"`
	// Specifies which version of the plan to subscribe to. If null, the default
	// version will be used.
	PlanVersionNumber param.Field[int64] `json:"plan_version_number"`
	// Optionally provide a list of overrides for prices on the plan
	PriceOverrides param.Field[[]interface{}] `json:"price_overrides"`
	// Plan adjustments to be removed from the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	RemoveAdjustments param.Field[[]shared.RemoveSubscriptionAdjustmentParams] `json:"remove_adjustments"`
	// Plan prices to be removed from the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	RemovePrices param.Field[[]shared.RemoveSubscriptionPriceParams] `json:"remove_prices"`
	// Plan adjustments to be replaced with additional adjustments on the subscription.
	// (Only available for accounts that have migrated off of legacy subscription
	// overrides)
	ReplaceAdjustments param.Field[[]shared.ReplaceSubscriptionAdjustmentParams] `json:"replace_adjustments"`
	// Plan prices to be replaced with additional prices on the subscription. (Only
	// available for accounts that have migrated off of legacy subscription overrides)
	ReplacePrices param.Field[[]shared.ReplaceSubscriptionPriceParams] `json:"replace_prices"`
	StartDate     param.Field[time.Time]                               `json:"start_date" format:"date-time"`
	// The duration of the trial period in days. If not provided, this defaults to the
	// value specified in the plan. If `0` is provided, the trial on the plan will be
	// skipped.
	TrialDurationDays param.Field[int64] `json:"trial_duration_days"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this subscription. By default, a subscription only considers usage events
	// associated with its attached customer's customer_id. When usage_customer_ids is
	// provided, the subscription includes usage events from the specified customers
	// only. Provided usage_customer_ids must be either the customer for this
	// subscription itself, or any of that customer's children.
	UsageCustomerIDs param.Field[[]string] `json:"usage_customer_ids"`
}

func (r SubscriptionNewParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day param.Field[int64] `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month param.Field[int64] `json:"month"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year param.Field[int64] `json:"year"`
}

func (r SubscriptionNewParamsBillingCycleAnchorConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsExternalMarketplace string

const (
	SubscriptionNewParamsExternalMarketplaceGoogle SubscriptionNewParamsExternalMarketplace = "google"
	SubscriptionNewParamsExternalMarketplaceAws    SubscriptionNewParamsExternalMarketplace = "aws"
	SubscriptionNewParamsExternalMarketplaceAzure  SubscriptionNewParamsExternalMarketplace = "azure"
)

func (r SubscriptionNewParamsExternalMarketplace) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsExternalMarketplaceGoogle, SubscriptionNewParamsExternalMarketplaceAws, SubscriptionNewParamsExternalMarketplaceAzure:
		return true
	}
	return false
}

type SubscriptionUpdateParams struct {
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior.
	AutoCollection param.Field[bool] `json:"auto_collection"`
	// Determines the default memo on this subscription's invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo param.Field[string] `json:"default_invoice_memo"`
	// When this subscription's accrued usage reaches this threshold, an invoice will
	// be issued for the subscription. If not specified, invoices will only be issued
	// at the end of the billing period.
	InvoicingThreshold param.Field[string] `json:"invoicing_threshold"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms param.Field[int64] `json:"net_terms"`
}

func (r SubscriptionUpdateParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionListParams struct {
	CreatedAtGt  param.Field[time.Time] `query:"created_at[gt]" format:"date-time"`
	CreatedAtGte param.Field[time.Time] `query:"created_at[gte]" format:"date-time"`
	CreatedAtLt  param.Field[time.Time] `query:"created_at[lt]" format:"date-time"`
	CreatedAtLte param.Field[time.Time] `query:"created_at[lte]" format:"date-time"`
	// Cursor for pagination. This can be populated by the `next_cursor` value returned
	// from the initial request.
	Cursor             param.Field[string]   `query:"cursor"`
	CustomerID         param.Field[[]string] `query:"customer_id"`
	ExternalCustomerID param.Field[string]   `query:"external_customer_id"`
	// The number of items to fetch. Defaults to 20.
	Limit  param.Field[int64]                        `query:"limit"`
	Status param.Field[SubscriptionListParamsStatus] `query:"status"`
}

// URLQuery serializes [SubscriptionListParams]'s query parameters as `url.Values`.
func (r SubscriptionListParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

type SubscriptionListParamsStatus string

const (
	SubscriptionListParamsStatusActive   SubscriptionListParamsStatus = "active"
	SubscriptionListParamsStatusEnded    SubscriptionListParamsStatus = "ended"
	SubscriptionListParamsStatusUpcoming SubscriptionListParamsStatus = "upcoming"
)

func (r SubscriptionListParamsStatus) IsKnown() bool {
	switch r {
	case SubscriptionListParamsStatusActive, SubscriptionListParamsStatusEnded, SubscriptionListParamsStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionCancelParams struct {
	// Determines the timing of subscription cancellation
	CancelOption param.Field[SubscriptionCancelParamsCancelOption] `json:"cancel_option,required"`
	// If false, this request will fail if it would void an issued invoice or create a
	// credit note. Consider using this as a safety mechanism if you do not expect
	// existing invoices to be changed.
	AllowInvoiceCreditOrVoid param.Field[bool] `json:"allow_invoice_credit_or_void"`
	// The date that the cancellation should take effect. This parameter can only be
	// passed if the `cancel_option` is `requested_date`.
	CancellationDate param.Field[time.Time] `json:"cancellation_date" format:"date-time"`
}

func (r SubscriptionCancelParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// Determines the timing of subscription cancellation
type SubscriptionCancelParamsCancelOption string

const (
	SubscriptionCancelParamsCancelOptionEndOfSubscriptionTerm SubscriptionCancelParamsCancelOption = "end_of_subscription_term"
	SubscriptionCancelParamsCancelOptionImmediate             SubscriptionCancelParamsCancelOption = "immediate"
	SubscriptionCancelParamsCancelOptionRequestedDate         SubscriptionCancelParamsCancelOption = "requested_date"
)

func (r SubscriptionCancelParamsCancelOption) IsKnown() bool {
	switch r {
	case SubscriptionCancelParamsCancelOptionEndOfSubscriptionTerm, SubscriptionCancelParamsCancelOptionImmediate, SubscriptionCancelParamsCancelOptionRequestedDate:
		return true
	}
	return false
}

type SubscriptionFetchCostsParams struct {
	// The currency or custom pricing unit to use.
	Currency param.Field[string] `query:"currency"`
	// Costs returned are exclusive of `timeframe_end`.
	TimeframeEnd param.Field[time.Time] `query:"timeframe_end" format:"date-time"`
	// Costs returned are inclusive of `timeframe_start`.
	TimeframeStart param.Field[time.Time] `query:"timeframe_start" format:"date-time"`
	// Controls whether Orb returns cumulative costs since the start of the billing
	// period, or incremental day-by-day costs. If your customer has minimums or
	// discounts, it's strongly recommended that you use the default cumulative
	// behavior.
	ViewMode param.Field[SubscriptionFetchCostsParamsViewMode] `query:"view_mode"`
}

// URLQuery serializes [SubscriptionFetchCostsParams]'s query parameters as
// `url.Values`.
func (r SubscriptionFetchCostsParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

// Controls whether Orb returns cumulative costs since the start of the billing
// period, or incremental day-by-day costs. If your customer has minimums or
// discounts, it's strongly recommended that you use the default cumulative
// behavior.
type SubscriptionFetchCostsParamsViewMode string

const (
	SubscriptionFetchCostsParamsViewModePeriodic   SubscriptionFetchCostsParamsViewMode = "periodic"
	SubscriptionFetchCostsParamsViewModeCumulative SubscriptionFetchCostsParamsViewMode = "cumulative"
)

func (r SubscriptionFetchCostsParamsViewMode) IsKnown() bool {
	switch r {
	case SubscriptionFetchCostsParamsViewModePeriodic, SubscriptionFetchCostsParamsViewModeCumulative:
		return true
	}
	return false
}

type SubscriptionFetchScheduleParams struct {
	// Cursor for pagination. This can be populated by the `next_cursor` value returned
	// from the initial request.
	Cursor param.Field[string] `query:"cursor"`
	// The number of items to fetch. Defaults to 20.
	Limit        param.Field[int64]     `query:"limit"`
	StartDateGt  param.Field[time.Time] `query:"start_date[gt]" format:"date-time"`
	StartDateGte param.Field[time.Time] `query:"start_date[gte]" format:"date-time"`
	StartDateLt  param.Field[time.Time] `query:"start_date[lt]" format:"date-time"`
	StartDateLte param.Field[time.Time] `query:"start_date[lte]" format:"date-time"`
}

// URLQuery serializes [SubscriptionFetchScheduleParams]'s query parameters as
// `url.Values`.
func (r SubscriptionFetchScheduleParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

type SubscriptionFetchUsageParams struct {
	// When specified in conjunction with `group_by`, this parameter filters usage to a
	// single billable metric. Note that both `group_by` and `billable_metric_id` must
	// be specified together.
	BillableMetricID    param.Field[string] `query:"billable_metric_id"`
	FirstDimensionKey   param.Field[string] `query:"first_dimension_key"`
	FirstDimensionValue param.Field[string] `query:"first_dimension_value"`
	// This determines the windowing of usage reporting.
	Granularity param.Field[SubscriptionFetchUsageParamsGranularity] `query:"granularity"`
	// Groups per-price usage by the key provided.
	GroupBy              param.Field[string] `query:"group_by"`
	SecondDimensionKey   param.Field[string] `query:"second_dimension_key"`
	SecondDimensionValue param.Field[string] `query:"second_dimension_value"`
	// Usage returned is exclusive of `timeframe_end`.
	TimeframeEnd param.Field[time.Time] `query:"timeframe_end" format:"date-time"`
	// Usage returned is inclusive of `timeframe_start`.
	TimeframeStart param.Field[time.Time] `query:"timeframe_start" format:"date-time"`
	// Controls whether Orb returns cumulative usage since the start of the billing
	// period, or incremental day-by-day usage. If your customer has minimums or
	// discounts, it's strongly recommended that you use the default cumulative
	// behavior.
	ViewMode param.Field[SubscriptionFetchUsageParamsViewMode] `query:"view_mode"`
}

// URLQuery serializes [SubscriptionFetchUsageParams]'s query parameters as
// `url.Values`.
func (r SubscriptionFetchUsageParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

// This determines the windowing of usage reporting.
type SubscriptionFetchUsageParamsGranularity string

const (
	SubscriptionFetchUsageParamsGranularityDay SubscriptionFetchUsageParamsGranularity = "day"
)

func (r SubscriptionFetchUsageParamsGranularity) IsKnown() bool {
	switch r {
	case SubscriptionFetchUsageParamsGranularityDay:
		return true
	}
	return false
}

// Controls whether Orb returns cumulative usage since the start of the billing
// period, or incremental day-by-day usage. If your customer has minimums or
// discounts, it's strongly recommended that you use the default cumulative
// behavior.
type SubscriptionFetchUsageParamsViewMode string

const (
	SubscriptionFetchUsageParamsViewModePeriodic   SubscriptionFetchUsageParamsViewMode = "periodic"
	SubscriptionFetchUsageParamsViewModeCumulative SubscriptionFetchUsageParamsViewMode = "cumulative"
)

func (r SubscriptionFetchUsageParamsViewMode) IsKnown() bool {
	switch r {
	case SubscriptionFetchUsageParamsViewModePeriodic, SubscriptionFetchUsageParamsViewModeCumulative:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParams struct {
	// A list of price intervals to add to the subscription.
	Add param.Field[[]SubscriptionPriceIntervalsParamsAdd] `json:"add"`
	// A list of adjustments to add to the subscription.
	AddAdjustments param.Field[[]SubscriptionPriceIntervalsParamsAddAdjustment] `json:"add_adjustments"`
	// If false, this request will fail if it would void an issued invoice or create a
	// credit note. Consider using this as a safety mechanism if you do not expect
	// existing invoices to be changed.
	AllowInvoiceCreditOrVoid param.Field[bool] `json:"allow_invoice_credit_or_void"`
	// A list of price intervals to edit on the subscription.
	Edit param.Field[[]SubscriptionPriceIntervalsParamsEdit] `json:"edit"`
	// A list of adjustments to edit on the subscription.
	EditAdjustments param.Field[[]SubscriptionPriceIntervalsParamsEditAdjustment] `json:"edit_adjustments"`
}

func (r SubscriptionPriceIntervalsParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAdd struct {
	// The start date of the price interval. This is the date that the price will start
	// billing on the subscription.
	StartDate param.Field[SubscriptionPriceIntervalsParamsAddStartDateUnion] `json:"start_date,required" format:"date-time"`
	// The definition of a new allocation price to create and add to the subscription.
	AllocationPrice param.Field[SubscriptionPriceIntervalsParamsAddAllocationPrice] `json:"allocation_price"`
	// A list of discounts to initialize on the price interval.
	Discounts param.Field[[]SubscriptionPriceIntervalsParamsAddDiscountUnion] `json:"discounts"`
	// The end date of the price interval. This is the date that the price will stop
	// billing on the subscription.
	EndDate param.Field[SubscriptionPriceIntervalsParamsAddEndDateUnion] `json:"end_date" format:"date-time"`
	// The external price id of the price to add to the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// An additional filter to apply to usage queries. This filter must be expressed as
	// a boolean
	// [computed property](/extensibility/advanced-metrics#computed-properties). If
	// null, usage queries will not include any additional filter.
	Filter param.Field[string] `json:"filter"`
	// A list of fixed fee quantity transitions to initialize on the price interval.
	FixedFeeQuantityTransitions param.Field[[]SubscriptionPriceIntervalsParamsAddFixedFeeQuantityTransition] `json:"fixed_fee_quantity_transitions"`
	// The maximum amount that will be billed for this price interval for a given
	// billing period.
	MaximumAmount param.Field[float64] `json:"maximum_amount"`
	// The minimum amount that will be billed for this price interval for a given
	// billing period.
	MinimumAmount param.Field[float64] `json:"minimum_amount"`
	// The definition of a new price to create and add to the subscription.
	Price param.Field[SubscriptionPriceIntervalsParamsAddPriceUnion] `json:"price"`
	// The id of the price to add to the subscription.
	PriceID param.Field[string] `json:"price_id"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this subscription. By default, a subscription only considers usage events
	// associated with its attached customer's customer_id. When usage_customer_ids is
	// provided, the subscription includes usage events from the specified customers
	// only. Provided usage_customer_ids must be either the customer for this
	// subscription itself, or any of that customer's children.
	UsageCustomerIDs param.Field[[]string] `json:"usage_customer_ids"`
}

func (r SubscriptionPriceIntervalsParamsAdd) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The start date of the price interval. This is the date that the price will start
// billing on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddStartDateUnion()
}

// The definition of a new allocation price to create and add to the subscription.
type SubscriptionPriceIntervalsParamsAddAllocationPrice struct {
	// An amount of the currency to allocate to the customer at the specified cadence.
	Amount param.Field[string] `json:"amount,required"`
	// The cadence at which to allocate the amount to the customer.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string or a custom pricing unit identifier in which to bill
	// this price.
	Currency param.Field[string] `json:"currency,required"`
	// Whether the allocated amount should expire at the end of the cadence or roll
	// over to the next period.
	ExpiresAtEndOfCadence param.Field[bool] `json:"expires_at_end_of_cadence,required"`
}

func (r SubscriptionPriceIntervalsParamsAddAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence at which to allocate the amount to the customer.
type SubscriptionPriceIntervalsParamsAddAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscount struct {
	DiscountType param.Field[SubscriptionPriceIntervalsParamsAddDiscountsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[float64] `json:"amount_discount"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for.
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscount) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

// Satisfied by
// [SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams],
// [SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams],
// [SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams],
// [SubscriptionPriceIntervalsParamsAddDiscount].
type SubscriptionPriceIntervalsParamsAddDiscountUnion interface {
	implementsSubscriptionPriceIntervalsParamsAddDiscountUnion()
}

type SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams struct {
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[float64]                                                                              `json:"amount_discount,required"`
	DiscountType   param.Field[SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType] `json:"discount_type,required"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

type SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountTypeAmount SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType = "amount"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams struct {
	DiscountType param.Field[SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

type SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountTypePercentage SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType = "percentage"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams struct {
	DiscountType param.Field[SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for.
	UsageDiscount param.Field[float64] `json:"usage_discount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

type SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountTypeUsage SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscountsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeAmount     SubscriptionPriceIntervalsParamsAddDiscountsDiscountType = "amount"
	SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypePercentage SubscriptionPriceIntervalsParamsAddDiscountsDiscountType = "percentage"
	SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeUsage      SubscriptionPriceIntervalsParamsAddDiscountsDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeAmount, SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypePercentage, SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeUsage:
		return true
	}
	return false
}

// The end date of the price interval. This is the date that the price will stop
// billing on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddEndDateUnion()
}

type SubscriptionPriceIntervalsParamsAddFixedFeeQuantityTransition struct {
	// The date that the fixed fee quantity transition should take effect.
	EffectiveDate param.Field[time.Time] `json:"effective_date,required" format:"date-time"`
	// The quantity of the fixed fee quantity transition.
	Quantity param.Field[int64] `json:"quantity,required"`
}

func (r SubscriptionPriceIntervalsParamsAddFixedFeeQuantityTransition) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new price to create and add to the subscription.
type SubscriptionPriceIntervalsParamsAddPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance           param.Field[bool]        `json:"billed_in_advance"`
	BillingCycleConfiguration param.Field[interface{}] `json:"billing_cycle_configuration"`
	BpsConfig                 param.Field[interface{}] `json:"bps_config"`
	BulkBpsConfig             param.Field[interface{}] `json:"bulk_bps_config"`
	BulkConfig                param.Field[interface{}] `json:"bulk_config"`
	BulkWithProrationConfig   param.Field[interface{}] `json:"bulk_with_proration_config"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate              param.Field[float64]     `json:"conversion_rate"`
	CumulativeGroupedBulkConfig param.Field[interface{}] `json:"cumulative_grouped_bulk_config"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity               param.Field[float64]     `json:"fixed_price_quantity"`
	GroupedAllocationConfig          param.Field[interface{}] `json:"grouped_allocation_config"`
	GroupedTieredConfig              param.Field[interface{}] `json:"grouped_tiered_config"`
	GroupedTieredPackageConfig       param.Field[interface{}] `json:"grouped_tiered_package_config"`
	GroupedWithMeteredMinimumConfig  param.Field[interface{}] `json:"grouped_with_metered_minimum_config"`
	GroupedWithProratedMinimumConfig param.Field[interface{}] `json:"grouped_with_prorated_minimum_config"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey                    param.Field[string]      `json:"invoice_grouping_key"`
	InvoicingCycleConfiguration           param.Field[interface{}] `json:"invoicing_cycle_configuration"`
	MatrixConfig                          param.Field[interface{}] `json:"matrix_config"`
	MatrixWithAllocationConfig            param.Field[interface{}] `json:"matrix_with_allocation_config"`
	MatrixWithDisplayNameConfig           param.Field[interface{}] `json:"matrix_with_display_name_config"`
	MaxGroupTieredPackageConfig           param.Field[interface{}] `json:"max_group_tiered_package_config"`
	Metadata                              param.Field[interface{}] `json:"metadata"`
	PackageConfig                         param.Field[interface{}] `json:"package_config"`
	PackageWithAllocationConfig           param.Field[interface{}] `json:"package_with_allocation_config"`
	ScalableMatrixWithTieredPricingConfig param.Field[interface{}] `json:"scalable_matrix_with_tiered_pricing_config"`
	ScalableMatrixWithUnitPricingConfig   param.Field[interface{}] `json:"scalable_matrix_with_unit_pricing_config"`
	ThresholdTotalAmountConfig            param.Field[interface{}] `json:"threshold_total_amount_config"`
	TieredBpsConfig                       param.Field[interface{}] `json:"tiered_bps_config"`
	TieredConfig                          param.Field[interface{}] `json:"tiered_config"`
	TieredPackageConfig                   param.Field[interface{}] `json:"tiered_package_config"`
	TieredPackageWithMinimumConfig        param.Field[interface{}] `json:"tiered_package_with_minimum_config"`
	TieredWithMinimumConfig               param.Field[interface{}] `json:"tiered_with_minimum_config"`
	TieredWithProrationConfig             param.Field[interface{}] `json:"tiered_with_proration_config"`
	UnitConfig                            param.Field[interface{}] `json:"unit_config"`
	UnitWithPercentConfig                 param.Field[interface{}] `json:"unit_with_percent_config"`
	UnitWithProrationConfig               param.Field[interface{}] `json:"unit_with_proration_config"`
}

func (r SubscriptionPriceIntervalsParamsAddPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The definition of a new price to create and add to the subscription.
//
// Satisfied by [SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPrice],
// [SubscriptionPriceIntervalsParamsAddPrice].
type SubscriptionPriceIntervalsParamsAddPriceUnion interface {
	implementsSubscriptionPriceIntervalsParamsAddPriceUnion()
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]                                                                 `json:"name,required"`
	UnitConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceUnitConfig] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelTypeUnit SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType = "unit"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceUnitConfig struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceUnitConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]                                                                       `json:"name,required"`
	PackageConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePricePackageConfig] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelTypePackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType = "package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelTypePackage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePricePackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePricePackageConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID       param.Field[string]                                                                     `json:"item_id,required"`
	MatrixConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfig] `json:"matrix_config,required"`
	ModelType    param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType]    `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelTypeMatrix SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType = "matrix"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID                     param.Field[string]                                                                                                 `json:"item_id,required"`
	MatrixWithAllocationConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfig] `json:"matrix_with_allocation_config,required"`
	ModelType                  param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType]                  `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfig struct {
	// Allocation to be used to calculate the price
	Allocation param.Field[float64] `json:"allocation,required"`
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelTypeMatrixWithAllocation SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType = "matrix_with_allocation"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelTypeMatrixWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]                                                                     `json:"name,required"`
	TieredConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfig] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelTypeTiered SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType = "tiered"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfigTier struct {
	// Inclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Exclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]                                                                           `json:"name,required"`
	TieredBpsConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfig] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelTypeTieredBps SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType = "tiered_bps"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelTypeTieredBps:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfigTier struct {
	// Per-event basis point rate
	Bps param.Field[float64] `json:"bps,required"`
	// Inclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Exclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice struct {
	BpsConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBpsConfig] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBpsConfig struct {
	// Basis point take rate per event
	Bps param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelTypeBps SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType = "bps"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelTypeBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice struct {
	BulkBpsConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfig] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfigTier struct {
	// Basis points to rate on
	Bps param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelTypeBulkBps SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType = "bulk_bps"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelTypeBulkBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice struct {
	BulkConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfig] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfigTier struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelTypeBulk SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType = "bulk"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelTypeThresholdTotalAmount SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelTypeTieredPackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType = "tiered_package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency            param.Field[string]                 `json:"currency,required"`
	GroupedTieredConfig param.Field[map[string]interface{}] `json:"grouped_tiered_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelTypeGroupedTiered SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType = "grouped_tiered"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelTypeGroupedTiered:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID                      param.Field[string]                                                                                 `json:"item_id,required"`
	MaxGroupTieredPackageConfig param.Field[map[string]interface{}]                                                                 `json:"max_group_tiered_package_config,required"`
	ModelType                   param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceModelType = "max_group_tiered_package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceModelTypeMaxGroupTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMaxGroupTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelTypeTieredWithMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelTypePackageWithAllocation SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                    `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                           param.Field[string]                 `json:"name,required"`
	TieredPackageWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_package_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType = "tiered_package_with_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelTypeUnitWithPercent SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelTypeTieredWithProration SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType = "tiered_with_proration"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelTypeUnitWithProration SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                param.Field[string]                 `json:"currency,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}] `json:"grouped_allocation_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelTypeGroupedAllocation SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                         param.Field[string]                 `json:"currency,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}] `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                      `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                        param.Field[string]                 `json:"currency,required"`
	GroupedWithMeteredMinimumConfig param.Field[map[string]interface{}] `json:"grouped_with_metered_minimum_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType = "grouped_with_metered_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID                      param.Field[string]                                                                                 `json:"item_id,required"`
	MatrixWithDisplayNameConfig param.Field[map[string]interface{}]                                                                 `json:"matrix_with_display_name_config,required"`
	ModelType                   param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType = "matrix_with_display_name"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelTypeBulkWithProration SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                   param.Field[string]                 `json:"currency,required"`
	GroupedTieredPackageConfig param.Field[map[string]interface{}] `json:"grouped_tiered_package_config,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelTypeGroupedTieredPackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType = "grouped_tiered_package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelTypeGroupedTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                                param.Field[string]                 `json:"name,required"`
	ScalableMatrixWithUnitPricingConfig param.Field[map[string]interface{}] `json:"scalable_matrix_with_unit_pricing_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceModelType = "scalable_matrix_with_unit_pricing"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceModelTypeScalableMatrixWithUnitPricing:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithUnitPricingPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                                  param.Field[string]                 `json:"name,required"`
	ScalableMatrixWithTieredPricingConfig param.Field[map[string]interface{}] `json:"scalable_matrix_with_tiered_pricing_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceModelType = "scalable_matrix_with_tiered_pricing"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceModelTypeScalableMatrixWithTieredPricing:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingScalableMatrixWithTieredPricingPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPrice struct {
	// The cadence to bill for this price on.
	Cadence                     param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence] `json:"cadence,required"`
	CumulativeGroupedBulkConfig param.Field[map[string]interface{}]                                                               `json:"cumulative_grouped_bulk_config,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the price will be associated with.
	ItemID    param.Field[string]                                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceModelType = "cumulative_grouped_bulk"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceModelTypeCumulativeGroupedBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingCumulativeGroupedBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceModelTypeUnit                            SubscriptionPriceIntervalsParamsAddPriceModelType = "unit"
	SubscriptionPriceIntervalsParamsAddPriceModelTypePackage                         SubscriptionPriceIntervalsParamsAddPriceModelType = "package"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrix                          SubscriptionPriceIntervalsParamsAddPriceModelType = "matrix"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithAllocation            SubscriptionPriceIntervalsParamsAddPriceModelType = "matrix_with_allocation"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTiered                          SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredBps                       SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_bps"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBps                             SubscriptionPriceIntervalsParamsAddPriceModelType = "bps"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkBps                         SubscriptionPriceIntervalsParamsAddPriceModelType = "bulk_bps"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBulk                            SubscriptionPriceIntervalsParamsAddPriceModelType = "bulk"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeThresholdTotalAmount            SubscriptionPriceIntervalsParamsAddPriceModelType = "threshold_total_amount"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackage                   SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_package"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTiered                   SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_tiered"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMaxGroupTieredPackage           SubscriptionPriceIntervalsParamsAddPriceModelType = "max_group_tiered_package"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithMinimum               SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_with_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypePackageWithAllocation           SubscriptionPriceIntervalsParamsAddPriceModelType = "package_with_allocation"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackageWithMinimum        SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_package_with_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithPercent                 SubscriptionPriceIntervalsParamsAddPriceModelType = "unit_with_percent"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithProration             SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_with_proration"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithProration               SubscriptionPriceIntervalsParamsAddPriceModelType = "unit_with_proration"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedAllocation               SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_allocation"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithProratedMinimum      SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_with_prorated_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithMeteredMinimum       SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_with_metered_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithDisplayName           SubscriptionPriceIntervalsParamsAddPriceModelType = "matrix_with_display_name"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkWithProration               SubscriptionPriceIntervalsParamsAddPriceModelType = "bulk_with_proration"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTieredPackage            SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_tiered_package"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeScalableMatrixWithUnitPricing   SubscriptionPriceIntervalsParamsAddPriceModelType = "scalable_matrix_with_unit_pricing"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeScalableMatrixWithTieredPricing SubscriptionPriceIntervalsParamsAddPriceModelType = "scalable_matrix_with_tiered_pricing"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeCumulativeGroupedBulk           SubscriptionPriceIntervalsParamsAddPriceModelType = "cumulative_grouped_bulk"
)

func (r SubscriptionPriceIntervalsParamsAddPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceModelTypeUnit, SubscriptionPriceIntervalsParamsAddPriceModelTypePackage, SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrix, SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithAllocation, SubscriptionPriceIntervalsParamsAddPriceModelTypeTiered, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredBps, SubscriptionPriceIntervalsParamsAddPriceModelTypeBps, SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkBps, SubscriptionPriceIntervalsParamsAddPriceModelTypeBulk, SubscriptionPriceIntervalsParamsAddPriceModelTypeThresholdTotalAmount, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackage, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTiered, SubscriptionPriceIntervalsParamsAddPriceModelTypeMaxGroupTieredPackage, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypePackageWithAllocation, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackageWithMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithPercent, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithProration, SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithProration, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedAllocation, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithProratedMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithMeteredMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithDisplayName, SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkWithProration, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTieredPackage, SubscriptionPriceIntervalsParamsAddPriceModelTypeScalableMatrixWithUnitPricing, SubscriptionPriceIntervalsParamsAddPriceModelTypeScalableMatrixWithTieredPricing, SubscriptionPriceIntervalsParamsAddPriceModelTypeCumulativeGroupedBulk:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustment struct {
	// The definition of a new adjustment to create and add to the subscription.
	Adjustment param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion] `json:"adjustment,required"`
	// The start date of the adjustment interval. This is the date that the adjustment
	// will start affecting prices on the subscription.
	StartDate param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion] `json:"start_date,required" format:"date-time"`
	// The end date of the adjustment interval. This is the date that the adjustment
	// will stop affecting prices on the subscription.
	EndDate param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion] `json:"end_date" format:"date-time"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new adjustment to create and add to the subscription.
type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment struct {
	AdjustmentType    param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType] `json:"adjustment_type,required"`
	AppliesToPriceIDs param.Field[interface{}]                                                            `json:"applies_to_price_ids,required"`
	AmountDiscount    param.Field[string]                                                                 `json:"amount_discount"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID             param.Field[string]  `json:"item_id"`
	MaximumAmount      param.Field[string]  `json:"maximum_amount"`
	MinimumAmount      param.Field[string]  `json:"minimum_amount"`
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	UsageDiscount      param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

// The definition of a new adjustment to create and add to the subscription.
//
// Satisfied by
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment].
type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion interface {
	implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion()
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs  param.Field[[]string] `json:"applies_to_price_ids,required"`
	PercentageDiscount param.Field[float64]  `json:"percentage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	UsageDiscount     param.Field[float64]  `json:"usage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType = "usage_discount"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                                                                                  `json:"amount_discount,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType = "amount_discount"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType = "minimum"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	MaximumAmount     param.Field[string]   `json:"maximum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum            SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "minimum"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum            SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

// The start date of the adjustment interval. This is the date that the adjustment
// will start affecting prices on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion()
}

// The end date of the adjustment interval. This is the date that the adjustment
// will stop affecting prices on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion()
}

type SubscriptionPriceIntervalsParamsEdit struct {
	// The id of the price interval to edit.
	PriceIntervalID param.Field[string] `json:"price_interval_id,required"`
	// The updated billing cycle day for this price interval. If not specified, the
	// billing cycle day will not be updated. Note that overlapping price intervals
	// must have the same billing cycle day.
	BillingCycleDay param.Field[int64] `json:"billing_cycle_day"`
	// The updated end date of this price interval. If not specified, the start date
	// will not be updated.
	EndDate param.Field[SubscriptionPriceIntervalsParamsEditEndDateUnion] `json:"end_date" format:"date-time"`
	// An additional filter to apply to usage queries. This filter must be expressed as
	// a boolean
	// [computed property](/extensibility/advanced-metrics#computed-properties). If
	// null, usage queries will not include any additional filter.
	Filter param.Field[string] `json:"filter"`
	// A list of fixed fee quantity transitions to use for this price interval. Note
	// that this list will overwrite all existing fixed fee quantity transitions on the
	// price interval.
	FixedFeeQuantityTransitions param.Field[[]SubscriptionPriceIntervalsParamsEditFixedFeeQuantityTransition] `json:"fixed_fee_quantity_transitions"`
	// The updated start date of this price interval. If not specified, the start date
	// will not be updated.
	StartDate param.Field[SubscriptionPriceIntervalsParamsEditStartDateUnion] `json:"start_date" format:"date-time"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this subscription. By default, a subscription only considers usage events
	// associated with its attached customer's customer_id. When usage_customer_ids is
	// provided, the subscription includes usage events from the specified customers
	// only. Provided usage_customer_ids must be either the customer for this
	// subscription itself, or any of that customer's children.
	UsageCustomerIDs param.Field[[]string] `json:"usage_customer_ids"`
}

func (r SubscriptionPriceIntervalsParamsEdit) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The updated end date of this price interval. If not specified, the start date
// will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditEndDateUnion()
}

type SubscriptionPriceIntervalsParamsEditFixedFeeQuantityTransition struct {
	// The date that the fixed fee quantity transition should take effect.
	EffectiveDate param.Field[time.Time] `json:"effective_date,required" format:"date-time"`
	// The quantity of the fixed fee quantity transition.
	Quantity param.Field[int64] `json:"quantity,required"`
}

func (r SubscriptionPriceIntervalsParamsEditFixedFeeQuantityTransition) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The updated start date of this price interval. If not specified, the start date
// will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditStartDateUnion()
}

type SubscriptionPriceIntervalsParamsEditAdjustment struct {
	// The id of the adjustment interval to edit.
	AdjustmentIntervalID param.Field[string] `json:"adjustment_interval_id,required"`
	// The updated end date of this adjustment interval. If not specified, the start
	// date will not be updated.
	EndDate param.Field[SubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion] `json:"end_date" format:"date-time"`
	// The updated start date of this adjustment interval. If not specified, the start
	// date will not be updated.
	StartDate param.Field[SubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion] `json:"start_date" format:"date-time"`
}

func (r SubscriptionPriceIntervalsParamsEditAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The updated end date of this adjustment interval. If not specified, the start
// date will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion()
}

// The updated start date of this adjustment interval. If not specified, the start
// date will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion()
}

type SubscriptionSchedulePlanChangeParams struct {
	ChangeOption param.Field[SubscriptionSchedulePlanChangeParamsChangeOption] `json:"change_option,required"`
	// Additional adjustments to be added to the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	AddAdjustments param.Field[[]shared.AddSubscriptionAdjustmentParams] `json:"add_adjustments"`
	// Additional prices to be added to the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	AddPrices param.Field[[]shared.AddSubscriptionPriceParams] `json:"add_prices"`
	// [DEPRECATED] Use billing_cycle_alignment instead. Reset billing periods to be
	// aligned with the plan change's effective date.
	AlignBillingWithPlanChangeDate param.Field[bool] `json:"align_billing_with_plan_change_date"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. If not specified, this
	// defaults to the behavior configured for this customer.
	AutoCollection param.Field[bool] `json:"auto_collection"`
	// Reset billing periods to be aligned with the plan change's effective date or
	// start of the month. Defaults to `unchanged` which keeps subscription's existing
	// billing cycle alignment.
	BillingCycleAlignment           param.Field[SubscriptionSchedulePlanChangeParamsBillingCycleAlignment]           `json:"billing_cycle_alignment"`
	BillingCycleAnchorConfiguration param.Field[SubscriptionSchedulePlanChangeParamsBillingCycleAnchorConfiguration] `json:"billing_cycle_anchor_configuration"`
	// The date that the plan change should take effect. This parameter can only be
	// passed if the `change_option` is `requested_date`. If a date with no time is
	// passed, the plan change will happen at midnight in the customer's timezone.
	ChangeDate param.Field[time.Time] `json:"change_date" format:"date-time"`
	// Redemption code to be used for this subscription. If the coupon cannot be found
	// by its redemption code, or cannot be redeemed, an error response will be
	// returned and the subscription creation or plan change will not be scheduled.
	CouponRedemptionCode param.Field[string]  `json:"coupon_redemption_code"`
	CreditsOverageRate   param.Field[float64] `json:"credits_overage_rate"`
	// Determines the default memo on this subscription's invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo param.Field[string] `json:"default_invoice_memo"`
	// The external_plan_id of the plan that the given subscription should be switched
	// to. Note that either this property or `plan_id` must be specified.
	ExternalPlanID param.Field[string] `json:"external_plan_id"`
	// An additional filter to apply to usage queries. This filter must be expressed as
	// a boolean
	// [computed property](/extensibility/advanced-metrics#computed-properties). If
	// null, usage queries will not include any additional filter.
	Filter param.Field[string] `json:"filter"`
	// The phase of the plan to start with
	InitialPhaseOrder param.Field[int64] `json:"initial_phase_order"`
	// When this subscription's accrued usage reaches this threshold, an invoice will
	// be issued for the subscription. If not specified, invoices will only be issued
	// at the end of the billing period.
	InvoicingThreshold param.Field[string] `json:"invoicing_threshold"`
	// The net terms determines the difference between the invoice date and the issue
	// date for the invoice. If you intend the invoice to be due on issue, set this
	// to 0. If not provided, this defaults to the value specified in the plan.
	NetTerms               param.Field[int64]   `json:"net_terms"`
	PerCreditOverageAmount param.Field[float64] `json:"per_credit_overage_amount"`
	// The plan that the given subscription should be switched to. Note that either
	// this property or `external_plan_id` must be specified.
	PlanID param.Field[string] `json:"plan_id"`
	// Specifies which version of the plan to change to. If null, the default version
	// will be used.
	PlanVersionNumber param.Field[int64] `json:"plan_version_number"`
	// Optionally provide a list of overrides for prices on the plan
	PriceOverrides param.Field[[]interface{}] `json:"price_overrides"`
	// Plan adjustments to be removed from the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	RemoveAdjustments param.Field[[]shared.RemoveSubscriptionAdjustmentParams] `json:"remove_adjustments"`
	// Plan prices to be removed from the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	RemovePrices param.Field[[]shared.RemoveSubscriptionPriceParams] `json:"remove_prices"`
	// Plan adjustments to be replaced with additional adjustments on the subscription.
	// (Only available for accounts that have migrated off of legacy subscription
	// overrides)
	ReplaceAdjustments param.Field[[]shared.ReplaceSubscriptionAdjustmentParams] `json:"replace_adjustments"`
	// Plan prices to be replaced with additional prices on the subscription. (Only
	// available for accounts that have migrated off of legacy subscription overrides)
	ReplacePrices param.Field[[]shared.ReplaceSubscriptionPriceParams] `json:"replace_prices"`
	// The duration of the trial period in days. If not provided, this defaults to the
	// value specified in the plan. If `0` is provided, the trial on the plan will be
	// skipped.
	TrialDurationDays param.Field[int64] `json:"trial_duration_days"`
	// A list of customer IDs whose usage events will be aggregated and billed under
	// this subscription. By default, a subscription only considers usage events
	// associated with its attached customer's customer_id. When usage_customer_ids is
	// provided, the subscription includes usage events from the specified customers
	// only. Provided usage_customer_ids must be either the customer for this
	// subscription itself, or any of that customer's children.
	UsageCustomerIDs param.Field[[]string] `json:"usage_customer_ids"`
}

func (r SubscriptionSchedulePlanChangeParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsChangeOption string

const (
	SubscriptionSchedulePlanChangeParamsChangeOptionRequestedDate         SubscriptionSchedulePlanChangeParamsChangeOption = "requested_date"
	SubscriptionSchedulePlanChangeParamsChangeOptionEndOfSubscriptionTerm SubscriptionSchedulePlanChangeParamsChangeOption = "end_of_subscription_term"
	SubscriptionSchedulePlanChangeParamsChangeOptionImmediate             SubscriptionSchedulePlanChangeParamsChangeOption = "immediate"
)

func (r SubscriptionSchedulePlanChangeParamsChangeOption) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsChangeOptionRequestedDate, SubscriptionSchedulePlanChangeParamsChangeOptionEndOfSubscriptionTerm, SubscriptionSchedulePlanChangeParamsChangeOptionImmediate:
		return true
	}
	return false
}

// Reset billing periods to be aligned with the plan change's effective date or
// start of the month. Defaults to `unchanged` which keeps subscription's existing
// billing cycle alignment.
type SubscriptionSchedulePlanChangeParamsBillingCycleAlignment string

const (
	SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentUnchanged      SubscriptionSchedulePlanChangeParamsBillingCycleAlignment = "unchanged"
	SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentPlanChangeDate SubscriptionSchedulePlanChangeParamsBillingCycleAlignment = "plan_change_date"
	SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentStartOfMonth   SubscriptionSchedulePlanChangeParamsBillingCycleAlignment = "start_of_month"
)

func (r SubscriptionSchedulePlanChangeParamsBillingCycleAlignment) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentUnchanged, SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentPlanChangeDate, SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentStartOfMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day param.Field[int64] `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month param.Field[int64] `json:"month"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year param.Field[int64] `json:"year"`
}

func (r SubscriptionSchedulePlanChangeParamsBillingCycleAnchorConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionTriggerPhaseParams struct {
	// If false, this request will fail if it would void an issued invoice or create a
	// credit note. Consider using this as a safety mechanism if you do not expect
	// existing invoices to be changed.
	AllowInvoiceCreditOrVoid param.Field[bool] `json:"allow_invoice_credit_or_void"`
	// The date on which the phase change should take effect. If not provided, defaults
	// to today in the customer's timezone.
	EffectiveDate param.Field[time.Time] `json:"effective_date" format:"date"`
}

func (r SubscriptionTriggerPhaseParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesParams struct {
	// Price for which the updates should be cleared. Must be a fixed fee.
	PriceID param.Field[string] `json:"price_id,required"`
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionUpdateFixedFeeQuantityParams struct {
	// Price for which the quantity should be updated. Must be a fixed fee.
	PriceID  param.Field[string]  `json:"price_id,required"`
	Quantity param.Field[float64] `json:"quantity,required"`
	// If false, this request will fail if it would void an issued invoice or create a
	// credit note. Consider using this as a safety mechanism if you do not expect
	// existing invoices to be changed.
	AllowInvoiceCreditOrVoid param.Field[bool] `json:"allow_invoice_credit_or_void"`
	// Determines when the change takes effect. Note that if `effective_date` is
	// specified, this defaults to `effective_date`. Otherwise, this defaults to
	// `immediate` unless it's explicitly set to `upcoming_invoice`.
	ChangeOption param.Field[SubscriptionUpdateFixedFeeQuantityParamsChangeOption] `json:"change_option"`
	// The date that the quantity change should take effect, localized to the
	// customer's timezone. Ifthis parameter is not passed in, the quantity change is
	// effective according to `change_option`.
	EffectiveDate param.Field[time.Time] `json:"effective_date" format:"date"`
}

func (r SubscriptionUpdateFixedFeeQuantityParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// Determines when the change takes effect. Note that if `effective_date` is
// specified, this defaults to `effective_date`. Otherwise, this defaults to
// `immediate` unless it's explicitly set to `upcoming_invoice`.
type SubscriptionUpdateFixedFeeQuantityParamsChangeOption string

const (
	SubscriptionUpdateFixedFeeQuantityParamsChangeOptionImmediate       SubscriptionUpdateFixedFeeQuantityParamsChangeOption = "immediate"
	SubscriptionUpdateFixedFeeQuantityParamsChangeOptionUpcomingInvoice SubscriptionUpdateFixedFeeQuantityParamsChangeOption = "upcoming_invoice"
	SubscriptionUpdateFixedFeeQuantityParamsChangeOptionEffectiveDate   SubscriptionUpdateFixedFeeQuantityParamsChangeOption = "effective_date"
)

func (r SubscriptionUpdateFixedFeeQuantityParamsChangeOption) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityParamsChangeOptionImmediate, SubscriptionUpdateFixedFeeQuantityParamsChangeOptionUpcomingInvoice, SubscriptionUpdateFixedFeeQuantityParamsChangeOptionEffectiveDate:
		return true
	}
	return false
}

type SubscriptionUpdateTrialParams struct {
	// The new date that the trial should end, or the literal string `immediate` to end
	// the trial immediately.
	TrialEndDate param.Field[SubscriptionUpdateTrialParamsTrialEndDateUnion] `json:"trial_end_date,required" format:"date-time"`
	// If true, shifts subsequent price and adjustment intervals (preserving their
	// durations, but adjusting their absolute dates).
	Shift param.Field[bool] `json:"shift"`
}

func (r SubscriptionUpdateTrialParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The new date that the trial should end, or the literal string `immediate` to end
// the trial immediately.
//
// Satisfied by [shared.UnionTime],
// [SubscriptionUpdateTrialParamsTrialEndDateString].
type SubscriptionUpdateTrialParamsTrialEndDateUnion interface {
	ImplementsSubscriptionUpdateTrialParamsTrialEndDateUnion()
}

type SubscriptionUpdateTrialParamsTrialEndDateString string

const (
	SubscriptionUpdateTrialParamsTrialEndDateStringImmediate SubscriptionUpdateTrialParamsTrialEndDateString = "immediate"
)

func (r SubscriptionUpdateTrialParamsTrialEndDateString) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialParamsTrialEndDateStringImmediate:
		return true
	}
	return false
}

func (r SubscriptionUpdateTrialParamsTrialEndDateString) ImplementsSubscriptionUpdateTrialParamsTrialEndDateUnion() {
}
