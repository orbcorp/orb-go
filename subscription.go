// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

package orb

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"reflect"
	"time"

	"github.com/orbcorp/orb-go/internal/apijson"
	"github.com/orbcorp/orb-go/internal/apiquery"
	"github.com/orbcorp/orb-go/internal/param"
	"github.com/orbcorp/orb-go/internal/requestconfig"
	"github.com/orbcorp/orb-go/option"
	"github.com/orbcorp/orb-go/packages/pagination"
	"github.com/orbcorp/orb-go/shared"
	"github.com/tidwall/gjson"
)

// SubscriptionService contains methods and other services that help with
// interacting with the orb API.
//
// Note, unlike clients, this service does not read variables from the environment
// automatically. You should not instantiate this service directly, and instead use
// the [NewSubscriptionService] method instead.
type SubscriptionService struct {
	Options []option.RequestOption
}

// NewSubscriptionService generates a new service that applies the given options to
// each request. These options are applied after the parent client's options (if
// there is one), and before any request-specific options.
func NewSubscriptionService(opts ...option.RequestOption) (r *SubscriptionService) {
	r = &SubscriptionService{}
	r.Options = opts
	return
}

// A subscription represents the purchase of a plan by a customer. The customer is
// identified by either the `customer_id` or the `external_customer_id`, and
// exactly one of these fields must be provided.
//
// By default, subscriptions begin on the day that they're created and renew
// automatically for each billing cycle at the cadence that's configured in the
// plan definition.
//
// The default configuration for subscriptions in Orb is **In-advance billing** and
// **Beginning of month alignment** (see
// [Subscription](../guides/concepts#subscription) for more details).
//
// In order to change the alignment behavior, Orb also supports billing
// subscriptions on the day of the month they are created. If
// `align_billing_with_subscription_start_date = true` is specified, subscriptions
// have billing cycles that are aligned with their `start_date`. For example, a
// subscription that begins on January 15th will have a billing cycle from January
// 15th to February 15th. Every subsequent billing cycle will continue to start and
// invoice on the 15th.
//
// If the "day" value is greater than the number of days in the month, the next
// billing cycle will start at the end of the month. For example, if the start_date
// is January 31st, the next billing cycle will start on February 28th.
//
// If a customer was created with a currency, Orb only allows subscribing the
// customer to a plan with a matching `invoicing_currency`. If the customer does
// not have a currency set, on subscription creation, we set the customer's
// currency to be the `invoicing_currency` of the plan.
//
// ## Customize your customer's subscriptions
//
// Prices and adjustments in a plan can be added, removed, or replaced for the
// subscription being created. This is useful when a customer has prices that
// differ from the default prices for a specific plan.
//
// :::info This feature is only available for accounts that have migrated to
// Subscription Overrides Version 2. You can find your Subscription Overrides
// Version at the bottom of your [Plans page](https://app.withorb.com/plans) :::
//
// ### Adding Prices
//
// To add prices, provide a list of objects with the key `add_prices`. An object in
// the list must specify an existing add-on price with a `price_id` or
// `external_price_id` field, or create a new add-on price by including an object
// with the key `price`, identical to what would be used in the request body for
// the [create price endpoint](../reference/create-price). See the
// [Price resource](../reference/price) for the specification of different price
// model configurations possible in this object.
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the price should be added to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. This is equivalent to creating a price interval with the
// [add/edit price intervals endpoint](../reference/add-edit-price-intervals). If
// unspecified, the start or end date of the phase or subscription will be used.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference this price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Removing Prices
//
// To remove prices, provide a list of objects with the key `remove_prices`. An
// object in the list must specify a plan price with either a `price_id` or
// `external_price_id` field.
//
// ### Replacing Prices
//
// To replace prices, provide a list of objects with the key `replace_prices`. An
// object in the list must specify a plan price to replace with the
// `replaces_price_id` key, and it must specify a price to replace it with by
// either referencing an existing add-on price with a `price_id` or
// `external_price_id` field, or by creating a new add-on price by including an
// object with the key `price`, identical to what would be used in the request body
// for the [create price endpoint](../reference/create-price). See the
// [Price resource](../reference/price) for the specification of different price
// model configurations possible in this object.
//
// For fixed fees, an object in the list can supply a `fixed_price_quantity`
// instead of a `price`, `price_id`, or `external_price_id` field. This will update
// only the quantity for the price, similar to the
// [Update price quantity](../reference/update-fixed-fee-quantity) endpoint.
//
// The replacement price will have the same phase, if applicable, and the same
// start and end dates as the price it replaces.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference the replacement price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Adding adjustments
//
// To add adjustments, provide a list of objects with the key `add_adjustments`. An
// object in the list must include an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](../reference/add-edit-price-intervals).
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the adjustment should be added
// to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. If unspecified, the start or end date of the phase or subscription
// will be used.
//
// ### Removing adjustments
//
// To remove adjustments, provide a list of objects with the key
// `remove_adjustments`. An object in the list must include a key, `adjustment_id`,
// with the ID of the adjustment to be removed.
//
// ### Replacing adjustments
//
// To replace adjustments, provide a list of objects with the key
// `replace_adjustments`. An object in the list must specify a plan adjustment to
// replace with the `replaces_adjustment_id` key, and it must specify an adjustment
// to replace it with by including an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](../reference/add-edit-price-intervals).
//
// The replacement adjustment will have the same phase, if applicable, and the same
// start and end dates as the adjustment it replaces.
//
// ## Price overrides (DEPRECATED)
//
// :::info Price overrides are being phased out in favor adding/removing/replacing
// prices. (See
// [Customize your customer's subscriptions](../reference/create-subscription#customize-your-customers-subscriptions))
// :::
//
// Price overrides are used to update some or all prices in a plan for the specific
// subscription being created. This is useful when a new customer has negotiated a
// rate that is unique to the customer.
//
// To override prices, provide a list of objects with the key `price_overrides`.
// The price object in the list of overrides is expected to contain the existing
// price id, the `model_type` and configuration. (See the
// [Price resource](../reference/price) for the specification of different price
// model configurations.) The numerical values can be updated, but the billable
// metric, cadence, type, and name of a price can not be overridden.
//
// ### Maximums and Minimums
//
// Minimums and maximums, much like price overrides, can be useful when a new
// customer has negotiated a new or different minimum or maximum spend cap than the
// default for a given price. If one exists for a price and null is provided for
// the minimum/maximum override on creation, then there will be no minimum/maximum
// on the new subscription. If no value is provided, then the default price maximum
// or minimum is used.
//
// To add a minimum for a specific price, add `minimum_amount` to the specific
// price in the `price_overrides` object.
//
// To add a maximum for a specific price, add `maximum_amount` to the specific
// price in the `price_overrides` object.
//
// ### Minimum override example
//
// Price minimum override example:
//
// ```json
//
//	{
//	  ...
//	  "id": "price_id",
//	  "model_type": "unit",
//	  "unit_config": {
//	    "unit_amount": "0.50"
//	  },
//	  "minimum_amount": "100.00"
//	  ...
//	}
//
// ```
//
// # Removing an existing minimum example
//
// ```json
//
//	{
//	  ...
//	  "id": "price_id",
//	  "model_type": "unit",
//	  "unit_config": {
//	    "unit_amount": "0.50"
//	  },
//	  "minimum_amount": null
//	  ...
//	}
//
// ```
//
// ### Discounts
//
// Discounts, like price overrides, can be useful when a new customer has
// negotiated a new or different discount than the default for a price. If a
// discount exists for a price and a null discount is provided on creation, then
// there will be no discount on the new subscription.
//
// To add a discount for a specific price, add `discount` to the price in the
// `price_overrides` object. Discount should be a dictionary of the format:
//
// ```ts
//
//	{
//	  "discount_type": "amount" | "percentage" | "usage",
//	  "amount_discount": string,
//	  "percentage_discount": string,
//	  "usage_discount": string
//	}
//
// ```
//
// where either `amount_discount`, `percentage_discount`, or `usage_discount` is
// provided.
//
// # Price discount example
//
// ```json
//
//	{
//	  ...
//	  "id": "price_id",
//	  "model_type": "unit",
//	  "unit_config": {
//	    "unit_amount": "0.50"
//	  },
//	  "discount": {"discount_type": "amount", "amount_discount": "175"},
//	}
//
// ```
//
// # Removing an existing discount example
//
// ```json
//
//	{
//	  "customer_id": "customer_id",
//	  "plan_id": "plan_id",
//	  "discount": null,
//	  "price_overrides": [ ... ]
//	  ...
//	}
//
// ```
//
// ## Threshold Billing
//
// Orb supports invoicing for a subscription when a preconfigured usage threshold
// is hit. To enable threshold billing, pass in an `invoicing_threshold`, which is
// specified in the subscription's invoicing currency, when creating a
// subscription. E.g. pass in `10.00` to issue an invoice when usage amounts hit
// $10.00 for a subscription that invoices in USD.
func (r *SubscriptionService) New(ctx context.Context, body SubscriptionNewParams, opts ...option.RequestOption) (res *SubscriptionNewResponse, err error) {
	opts = append(r.Options[:], opts...)
	path := "subscriptions"
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to update the `metadata`, `net terms`,
// `auto_collection`, `invoicing_threshold`, and `default_invoice_memo` properties
// on a subscription.
func (r *SubscriptionService) Update(ctx context.Context, subscriptionID string, body SubscriptionUpdateParams, opts ...option.RequestOption) (res *Subscription, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPut, path, body, &res, opts...)
	return
}

// This endpoint returns a list of all subscriptions for an account as a
// [paginated](../reference/pagination) list, ordered starting from the most
// recently created subscription. For a full discussion of the subscription
// resource, see [Subscription](../guides/concepts#subscription).
//
// Subscriptions can be filtered for a specific customer by using either the
// customer_id or external_customer_id query parameters. To filter subscriptions
// for multiple customers, use the customer_id[] or external_customer_id[] query
// parameters.
func (r *SubscriptionService) List(ctx context.Context, query SubscriptionListParams, opts ...option.RequestOption) (res *pagination.Page[Subscription], err error) {
	var raw *http.Response
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithResponseInto(&raw)}, opts...)
	path := "subscriptions"
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodGet, path, query, &res, opts...)
	if err != nil {
		return nil, err
	}
	err = cfg.Execute()
	if err != nil {
		return nil, err
	}
	res.SetPageConfig(cfg, raw)
	return res, nil
}

// This endpoint returns a list of all subscriptions for an account as a
// [paginated](../reference/pagination) list, ordered starting from the most
// recently created subscription. For a full discussion of the subscription
// resource, see [Subscription](../guides/concepts#subscription).
//
// Subscriptions can be filtered for a specific customer by using either the
// customer_id or external_customer_id query parameters. To filter subscriptions
// for multiple customers, use the customer_id[] or external_customer_id[] query
// parameters.
func (r *SubscriptionService) ListAutoPaging(ctx context.Context, query SubscriptionListParams, opts ...option.RequestOption) *pagination.PageAutoPager[Subscription] {
	return pagination.NewPageAutoPager(r.List(ctx, query, opts...))
}

// This endpoint can be used to cancel an existing subscription. It returns the
// serialized subscription object with an `end_date` parameter that signifies when
// the subscription will transition to an ended state.
//
// The body parameter `cancel_option` determines the cancellation behavior. Orb
// supports three cancellation options:
//
//   - `end_of_subscription_term`: stops the subscription from auto-renewing.
//     Subscriptions that have been cancelled with this option can still incur
//     charges for the remainder of their term:
//
//   - Issuing this cancellation request for a monthly subscription will keep the
//     subscription active until the start of the subsequent month, and potentially
//     issue an invoice for any usage charges incurred in the intervening period.
//
//   - Issuing this cancellation request for a quarterly subscription will keep the
//     subscription active until the end of the quarter and potentially issue an
//     invoice for any usage charges incurred in the intervening period.
//
//   - Issuing this cancellation request for a yearly subscription will keep the
//     subscription active for the full year. For example, a yearly subscription
//     starting on 2021-11-01 and cancelled on 2021-12-08 will remain active until
//     2022-11-01 and potentially issue charges in the intervening months for any
//     recurring monthly usage charges in its plan.
//
//   - **Note**: If a subscription's plan contains prices with difference cadences,
//     the end of term date will be determined by the largest cadence value. For
//     example, cancelling end of term for a subscription with a quarterly fixed
//     fee with a monthly usage fee will result in the subscription ending at the
//     end of the quarter.
//
//   - `immediate`: ends the subscription immediately, setting the `end_date` to the
//     current time:
//
//   - Subscriptions that have been cancelled with this option will be invoiced
//     immediately. This invoice will include any usage fees incurred in the
//     billing period up to the cancellation, along with any prorated recurring
//     fees for the billing period, if applicable.
//
//   - **Note**: If the subscription has a recurring fee that was paid in-advance,
//     the prorated amount for the remaining time period will be added to the
//     [customer's balance](list-balance-transactions) upon immediate cancellation.
//     However, if the customer is ineligible to use the customer balance, the
//     subscription cannot be cancelled immediately.
//
//   - `requested_date`: ends the subscription on a specified date, which requires a
//     `cancellation_date` to be passed in. If no timezone is provided, the
//     customer's timezone is used. For example, a subscription starting on January
//     1st with a monthly price can be set to be cancelled on the first of any month
//     after January 1st (e.g. March 1st, April 1st, May 1st). A subscription with
//     multiple prices with different cadences defines the "term" to be the highest
//     cadence of the prices.
//
// Upcoming subscriptions are only eligible for immediate cancellation, which will
// set the `end_date` equal to the `start_date` upon cancellation.
//
// ## Backdated cancellations
//
// Orb allows you to cancel a subscription in the past as long as there are no paid
// invoices between the `requested_date` and the current time. If the cancellation
// is after the latest issued invoice, Orb will generate a balance refund for the
// current period. If the cancellation is before the most recently issued invoice,
// Orb will void the intervening invoice and generate a new one based on the new
// dates for the subscription. See the section on
// [cancellation behaviors](../guides/product-catalog/creating-subscriptions.md#cancellation-behaviors).
func (r *SubscriptionService) Cancel(ctx context.Context, subscriptionID string, body SubscriptionCancelParams, opts ...option.RequestOption) (res *SubscriptionCancelResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/cancel", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint is used to fetch a [Subscription](../guides/concepts#subscription)
// given an identifier.
func (r *SubscriptionService) Fetch(ctx context.Context, subscriptionID string, opts ...option.RequestOption) (res *Subscription, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, nil, &res, opts...)
	return
}

// This endpoint is used to fetch a day-by-day snapshot of a subscription's costs
// in Orb, calculated by applying pricing information to the underlying usage (see
// the [subscription usage endpoint](fetch-subscription-usage) to fetch usage per
// metric, in usage units rather than a currency).
//
// The semantics of this endpoint exactly mirror those of
// [fetching a customer's costs](fetch-customer-costs). Use this endpoint to limit
// your analysis of costs to a specific subscription for the customer (e.g. to
// de-aggregate costs when a customer's subscription has started and stopped on the
// same day).
func (r *SubscriptionService) FetchCosts(ctx context.Context, subscriptionID string, query SubscriptionFetchCostsParams, opts ...option.RequestOption) (res *SubscriptionFetchCostsResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/costs", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, query, &res, opts...)
	return
}

// This endpoint returns a [paginated](../reference/pagination) list of all plans
// associated with a subscription along with their start and end dates. This list
// contains the subscription's initial plan along with past and future plan
// changes.
func (r *SubscriptionService) FetchSchedule(ctx context.Context, subscriptionID string, query SubscriptionFetchScheduleParams, opts ...option.RequestOption) (res *pagination.Page[SubscriptionFetchScheduleResponse], err error) {
	var raw *http.Response
	opts = append(r.Options[:], opts...)
	opts = append([]option.RequestOption{option.WithResponseInto(&raw)}, opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/schedule", subscriptionID)
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodGet, path, query, &res, opts...)
	if err != nil {
		return nil, err
	}
	err = cfg.Execute()
	if err != nil {
		return nil, err
	}
	res.SetPageConfig(cfg, raw)
	return res, nil
}

// This endpoint returns a [paginated](../reference/pagination) list of all plans
// associated with a subscription along with their start and end dates. This list
// contains the subscription's initial plan along with past and future plan
// changes.
func (r *SubscriptionService) FetchScheduleAutoPaging(ctx context.Context, subscriptionID string, query SubscriptionFetchScheduleParams, opts ...option.RequestOption) *pagination.PageAutoPager[SubscriptionFetchScheduleResponse] {
	return pagination.NewPageAutoPager(r.FetchSchedule(ctx, subscriptionID, query, opts...))
}

// This endpoint is used to fetch a subscription's usage in Orb. Especially when
// combined with optional query parameters, this endpoint is a powerful way to
// build visualizations on top of Orb's event data and metrics.
//
// With no query parameters specified, this endpoint returns usage for the
// subscription's _current billing period_ across each billable metric that
// participates in the subscription. Usage quantities returned are the result of
// evaluating the metric definition for the entirety of the customer's billing
// period.
//
// ### Default response shape
//
// Orb returns a `data` array with an object corresponding to each billable metric.
// Nested within this object is a `usage` array which has a `quantity` value and a
// corresponding `timeframe_start` and `timeframe_end`. The `quantity` value
// represents the calculated usage value for the billable metric over the specified
// timeframe (inclusive of the `timeframe_start` timestamp and exclusive of the
// `timeframe_end` timestamp).
//
// Orb will include _every_ window in the response starting from the beginning of
// the billing period, even when there were no events (and therefore no usage) in
// the window. This increases the size of the response but prevents the caller from
// filling in gaps and handling cumbersome time-based logic.
//
// The query parameters in this endpoint serve to override this behavior and
// provide some key functionality, as listed below. Note that this functionality
// can also be used _in conjunction_ with each other, e.g. to display grouped usage
// on a custom timeframe.
//
// ## Custom timeframe
//
// In order to view usage for a custom timeframe rather than the current billing
// period, specify a `timeframe_start` and `timeframe_end`. This will calculate
// quantities for usage incurred between timeframe_start (inclusive) and
// timeframe_end (exclusive), i.e. `[timeframe_start, timeframe_end)`.
//
// Note:
//
//   - These timestamps must be specified in ISO 8601 format and UTC timezone, e.g.
//     `2022-02-01T05:00:00Z`.
//   - Both parameters must be specified if either is specified.
//
// ## Grouping by custom attributes
//
// In order to view a single metric grouped by a specific _attribute_ that each
// event is tagged with (e.g. `cluster`), you must additionally specify a
// `billable_metric_id` and a `group_by` key. The `group_by` key denotes the event
// property on which to group.
//
// When returning grouped usage, only usage for `billable_metric_id` is returned,
// and a separate object in the `data` array is returned for each value of the
// `group_by` key present in your events. The `quantity` value is the result of
// evaluating the billable metric for events filtered to a single value of the
// `group_by` key.
//
// Orb expects that events that match the billable metric will contain values in
// the `properties` dictionary that correspond to the `group_by` key specified. By
// default, Orb will not return a `null` group (i.e. events that match the metric
// but do not have the key set). Currently, it is only possible to view usage
// grouped by a single attribute at a time.
//
// When viewing grouped usage, Orb uses pagination to limit the response size to
// 1000 groups by default. If there are more groups for a given subscription,
// pagination metadata in the response can be used to fetch all of the data.
//
// The following example shows usage for an "API Requests" billable metric grouped
// by `region`. Note the extra `metric_group` dictionary in the response, which
// provides metadata about the group:
//
// ```json
//
//	{
//	    "data": [
//	        {
//	            "usage": [
//	                {
//	                    "quantity": 0.19291,
//	                    "timeframe_start": "2021-10-01T07:00:00Z",
//	                    "timeframe_end": "2021-10-02T07:00:00Z",
//	                },
//	                ...
//	            ],
//	            "metric_group": {
//	                "property_key": "region",
//	                "property_value": "asia/pacific"
//	            },
//	            "billable_metric": {
//	                "id": "Fe9pbpMk86xpwdGB",
//	                "name": "API Requests"
//	            },
//	            "view_mode": "periodic"
//	        },
//	        ...
//	    ]
//	}
//
// ```
//
// ## Windowed usage
//
// The `granularity` parameter can be used to _window_ the usage `quantity` value
// into periods. When not specified, usage is returned for the entirety of the time
// range.
//
// When `granularity = day` is specified with a timeframe longer than a day, Orb
// will return a `quantity` value for each full day between `timeframe_start` and
// `timeframe_end`. Note that the days are demarcated by the _customer's local
// midnight_.
//
// For example, with `timeframe_start = 2022-02-01T05:00:00Z`,
// `timeframe_end = 2022-02-04T01:00:00Z` and `granularity=day`, the following
// windows will be returned for a customer in the `America/Los_Angeles` timezone
// since local midnight is `08:00` UTC:
//
// - `[2022-02-01T05:00:00Z, 2022-02-01T08:00:00Z)`
// - `[2022-02-01T08:00:00, 2022-02-02T08:00:00Z)`
// - `[2022-02-02T08:00:00, 2022-02-03T08:00:00Z)`
// - `[2022-02-03T08:00:00, 2022-02-04T01:00:00Z)`
//
// ```json
//
//	{
//	    "data": [
//	        {
//	            "billable_metric": {
//	                "id": "Q8w89wjTtBdejXKsm",
//	                "name": "API Requests"
//	            },
//	            "usage": [
//	                {
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-01T08:00:00+00:00",
//	                    "timeframe_start": "2022-02-01T05:00:00+00:00"
//	                },
//	                {
//
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-02T08:00:00+00:00",
//	                    "timeframe_start": "2022-02-01T08:00:00+00:00"
//	                },
//	                {
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-03T08:00:00+00:00",
//	                    "timeframe_start": "2022-02-02T08:00:00+00:00"
//	                },
//	                {
//	                    "quantity": 0,
//	                    "timeframe_end": "2022-02-04T01:00:00+00:00",
//	                    "timeframe_start": "2022-02-03T08:00:00+00:00"
//	                }
//	            ],
//	            "view_mode": "periodic"
//	        },
//	        ...
//	    ]
//	}
//
// ```
//
// ## Decomposable vs. non-decomposable metrics
//
// Billable metrics fall into one of two categories: decomposable and
// non-decomposable. A decomposable billable metric, such as a sum or a count, can
// be displayed and aggregated across arbitrary timescales. On the other hand, a
// non-decomposable metric is not meaningful when only a slice of the billing
// window is considered.
//
// As an example, if we have a billable metric that's defined to count unique
// users, displaying a graph of unique users for each day is not representative of
// the billable metric value over the month (days could have an overlapping set of
// 'unique' users). Instead, what's useful for any given day is the number of
// unique users in the billing period so far, which are the _cumulative_ unique
// users.
//
// Accordingly, this endpoint returns treats these two types of metrics differently
// when `group_by` is specified:
//
//   - Decomposable metrics can be grouped by any event property.
//   - Non-decomposable metrics can only be grouped by the corresponding price's
//     invoice grouping key. If no invoice grouping key is present, the metric does
//     not support `group_by`.
//
// ## Matrix prices
//
// When a billable metric is attached to a price that uses matrix pricing, it's
// important to view usage grouped by those matrix dimensions. In this case, use
// the query parameters `first_dimension_key`, `first_dimension_value` and
// `second_dimension_key`, `second_dimension_value` while filtering to a specific
// `billable_metric_id`.
//
// For example, if your compute metric has a separate unit price (i.e. a matrix
// pricing model) per `region` and `provider`, your request might provide the
// following parameters:
//
// - `first_dimension_key`: `region`
// - `first_dimension_value`: `us-east-1`
// - `second_dimension_key`: `provider`
// - `second_dimension_value`: `aws`
func (r *SubscriptionService) FetchUsage(ctx context.Context, subscriptionID string, query SubscriptionFetchUsageParams, opts ...option.RequestOption) (res *SubscriptionUsage, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/usage", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodGet, path, query, &res, opts...)
	return
}

// This endpoint is used to add and edit subscription
// [price intervals](../reference/price-interval). By making modifications to a
// subscription’s price intervals, you can
// [flexibly and atomically control the billing behavior of a subscription](../guides/product-catalog/modifying-subscriptions).
//
// ## Adding price intervals
//
// Prices can be added as price intervals to a subscription by specifying them in
// the `add` array. A `price_id` or `external_price_id` from an add-on price or
// previously removed plan price can be specified to reuse an existing price
// definition (however, please note that prices from other plans cannot be added to
// the subscription). Additionally, a new price can be specified using the `price`
// field — this price will be created automatically.
//
// A `start_date` must be specified for the price interval. This is the date when
// the price will start billing on the subscription, so this will notably result in
// an immediate charge at this time for any billed in advance fixed fees. The
// `end_date` will default to null, resulting in a price interval that will bill on
// a continually recurring basis. Both of these dates can be set in the past or the
// future and Orb will generate or modify invoices to ensure the subscription’s
// invoicing behavior is correct.
//
// Additionally, a discount, minimum, or maximum can be specified on the price
// interval. This will only apply to this price interval, not any other price
// intervals on the subscription.
//
// ## Adjustment intervals
//
// An adjustment interval represents the time period that a particular adjustment
// (a discount, minimum, or maximum) applies to the prices on a subscription.
// Adjustment intervals can be added to a subscription by specifying them in the
// `add_adjustments` array, or modified via the `edit_adjustments` array. When
// creating an adjustment interval, you'll need to provide the definition of the
// new adjustment (the type of adjustment, and which prices it applies to), as well
// as the start and end dates for the adjustment interval. The start and end dates
// of an existing adjustment interval can be edited via the `edit_adjustments`
// field (just like price intervals). (To "change" the amount of a discount,
// minimum, or maximum, then, you'll need to end the existing interval, and create
// a new adjustment interval with the new amount and a start date that matches the
// end date of the previous interval.)
//
// ## Editing price intervals
//
// Price intervals can be adjusted by specifying edits to make in the `edit` array.
// A `price_interval_id` to edit must be specified — this can be retrieved from the
// `price_intervals` field on the subscription.
//
// A new `start_date` or `end_date` can be specified to change the range of the
// price interval, which will modify past or future invoices to ensure correctness.
// If either of these dates are unspecified, they will default to the existing date
// on the price interval. To remove a price interval entirely from a subscription,
// set the `end_date` to be equivalent to the `start_date`.
//
// ## Fixed fee quantity transitions
//
// The fixed fee quantity transitions for a fixed fee price interval can also be
// specified when adding or editing by passing an array for
// `fixed_fee_quantity_transitions`. A fixed fee quantity transition must have a
// `quantity` and an `effective_date`, which is the date after which the new
// quantity will be used for billing. If a fixed fee quantity transition is
// scheduled at a billing period boundary, the full quantity will be billed on an
// invoice with the other prices on the subscription. If the fixed fee quantity
// transition is scheduled mid-billing period, the difference between the existing
// quantity and quantity specified in the transition will be prorated for the rest
// of the billing period and billed immediately, which will generate a new invoice.
//
// Notably, the list of fixed fee quantity transitions passed will overwrite the
// existing fixed fee quantity transitions on the price interval, so the entire
// list of transitions must be specified to add additional transitions. The
// existing list of transitions can be retrieved using the
// `fixed_fee_quantity_transitions` property on a subscription’s serialized price
// intervals.
func (r *SubscriptionService) PriceIntervals(ctx context.Context, subscriptionID string, body SubscriptionPriceIntervalsParams, opts ...option.RequestOption) (res *SubscriptionPriceIntervalsResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/price_intervals", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to change an existing subscription's plan. It returns
// the serialized updated subscription object.
//
// The body parameter `change_option` determines when the plan change occurrs. Orb
// supports three options:
//
//   - `end_of_subscription_term`: changes the plan at the end of the existing plan's
//     term.
//   - Issuing this plan change request for a monthly subscription will keep the
//     existing plan active until the start of the subsequent month. Issuing this
//     plan change request for a yearly subscription will keep the existing plan
//     active for the full year. Charges incurred in the remaining period will be
//     invoiced as normal.
//   - Example: The plan is billed monthly on the 1st of the month, the request is
//     made on January 15th, so the plan will be changed on February 1st, and
//     invoice will be issued on February 1st for the last month of the original
//     plan.
//   - `immediate`: changes the plan immediately.
//   - Subscriptions that have their plan changed with this option will move to the
//     new plan immediately, and be invoiced immediately.
//   - This invoice will include any usage fees incurred in the billing period up
//     to the change, along with any prorated recurring fees for the billing
//     period, if applicable.
//   - Example: The plan is billed monthly on the 1st of the month, the request is
//     made on January 15th, so the plan will be changed on January 15th, and an
//     invoice will be issued for the partial month, from January 1 to January 15,
//     on the original plan.
//   - `requested_date`: changes the plan on the requested date (`change_date`).
//   - If no timezone is provided, the customer's timezone is used. The
//     `change_date` body parameter is required if this option is chosen.
//   - Example: The plan is billed monthly on the 1st of the month, the request is
//     made on January 15th, with a requested `change_date` of February 15th, so
//     the plan will be changed on February 15th, and invoices will be issued on
//     February 1st and February 15th.
//
// Note that one of `plan_id` or `external_plan_id` is required in the request body
// for this operation.
//
// ## Customize your customer's subscriptions
//
// Prices and adjustments in a plan can be added, removed, or replaced on the
// subscription when you schedule the plan change. This is useful when a customer
// has prices that differ from the default prices for a specific plan.
//
// :::info This feature is only available for accounts that have migrated to
// Subscription Overrides Version 2. You can find your Subscription Overrides
// Version at the bottom of your [Plans page](https://app.withorb.com/plans) :::
//
// ### Adding Prices
//
// To add prices, provide a list of objects with the key `add_prices`. An object in
// the list must specify an existing add-on price with a `price_id` or
// `external_price_id` field, or create a new add-on price by including an object
// with the key `price`, identical to what would be used in the request body for
// the [create price endpoint](../reference/create-price). See the
// [Price resource](../reference/price) for the specification of different price
// model configurations possible in this object.
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the price should be added to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. This is equivalent to creating a price interval with the
// [add/edit price intervals endpoint](../reference/add-edit-price-intervals). If
// unspecified, the start or end date of the phase or subscription will be used.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference this price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Removing Prices
//
// To remove prices, provide a list of objects with the key `remove_prices`. An
// object in the list must specify a plan price with either a `price_id` or
// `external_price_id` field.
//
// ### Replacing Prices
//
// To replace prices, provide a list of objects with the key `replace_prices`. An
// object in the list must specify a plan price to replace with the
// `replaces_price_id` key, and it must specify a price to replace it with by
// either referencing an existing add-on price with a `price_id` or
// `external_price_id` field, or by creating a new add-on price by including an
// object with the key `price`, identical to what would be used in the request body
// for the [create price endpoint](../reference/create-price). See the
// [Price resource](../reference/price) for the specification of different price
// model configurations possible in this object.
//
// For fixed fees, an object in the list can supply a `fixed_price_quantity`
// instead of a `price`, `price_id`, or `external_price_id` field. This will update
// only the quantity for the price, similar to the
// [Update price quantity](../reference/update-fixed-fee-quantity) endpoint.
//
// The replacement price will have the same phase, if applicable, and the same
// start and end dates as the price it replaces.
//
// An object in the list can specify an optional `minimum_amount`,
// `maximum_amount`, or `discounts`. This will create adjustments which apply only
// to this price.
//
// Additionally, an object in the list can specify an optional `reference_id`. This
// ID can be used to reference the replacement price when
// [adding an adjustment](#adding-adjustments) in the same API call. However the ID
// is _transient_ and cannot be used to refer to the price in future API calls.
//
// ### Adding adjustments
//
// To add adjustments, provide a list of objects with the key `add_adjustments`. An
// object in the list must include an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](../reference/add-edit-price-intervals).
//
// If the plan has phases, each object in the list must include a number with
// `plan_phase_order` key to indicate which phase the adjustment should be added
// to.
//
// An object in the list can specify an optional `start_date` and optional
// `end_date`. If unspecified, the start or end date of the phase or subscription
// will be used.
//
// ### Removing adjustments
//
// To remove adjustments, provide a list of objects with the key
// `remove_adjustments`. An object in the list must include a key, `adjustment_id`,
// with the ID of the adjustment to be removed.
//
// ### Replacing adjustments
//
// To replace adjustments, provide a list of objects with the key
// `replace_adjustments`. An object in the list must specify a plan adjustment to
// replace with the `replaces_adjustment_id` key, and it must specify an adjustment
// to replace it with by including an object with the key `adjustment`, identical
// to the adjustment object in the
// [add/edit price intervals endpoint](../reference/add-edit-price-intervals).
//
// The replacement adjustment will have the same phase, if applicable, and the same
// start and end dates as the adjustment it replaces.
//
// ## Price overrides (DEPRECATED)
//
// :::info Price overrides are being phased out in favor adding/removing/replacing
// prices. (See
// [Customize your customer's subscriptions](../reference/schedule-plan-change#customize-your-customers-subscriptions))
// :::
//
// Price overrides are used to update some or all prices in a plan for the specific
// subscription being created. This is useful when a new customer has negotiated a
// rate that is unique to the customer.
//
// To override prices, provide a list of objects with the key `price_overrides`.
// The price object in the list of overrides is expected to contain the existing
// price id, the `model_type` and configuration. (See the
// [Price resource](../reference/price) for the specification of different price
// model configurations.) The numerical values can be updated, but the billable
// metric, cadence, type, and name of a price can not be overridden.
//
// ### Maximums, and minimums
//
// Price overrides are used to update some or all prices in the target plan.
// Minimums and maximums, much like price overrides, can be useful when a new
// customer has negotiated a new or different minimum or maximum spend cap than the
// default for the plan. The request format for maximums and minimums is the same
// as those in [subscription creation](create-subscription).
//
// ## Scheduling multiple plan changes
//
// When scheduling multiple plan changes with the same date, the latest plan change
// on that day takes effect.
//
// ## Prorations for in-advance fees
//
// By default, Orb calculates the prorated difference in any fixed fees when making
// a plan change, adjusting the customer balance as needed. For details on this
// behavior, see
// [Modifying subscriptions](../guides/product-catalog/modifying-subscriptions.md#prorations-for-in-advance-fees).
func (r *SubscriptionService) SchedulePlanChange(ctx context.Context, subscriptionID string, body SubscriptionSchedulePlanChangeParams, opts ...option.RequestOption) (res *SubscriptionSchedulePlanChangeResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/schedule_plan_change", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// Manually trigger a phase, effective the given date (or the current time, if not
// specified).
func (r *SubscriptionService) TriggerPhase(ctx context.Context, subscriptionID string, body SubscriptionTriggerPhaseParams, opts ...option.RequestOption) (res *SubscriptionTriggerPhaseResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/trigger_phase", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to unschedule any pending cancellations for a
// subscription.
//
// To be eligible, the subscription must currently be active and have a future
// cancellation. This operation will turn on auto-renew, ensuring that the
// subscription does not end at the currently scheduled cancellation time.
func (r *SubscriptionService) UnscheduleCancellation(ctx context.Context, subscriptionID string, opts ...option.RequestOption) (res *SubscriptionUnscheduleCancellationResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/unschedule_cancellation", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, nil, &res, opts...)
	return
}

// This endpoint can be used to clear scheduled updates to the quantity for a fixed
// fee.
//
// If there are no updates scheduled, a request validation error will be returned
// with a 400 status code.
func (r *SubscriptionService) UnscheduleFixedFeeQuantityUpdates(ctx context.Context, subscriptionID string, body SubscriptionUnscheduleFixedFeeQuantityUpdatesParams, opts ...option.RequestOption) (res *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/unschedule_fixed_fee_quantity_updates", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint can be used to unschedule any pending plan changes on an existing
// subscription.
func (r *SubscriptionService) UnschedulePendingPlanChanges(ctx context.Context, subscriptionID string, opts ...option.RequestOption) (res *SubscriptionUnschedulePendingPlanChangesResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/unschedule_pending_plan_changes", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, nil, &res, opts...)
	return
}

// This endpoint can be used to update the quantity for a fixed fee.
//
// To be eligible, the subscription must currently be active and the price
// specified must be a fixed fee (not usage-based). This operation will immediately
// update the quantity for the fee, or if a `effective_date` is passed in, will
// update the quantity on the requested date at midnight in the customer's
// timezone.
//
// In order to change the fixed fee quantity as of the next draft invoice for this
// subscription, pass `change_option=upcoming_invoice` without an `effective_date`
// specified.
//
// If the fee is an in-advance fixed fee, it will also issue an immediate invoice
// for the difference for the remainder of the billing period.
func (r *SubscriptionService) UpdateFixedFeeQuantity(ctx context.Context, subscriptionID string, body SubscriptionUpdateFixedFeeQuantityParams, opts ...option.RequestOption) (res *SubscriptionUpdateFixedFeeQuantityResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/update_fixed_fee_quantity", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// This endpoint is used to update the trial end date for a subscription. The new
// trial end date must be within the time range of the current plan (i.e. the new
// trial end date must be on or after the subscription's start date on the current
// plan, and on or before the subscription end date).
//
// In order to retroactively remove a trial completely, the end date can be set to
// the transition date of the subscription to this plan (or, if this is the first
// plan for this subscription, the subscription's start date). In order to end a
// trial immediately, the keyword `immediate` can be provided as the trial end
// date.
//
// By default, Orb will shift only the trial end date (and price intervals that
// start or end on the previous trial end date), and leave all other future price
// intervals untouched. If the `shift` parameter is set to `true`, Orb will shift
// all subsequent price and adjustment intervals by the same amount as the trial
// end date shift (so, e.g., if a plan change is scheduled or an add-on price was
// added, that change will be pushed back by the same amount of time the trial is
// extended).
func (r *SubscriptionService) UpdateTrial(ctx context.Context, subscriptionID string, body SubscriptionUpdateTrialParams, opts ...option.RequestOption) (res *SubscriptionUpdateTrialResponse, err error) {
	opts = append(r.Options[:], opts...)
	if subscriptionID == "" {
		err = errors.New("missing required subscription_id parameter")
		return
	}
	path := fmt.Sprintf("subscriptions/%s/update_trial", subscriptionID)
	err = requestconfig.ExecuteNewRequest(ctx, http.MethodPost, path, body, &res, opts...)
	return
}

// A [subscription](../guides/core-concepts.mdx#subscription) represents the
// purchase of a plan by a customer.
//
// By default, subscriptions begin on the day that they're created and renew
// automatically for each billing cycle at the cadence that's configured in the
// plan definition.
//
// Subscriptions also default to **beginning of month alignment**, which means the
// first invoice issued for the subscription will have pro-rated charges between
// the `start_date` and the first of the following month. Subsequent billing
// periods will always start and end on a month boundary (e.g. subsequent month
// starts for monthly billing).
//
// Depending on the plan configuration, any _flat_ recurring fees will be billed
// either at the beginning (in-advance) or end (in-arrears) of each billing cycle.
// Plans default to **in-advance billing**. Usage-based fees are billed in arrears
// as usage is accumulated. In the normal course of events, you can expect an
// invoice to contain usage-based charges for the previous period, and a recurring
// fee for the following period.
type Subscription struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                        `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                              `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                 `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionPriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time             `json:"start_date,required" format:"date-time"`
	Status    SubscriptionStatus    `json:"status,required"`
	TrialInfo SubscriptionTrialInfo `json:"trial_info,required"`
	JSON      subscriptionJSON      `json:"-"`
}

// subscriptionJSON contains the JSON metadata for the struct [Subscription]
type subscriptionJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *Subscription) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionAdjustmentInterval struct {
	ID         string                                    `json:"id,required"`
	Adjustment SubscriptionAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionAdjustmentIntervalJSON `json:"-"`
}

// subscriptionAdjustmentIntervalJSON contains the JSON metadata for the struct
// [SubscriptionAdjustmentInterval]
type subscriptionAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionAdjustmentIntervalsAdjustment struct {
	ID             string                                                  `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                       `json:"usage_discount"`
	JSON          subscriptionAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionAdjustmentIntervalsAdjustmentUnion
}

// subscriptionAdjustmentIntervalsAdjustmentJSON contains the JSON metadata for the
// struct [SubscriptionAdjustmentIntervalsAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionAdjustmentIntervalsAdjustment) AsUnion() SubscriptionAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment] or
// [SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                          `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON contains
// the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                              `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                    `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                         `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                              `json:"usage_discount,required"`
	JSON          subscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON contains
// the JSON metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                   `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                         `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON contains the JSON
// metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                   `json:"id,required"`
	AdjustmentType SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                         `json:"reason,required,nullable"`
	JSON   subscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON contains the JSON
// metadata for the struct
// [SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionAdjustmentIntervalsAdjustment() {
}

type SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                           `json:"year,nullable"`
	JSON subscriptionBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionBillingCycleAnchorConfigurationJSON contains the JSON metadata for
// the struct [SubscriptionBillingCycleAnchorConfiguration]
type subscriptionBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                               `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                          `json:"usage_discount"`
	JSON          subscriptionDiscountIntervalJSON `json:"-"`
	union         SubscriptionDiscountIntervalsUnion
}

// subscriptionDiscountIntervalJSON contains the JSON metadata for the struct
// [SubscriptionDiscountInterval]
type subscriptionDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionDiscountIntervalsUnion] interface which you can
// cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionDiscountIntervalsAmountDiscountInterval],
// [SubscriptionDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionDiscountInterval) AsUnion() SubscriptionDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by [SubscriptionDiscountIntervalsAmountDiscountInterval],
// [SubscriptionDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionDiscountIntervalsUsageDiscountInterval].
type SubscriptionDiscountIntervalsUnion interface {
	implementsSubscriptionDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                        `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                               `json:"start_date,required" format:"date-time"`
	JSON      subscriptionDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionDiscountIntervalsAmountDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionDiscountIntervalsAmountDiscountInterval]
type subscriptionDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionDiscountIntervalsAmountDiscountInterval) implementsSubscriptionDiscountInterval() {
}

type SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                            `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionDiscountIntervalsPercentageDiscountIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionDiscountIntervalsPercentageDiscountInterval]
type subscriptionDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionDiscountInterval() {
}

type SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                       `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                `json:"usage_discount,required"`
	JSON          subscriptionDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionDiscountIntervalsUsageDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionDiscountIntervalsUsageDiscountInterval]
type subscriptionDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionDiscountIntervalsUsageDiscountInterval) implementsSubscriptionDiscountInterval() {
}

type SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionDiscountIntervalsDiscountType string

const (
	SubscriptionDiscountIntervalsDiscountTypeAmount     SubscriptionDiscountIntervalsDiscountType = "amount"
	SubscriptionDiscountIntervalsDiscountTypePercentage SubscriptionDiscountIntervalsDiscountType = "percentage"
	SubscriptionDiscountIntervalsDiscountTypeUsage      SubscriptionDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionDiscountIntervalsDiscountTypeAmount, SubscriptionDiscountIntervalsDiscountTypePercentage, SubscriptionDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                   `json:"price_id,required"`
	Quantity  float64                                  `json:"quantity,required"`
	StartDate time.Time                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionFixedFeeQuantityScheduleJSON contains the JSON metadata for the
// struct [SubscriptionFixedFeeQuantitySchedule]
type subscriptionFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionMaximumIntervalJSON `json:"-"`
}

// subscriptionMaximumIntervalJSON contains the JSON metadata for the struct
// [SubscriptionMaximumInterval]
type subscriptionMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionMinimumIntervalJSON `json:"-"`
}

// subscriptionMinimumIntervalJSON contains the JSON metadata for the struct
// [SubscriptionMinimumInterval]
type subscriptionMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionPriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionPriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalJSON contains the JSON metadata for the struct
// [SubscriptionPriceInterval]
type subscriptionPriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionPriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                   `json:"price_id,required"`
	Quantity      int64                                                    `json:"quantity,required"`
	JSON          subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON contains the JSON
// metadata for the struct [SubscriptionPriceIntervalsFixedFeeQuantityTransition]
type subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionRedeemedCoupon struct {
	CouponID  string                         `json:"coupon_id,required"`
	EndDate   time.Time                      `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                      `json:"start_date,required" format:"date-time"`
	JSON      subscriptionRedeemedCouponJSON `json:"-"`
}

// subscriptionRedeemedCouponJSON contains the JSON metadata for the struct
// [SubscriptionRedeemedCoupon]
type subscriptionRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionStatus string

const (
	SubscriptionStatusActive   SubscriptionStatus = "active"
	SubscriptionStatusEnded    SubscriptionStatus = "ended"
	SubscriptionStatusUpcoming SubscriptionStatus = "upcoming"
)

func (r SubscriptionStatus) IsKnown() bool {
	switch r {
	case SubscriptionStatusActive, SubscriptionStatusEnded, SubscriptionStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionTrialInfo struct {
	EndDate time.Time                 `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionTrialInfoJSON `json:"-"`
}

// subscriptionTrialInfoJSON contains the JSON metadata for the struct
// [SubscriptionTrialInfo]
type subscriptionTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsage struct {
	// This field can have the runtime type of
	// [[]SubscriptionUsageUngroupedSubscriptionUsageData],
	// [[]SubscriptionUsageGroupedSubscriptionUsageData].
	Data               interface{}               `json:"data,required"`
	PaginationMetadata shared.PaginationMetadata `json:"pagination_metadata,nullable"`
	JSON               subscriptionUsageJSON     `json:"-"`
	union              SubscriptionUsageUnion
}

// subscriptionUsageJSON contains the JSON metadata for the struct
// [SubscriptionUsage]
type subscriptionUsageJSON struct {
	Data               apijson.Field
	PaginationMetadata apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUsageJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUsage) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUsage{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionUsageUnion] interface which you can cast to the
// specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUsageUngroupedSubscriptionUsage],
// [SubscriptionUsageGroupedSubscriptionUsage].
func (r SubscriptionUsage) AsUnion() SubscriptionUsageUnion {
	return r.union
}

// Union satisfied by [SubscriptionUsageUngroupedSubscriptionUsage] or
// [SubscriptionUsageGroupedSubscriptionUsage].
type SubscriptionUsageUnion interface {
	implementsSubscriptionUsage()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUsageUnion)(nil)).Elem(),
		"",
		apijson.UnionVariant{
			TypeFilter: gjson.JSON,
			Type:       reflect.TypeOf(SubscriptionUsageUngroupedSubscriptionUsage{}),
		},
		apijson.UnionVariant{
			TypeFilter: gjson.JSON,
			Type:       reflect.TypeOf(SubscriptionUsageGroupedSubscriptionUsage{}),
		},
	)
}

type SubscriptionUsageUngroupedSubscriptionUsage struct {
	Data []SubscriptionUsageUngroupedSubscriptionUsageData `json:"data,required"`
	JSON subscriptionUsageUngroupedSubscriptionUsageJSON   `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageJSON contains the JSON metadata for
// the struct [SubscriptionUsageUngroupedSubscriptionUsage]
type subscriptionUsageUngroupedSubscriptionUsageJSON struct {
	Data        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUsageUngroupedSubscriptionUsage) implementsSubscriptionUsage() {}

type SubscriptionUsageUngroupedSubscriptionUsageData struct {
	BillableMetric SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric `json:"billable_metric,required"`
	Usage          []SubscriptionUsageUngroupedSubscriptionUsageDataUsage        `json:"usage,required"`
	ViewMode       SubscriptionUsageUngroupedSubscriptionUsageDataViewMode       `json:"view_mode,required"`
	JSON           subscriptionUsageUngroupedSubscriptionUsageDataJSON           `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageDataJSON contains the JSON metadata
// for the struct [SubscriptionUsageUngroupedSubscriptionUsageData]
type subscriptionUsageUngroupedSubscriptionUsageDataJSON struct {
	BillableMetric apijson.Field
	Usage          apijson.Field
	ViewMode       apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsageData) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageDataJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric struct {
	ID   string                                                            `json:"id,required"`
	Name string                                                            `json:"name,required"`
	JSON subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON contains the
// JSON metadata for the struct
// [SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric]
type subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsageDataBillableMetric) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageDataBillableMetricJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageUngroupedSubscriptionUsageDataUsage struct {
	Quantity       float64                                                  `json:"quantity,required"`
	TimeframeEnd   time.Time                                                `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time                                                `json:"timeframe_start,required" format:"date-time"`
	JSON           subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON `json:"-"`
}

// subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON contains the JSON
// metadata for the struct [SubscriptionUsageUngroupedSubscriptionUsageDataUsage]
type subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON struct {
	Quantity       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageUngroupedSubscriptionUsageDataUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageUngroupedSubscriptionUsageDataUsageJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageUngroupedSubscriptionUsageDataViewMode string

const (
	SubscriptionUsageUngroupedSubscriptionUsageDataViewModePeriodic   SubscriptionUsageUngroupedSubscriptionUsageDataViewMode = "periodic"
	SubscriptionUsageUngroupedSubscriptionUsageDataViewModeCumulative SubscriptionUsageUngroupedSubscriptionUsageDataViewMode = "cumulative"
)

func (r SubscriptionUsageUngroupedSubscriptionUsageDataViewMode) IsKnown() bool {
	switch r {
	case SubscriptionUsageUngroupedSubscriptionUsageDataViewModePeriodic, SubscriptionUsageUngroupedSubscriptionUsageDataViewModeCumulative:
		return true
	}
	return false
}

type SubscriptionUsageGroupedSubscriptionUsage struct {
	Data               []SubscriptionUsageGroupedSubscriptionUsageData `json:"data,required"`
	PaginationMetadata shared.PaginationMetadata                       `json:"pagination_metadata,nullable"`
	JSON               subscriptionUsageGroupedSubscriptionUsageJSON   `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageJSON contains the JSON metadata for the
// struct [SubscriptionUsageGroupedSubscriptionUsage]
type subscriptionUsageGroupedSubscriptionUsageJSON struct {
	Data               apijson.Field
	PaginationMetadata apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUsageGroupedSubscriptionUsage) implementsSubscriptionUsage() {}

type SubscriptionUsageGroupedSubscriptionUsageData struct {
	BillableMetric SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric `json:"billable_metric,required"`
	MetricGroup    SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup    `json:"metric_group,required"`
	Usage          []SubscriptionUsageGroupedSubscriptionUsageDataUsage        `json:"usage,required"`
	ViewMode       SubscriptionUsageGroupedSubscriptionUsageDataViewMode       `json:"view_mode,required"`
	JSON           subscriptionUsageGroupedSubscriptionUsageDataJSON           `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataJSON contains the JSON metadata for
// the struct [SubscriptionUsageGroupedSubscriptionUsageData]
type subscriptionUsageGroupedSubscriptionUsageDataJSON struct {
	BillableMetric apijson.Field
	MetricGroup    apijson.Field
	Usage          apijson.Field
	ViewMode       apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageData) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric struct {
	ID   string                                                          `json:"id,required"`
	Name string                                                          `json:"name,required"`
	JSON subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON contains the
// JSON metadata for the struct
// [SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric]
type subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON struct {
	ID          apijson.Field
	Name        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageDataBillableMetric) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataBillableMetricJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup struct {
	PropertyKey   string                                                       `json:"property_key,required"`
	PropertyValue string                                                       `json:"property_value,required"`
	JSON          subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON contains the JSON
// metadata for the struct
// [SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup]
type subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON struct {
	PropertyKey   apijson.Field
	PropertyValue apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageDataMetricGroup) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataMetricGroupJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataUsage struct {
	Quantity       float64                                                `json:"quantity,required"`
	TimeframeEnd   time.Time                                              `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time                                              `json:"timeframe_start,required" format:"date-time"`
	JSON           subscriptionUsageGroupedSubscriptionUsageDataUsageJSON `json:"-"`
}

// subscriptionUsageGroupedSubscriptionUsageDataUsageJSON contains the JSON
// metadata for the struct [SubscriptionUsageGroupedSubscriptionUsageDataUsage]
type subscriptionUsageGroupedSubscriptionUsageDataUsageJSON struct {
	Quantity       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionUsageGroupedSubscriptionUsageDataUsage) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUsageGroupedSubscriptionUsageDataUsageJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUsageGroupedSubscriptionUsageDataViewMode string

const (
	SubscriptionUsageGroupedSubscriptionUsageDataViewModePeriodic   SubscriptionUsageGroupedSubscriptionUsageDataViewMode = "periodic"
	SubscriptionUsageGroupedSubscriptionUsageDataViewModeCumulative SubscriptionUsageGroupedSubscriptionUsageDataViewMode = "cumulative"
)

func (r SubscriptionUsageGroupedSubscriptionUsageDataViewMode) IsKnown() bool {
	switch r {
	case SubscriptionUsageGroupedSubscriptionUsageDataViewModePeriodic, SubscriptionUsageGroupedSubscriptionUsageDataViewModeCumulative:
		return true
	}
	return false
}

type Subscriptions struct {
	Data               []Subscription            `json:"data,required"`
	PaginationMetadata shared.PaginationMetadata `json:"pagination_metadata,required"`
	JSON               subscriptionsJSON         `json:"-"`
}

// subscriptionsJSON contains the JSON metadata for the struct [Subscriptions]
type subscriptionsJSON struct {
	Data               apijson.Field
	PaginationMetadata apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *Subscriptions) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionsJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionNewResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                   `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionNewResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionNewResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                         `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionNewResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                            `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionNewResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionNewResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionNewResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionNewResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                        `json:"start_date,required" format:"date-time"`
	Status    SubscriptionNewResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionNewResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionNewResponseJSON      `json:"-"`
}

// subscriptionNewResponseJSON contains the JSON metadata for the struct
// [SubscriptionNewResponse]
type subscriptionNewResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionNewResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseAdjustmentInterval struct {
	ID         string                                               `json:"id,required"`
	Adjustment SubscriptionNewResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseAdjustmentInterval]
type subscriptionNewResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                             `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                  `json:"usage_discount"`
	JSON          subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON contains the JSON
// metadata for the struct [SubscriptionNewResponseAdjustmentIntervalsAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionNewResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionNewResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment] or
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionNewResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                     `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                           `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                         `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                               `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                    `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                         `json:"usage_discount,required"`
	JSON          subscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                              `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                    `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                              `json:"id,required"`
	AdjustmentType SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                    `json:"reason,required,nullable"`
	JSON   subscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionNewResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionNewResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                      `json:"year,nullable"`
	JSON subscriptionNewResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionNewResponseBillingCycleAnchorConfigurationJSON contains the JSON
// metadata for the struct [SubscriptionNewResponseBillingCycleAnchorConfiguration]
type subscriptionNewResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                     `json:"usage_discount"`
	JSON          subscriptionNewResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionNewResponseDiscountIntervalsUnion
}

// subscriptionNewResponseDiscountIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseDiscountInterval]
type subscriptionNewResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionNewResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionNewResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionNewResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionNewResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionNewResponseDiscountInterval) AsUnion() SubscriptionNewResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionNewResponseDiscountIntervalsUnion interface {
	implementsSubscriptionNewResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionNewResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                   `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionNewResponseDiscountInterval() {
}

type SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                       `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionNewResponseDiscountInterval() {
}

type SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                           `json:"usage_discount,required"`
	JSON          subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionNewResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionNewResponseDiscountInterval() {
}

type SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionNewResponseDiscountIntervalsDiscountType string

const (
	SubscriptionNewResponseDiscountIntervalsDiscountTypeAmount     SubscriptionNewResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionNewResponseDiscountIntervalsDiscountTypePercentage SubscriptionNewResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionNewResponseDiscountIntervalsDiscountTypeUsage      SubscriptionNewResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionNewResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseDiscountIntervalsDiscountTypeAmount, SubscriptionNewResponseDiscountIntervalsDiscountTypePercentage, SubscriptionNewResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionNewResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                           `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                              `json:"price_id,required"`
	Quantity  float64                                             `json:"quantity,required"`
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionNewResponseFixedFeeQuantityScheduleJSON contains the JSON metadata
// for the struct [SubscriptionNewResponseFixedFeeQuantitySchedule]
type subscriptionNewResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                  `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionNewResponseMaximumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseMaximumInterval]
type subscriptionNewResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                  `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionNewResponseMinimumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseMinimumInterval]
type subscriptionNewResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionNewResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionNewResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponsePriceIntervalJSON `json:"-"`
}

// subscriptionNewResponsePriceIntervalJSON contains the JSON metadata for the
// struct [SubscriptionNewResponsePriceInterval]
type subscriptionNewResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionNewResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                           `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                              `json:"price_id,required"`
	Quantity      int64                                                               `json:"quantity,required"`
	JSON          subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON contains the
// JSON metadata for the struct
// [SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionNewResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseRedeemedCoupon struct {
	CouponID  string                                    `json:"coupon_id,required"`
	EndDate   time.Time                                 `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionNewResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionNewResponseRedeemedCouponJSON contains the JSON metadata for the
// struct [SubscriptionNewResponseRedeemedCoupon]
type subscriptionNewResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewResponseStatus string

const (
	SubscriptionNewResponseStatusActive   SubscriptionNewResponseStatus = "active"
	SubscriptionNewResponseStatusEnded    SubscriptionNewResponseStatus = "ended"
	SubscriptionNewResponseStatusUpcoming SubscriptionNewResponseStatus = "upcoming"
)

func (r SubscriptionNewResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionNewResponseStatusActive, SubscriptionNewResponseStatusEnded, SubscriptionNewResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionNewResponseTrialInfo struct {
	EndDate time.Time                            `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionNewResponseTrialInfoJSON `json:"-"`
}

// subscriptionNewResponseTrialInfoJSON contains the JSON metadata for the struct
// [SubscriptionNewResponseTrialInfo]
type subscriptionNewResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionNewResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionNewResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionCancelResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                      `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionCancelResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionCancelResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                            `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionCancelResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                               `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionCancelResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionCancelResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionCancelResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionCancelResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                           `json:"start_date,required" format:"date-time"`
	Status    SubscriptionCancelResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionCancelResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionCancelResponseJSON      `json:"-"`
}

// subscriptionCancelResponseJSON contains the JSON metadata for the struct
// [SubscriptionCancelResponse]
type subscriptionCancelResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionCancelResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseAdjustmentInterval struct {
	ID         string                                                  `json:"id,required"`
	Adjustment SubscriptionCancelResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalJSON contains the JSON metadata for
// the struct [SubscriptionCancelResponseAdjustmentInterval]
type subscriptionCancelResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                     `json:"usage_discount"`
	JSON          subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON contains the JSON
// metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionCancelResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment] or
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                        `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                              `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                            `json:"usage_discount,required"`
	JSON          subscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionCancelResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionCancelResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionCancelResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                         `json:"year,nullable"`
	JSON subscriptionCancelResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionCancelResponseBillingCycleAnchorConfigurationJSON contains the JSON
// metadata for the struct
// [SubscriptionCancelResponseBillingCycleAnchorConfiguration]
type subscriptionCancelResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                        `json:"usage_discount"`
	JSON          subscriptionCancelResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionCancelResponseDiscountIntervalsUnion
}

// subscriptionCancelResponseDiscountIntervalJSON contains the JSON metadata for
// the struct [SubscriptionCancelResponseDiscountInterval]
type subscriptionCancelResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionCancelResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionCancelResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionCancelResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionCancelResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionCancelResponseDiscountInterval) AsUnion() SubscriptionCancelResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionCancelResponseDiscountIntervalsUnion interface {
	implementsSubscriptionCancelResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionCancelResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionCancelResponseDiscountInterval() {
}

type SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionCancelResponseDiscountInterval() {
}

type SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                              `json:"usage_discount,required"`
	JSON          subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionCancelResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionCancelResponseDiscountInterval() {
}

type SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionCancelResponseDiscountIntervalsDiscountType string

const (
	SubscriptionCancelResponseDiscountIntervalsDiscountTypeAmount     SubscriptionCancelResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionCancelResponseDiscountIntervalsDiscountTypePercentage SubscriptionCancelResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionCancelResponseDiscountIntervalsDiscountTypeUsage      SubscriptionCancelResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionCancelResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseDiscountIntervalsDiscountTypeAmount, SubscriptionCancelResponseDiscountIntervalsDiscountTypePercentage, SubscriptionCancelResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionCancelResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                              `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                 `json:"price_id,required"`
	Quantity  float64                                                `json:"quantity,required"`
	StartDate time.Time                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionCancelResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct [SubscriptionCancelResponseFixedFeeQuantitySchedule]
type subscriptionCancelResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionCancelResponseMaximumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseMaximumInterval]
type subscriptionCancelResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionCancelResponseMinimumIntervalJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseMinimumInterval]
type subscriptionCancelResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionCancelResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionCancelResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponsePriceIntervalJSON `json:"-"`
}

// subscriptionCancelResponsePriceIntervalJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponsePriceInterval]
type subscriptionCancelResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionCancelResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                              `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                 `json:"price_id,required"`
	Quantity      int64                                                                  `json:"quantity,required"`
	JSON          subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON contains
// the JSON metadata for the struct
// [SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseRedeemedCoupon struct {
	CouponID  string                                       `json:"coupon_id,required"`
	EndDate   time.Time                                    `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionCancelResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionCancelResponseRedeemedCouponJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseRedeemedCoupon]
type subscriptionCancelResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionCancelResponseStatus string

const (
	SubscriptionCancelResponseStatusActive   SubscriptionCancelResponseStatus = "active"
	SubscriptionCancelResponseStatusEnded    SubscriptionCancelResponseStatus = "ended"
	SubscriptionCancelResponseStatusUpcoming SubscriptionCancelResponseStatus = "upcoming"
)

func (r SubscriptionCancelResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionCancelResponseStatusActive, SubscriptionCancelResponseStatusEnded, SubscriptionCancelResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionCancelResponseTrialInfo struct {
	EndDate time.Time                               `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionCancelResponseTrialInfoJSON `json:"-"`
}

// subscriptionCancelResponseTrialInfoJSON contains the JSON metadata for the
// struct [SubscriptionCancelResponseTrialInfo]
type subscriptionCancelResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionCancelResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionCancelResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchCostsResponse struct {
	Data []SubscriptionFetchCostsResponseData `json:"data,required"`
	JSON subscriptionFetchCostsResponseJSON   `json:"-"`
}

// subscriptionFetchCostsResponseJSON contains the JSON metadata for the struct
// [SubscriptionFetchCostsResponse]
type subscriptionFetchCostsResponseJSON struct {
	Data        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFetchCostsResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchCostsResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchCostsResponseData struct {
	PerPriceCosts []SubscriptionFetchCostsResponseDataPerPriceCost `json:"per_price_costs,required"`
	// Total costs for the timeframe, excluding any minimums and discounts.
	Subtotal       string    `json:"subtotal,required"`
	TimeframeEnd   time.Time `json:"timeframe_end,required" format:"date-time"`
	TimeframeStart time.Time `json:"timeframe_start,required" format:"date-time"`
	// Total costs for the timeframe, including any minimums and discounts.
	Total string                                 `json:"total,required"`
	JSON  subscriptionFetchCostsResponseDataJSON `json:"-"`
}

// subscriptionFetchCostsResponseDataJSON contains the JSON metadata for the struct
// [SubscriptionFetchCostsResponseData]
type subscriptionFetchCostsResponseDataJSON struct {
	PerPriceCosts  apijson.Field
	Subtotal       apijson.Field
	TimeframeEnd   apijson.Field
	TimeframeStart apijson.Field
	Total          apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionFetchCostsResponseData) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchCostsResponseDataJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchCostsResponseDataPerPriceCost struct {
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// Price's contributions for the timeframe, excluding any minimums and discounts.
	Subtotal string `json:"subtotal,required"`
	// Price's contributions for the timeframe, including minimums and discounts.
	Total string `json:"total,required"`
	// The price's quantity for the timeframe
	Quantity float64                                            `json:"quantity,nullable"`
	JSON     subscriptionFetchCostsResponseDataPerPriceCostJSON `json:"-"`
}

// subscriptionFetchCostsResponseDataPerPriceCostJSON contains the JSON metadata
// for the struct [SubscriptionFetchCostsResponseDataPerPriceCost]
type subscriptionFetchCostsResponseDataPerPriceCostJSON struct {
	Price       apijson.Field
	Subtotal    apijson.Field
	Total       apijson.Field
	Quantity    apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFetchCostsResponseDataPerPriceCost) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchCostsResponseDataPerPriceCostJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchScheduleResponse struct {
	CreatedAt time.Time                             `json:"created_at,required" format:"date-time"`
	EndDate   time.Time                             `json:"end_date,required,nullable" format:"date-time"`
	Plan      SubscriptionFetchScheduleResponsePlan `json:"plan,required"`
	StartDate time.Time                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionFetchScheduleResponseJSON `json:"-"`
}

// subscriptionFetchScheduleResponseJSON contains the JSON metadata for the struct
// [SubscriptionFetchScheduleResponse]
type subscriptionFetchScheduleResponseJSON struct {
	CreatedAt   apijson.Field
	EndDate     apijson.Field
	Plan        apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionFetchScheduleResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchScheduleResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionFetchScheduleResponsePlan struct {
	ID string `json:"id,required,nullable"`
	// An optional user-defined ID for this plan resource, used throughout the system
	// as an alias for this Plan. Use this field to identify a plan by an existing
	// identifier in your system.
	ExternalPlanID string                                    `json:"external_plan_id,required,nullable"`
	Name           string                                    `json:"name,required,nullable"`
	JSON           subscriptionFetchScheduleResponsePlanJSON `json:"-"`
}

// subscriptionFetchScheduleResponsePlanJSON contains the JSON metadata for the
// struct [SubscriptionFetchScheduleResponsePlan]
type subscriptionFetchScheduleResponsePlanJSON struct {
	ID             apijson.Field
	ExternalPlanID apijson.Field
	Name           apijson.Field
	raw            string
	ExtraFields    map[string]apijson.Field
}

func (r *SubscriptionFetchScheduleResponsePlan) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionFetchScheduleResponsePlanJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionPriceIntervalsResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                              `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionPriceIntervalsResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                       `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionPriceIntervalsResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionPriceIntervalsResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionPriceIntervalsResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionPriceIntervalsResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                   `json:"start_date,required" format:"date-time"`
	Status    SubscriptionPriceIntervalsResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionPriceIntervalsResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionPriceIntervalsResponseJSON      `json:"-"`
}

// subscriptionPriceIntervalsResponseJSON contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponse]
type subscriptionPriceIntervalsResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseAdjustmentInterval struct {
	ID         string                                                          `json:"id,required"`
	Adjustment SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalJSON contains the JSON
// metadata for the struct [SubscriptionPriceIntervalsResponseAdjustmentInterval]
type subscriptionPriceIntervalsResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                        `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                             `json:"usage_discount"`
	JSON          subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON contains the
// JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                                `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                      `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                    `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                          `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                               `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                    `json:"usage_discount,required"`
	JSON          subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                         `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                               `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                         `json:"id,required"`
	AdjustmentType SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                               `json:"reason,required,nullable"`
	JSON   subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionPriceIntervalsResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                 `json:"year,nullable"`
	JSON subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON contains
// the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration]
type subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                `json:"usage_discount"`
	JSON          subscriptionPriceIntervalsResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionPriceIntervalsResponseDiscountIntervalsUnion
}

// subscriptionPriceIntervalsResponseDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionPriceIntervalsResponseDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionPriceIntervalsResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionPriceIntervalsResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionPriceIntervalsResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionPriceIntervalsResponseDiscountInterval) AsUnion() SubscriptionPriceIntervalsResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval]
// or [SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionPriceIntervalsResponseDiscountIntervalsUnion interface {
	implementsSubscriptionPriceIntervalsResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionPriceIntervalsResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                              `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionPriceIntervalsResponseDiscountInterval() {
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionPriceIntervalsResponseDiscountInterval() {
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                      `json:"usage_discount,required"`
	JSON          subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionPriceIntervalsResponseDiscountInterval() {
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType string

const (
	SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeAmount     SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypePercentage SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeUsage      SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeAmount, SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypePercentage, SubscriptionPriceIntervalsResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                      `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                         `json:"price_id,required"`
	Quantity  float64                                                        `json:"quantity,required"`
	StartDate time.Time                                                      `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct
// [SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule]
type subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseMaximumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponseMaximumInterval]
type subscriptionPriceIntervalsResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseMinimumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponseMinimumInterval]
type subscriptionPriceIntervalsResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionPriceIntervalsResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponsePriceIntervalJSON `json:"-"`
}

// subscriptionPriceIntervalsResponsePriceIntervalJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponsePriceInterval]
type subscriptionPriceIntervalsResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                      `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                         `json:"price_id,required"`
	Quantity      int64                                                                          `json:"quantity,required"`
	JSON          subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseRedeemedCoupon struct {
	CouponID  string                                               `json:"coupon_id,required"`
	EndDate   time.Time                                            `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                            `json:"start_date,required" format:"date-time"`
	JSON      subscriptionPriceIntervalsResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseRedeemedCouponJSON contains the JSON metadata
// for the struct [SubscriptionPriceIntervalsResponseRedeemedCoupon]
type subscriptionPriceIntervalsResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionPriceIntervalsResponseStatus string

const (
	SubscriptionPriceIntervalsResponseStatusActive   SubscriptionPriceIntervalsResponseStatus = "active"
	SubscriptionPriceIntervalsResponseStatusEnded    SubscriptionPriceIntervalsResponseStatus = "ended"
	SubscriptionPriceIntervalsResponseStatusUpcoming SubscriptionPriceIntervalsResponseStatus = "upcoming"
)

func (r SubscriptionPriceIntervalsResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsResponseStatusActive, SubscriptionPriceIntervalsResponseStatusEnded, SubscriptionPriceIntervalsResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsResponseTrialInfo struct {
	EndDate time.Time                                       `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionPriceIntervalsResponseTrialInfoJSON `json:"-"`
}

// subscriptionPriceIntervalsResponseTrialInfoJSON contains the JSON metadata for
// the struct [SubscriptionPriceIntervalsResponseTrialInfo]
type subscriptionPriceIntervalsResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionPriceIntervalsResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionPriceIntervalsResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionSchedulePlanChangeResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                  `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionSchedulePlanChangeResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                        `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                           `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionSchedulePlanChangeResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionSchedulePlanChangeResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionSchedulePlanChangeResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionSchedulePlanChangeResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                       `json:"start_date,required" format:"date-time"`
	Status    SubscriptionSchedulePlanChangeResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionSchedulePlanChangeResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionSchedulePlanChangeResponseJSON      `json:"-"`
}

// subscriptionSchedulePlanChangeResponseJSON contains the JSON metadata for the
// struct [SubscriptionSchedulePlanChangeResponse]
type subscriptionSchedulePlanChangeResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseAdjustmentInterval struct {
	ID         string                                                              `json:"id,required"`
	Adjustment SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentInterval]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                            `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                 `json:"usage_discount"`
	JSON          subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON contains
// the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                                    `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                          `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                        `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                              `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                                   `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                        `json:"usage_discount,required"`
	JSON          subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                   `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                   `json:"reason,required,nullable"`
	JSON   subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionSchedulePlanChangeResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                     `json:"year,nullable"`
	JSON subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration]
type subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                         `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                    `json:"usage_discount"`
	JSON          subscriptionSchedulePlanChangeResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionSchedulePlanChangeResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionSchedulePlanChangeResponseDiscountInterval) AsUnion() SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion interface {
	implementsSubscriptionSchedulePlanChangeResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionSchedulePlanChangeResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionSchedulePlanChangeResponseDiscountInterval() {
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionSchedulePlanChangeResponseDiscountInterval() {
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                 `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                          `json:"usage_discount,required"`
	JSON          subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionSchedulePlanChangeResponseDiscountInterval() {
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType string

const (
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeAmount     SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypePercentage SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeUsage      SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeAmount, SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypePercentage, SubscriptionSchedulePlanChangeResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                          `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                             `json:"price_id,required"`
	Quantity  float64                                                            `json:"quantity,required"`
	StartDate time.Time                                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON contains the
// JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule]
type subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseMaximumIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseMaximumInterval]
type subscriptionSchedulePlanChangeResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseMinimumIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseMinimumInterval]
type subscriptionSchedulePlanChangeResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionSchedulePlanChangeResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                               `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponsePriceIntervalJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponsePriceIntervalJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponsePriceInterval]
type subscriptionSchedulePlanChangeResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                          `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                             `json:"price_id,required"`
	Quantity      int64                                                                              `json:"quantity,required"`
	JSON          subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseRedeemedCoupon struct {
	CouponID  string                                                   `json:"coupon_id,required"`
	EndDate   time.Time                                                `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionSchedulePlanChangeResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseRedeemedCouponJSON contains the JSON
// metadata for the struct [SubscriptionSchedulePlanChangeResponseRedeemedCoupon]
type subscriptionSchedulePlanChangeResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionSchedulePlanChangeResponseStatus string

const (
	SubscriptionSchedulePlanChangeResponseStatusActive   SubscriptionSchedulePlanChangeResponseStatus = "active"
	SubscriptionSchedulePlanChangeResponseStatusEnded    SubscriptionSchedulePlanChangeResponseStatus = "ended"
	SubscriptionSchedulePlanChangeResponseStatusUpcoming SubscriptionSchedulePlanChangeResponseStatus = "upcoming"
)

func (r SubscriptionSchedulePlanChangeResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeResponseStatusActive, SubscriptionSchedulePlanChangeResponseStatusEnded, SubscriptionSchedulePlanChangeResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeResponseTrialInfo struct {
	EndDate time.Time                                           `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionSchedulePlanChangeResponseTrialInfoJSON `json:"-"`
}

// subscriptionSchedulePlanChangeResponseTrialInfoJSON contains the JSON metadata
// for the struct [SubscriptionSchedulePlanChangeResponseTrialInfo]
type subscriptionSchedulePlanChangeResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionSchedulePlanChangeResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionSchedulePlanChangeResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionTriggerPhaseResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                            `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionTriggerPhaseResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                  `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                     `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionTriggerPhaseResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionTriggerPhaseResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionTriggerPhaseResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionTriggerPhaseResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                 `json:"start_date,required" format:"date-time"`
	Status    SubscriptionTriggerPhaseResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionTriggerPhaseResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionTriggerPhaseResponseJSON      `json:"-"`
}

// subscriptionTriggerPhaseResponseJSON contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponse]
type subscriptionTriggerPhaseResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseAdjustmentInterval struct {
	ID         string                                                        `json:"id,required"`
	Adjustment SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalJSON contains the JSON
// metadata for the struct [SubscriptionTriggerPhaseResponseAdjustmentInterval]
type subscriptionTriggerPhaseResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                      `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                           `json:"usage_discount"`
	JSON          subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON contains the
// JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                              `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                    `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                        `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                  `json:"usage_discount,required"`
	JSON          subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionTriggerPhaseResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                               `json:"year,nullable"`
	JSON subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON contains the
// JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration]
type subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                   `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                              `json:"usage_discount"`
	JSON          subscriptionTriggerPhaseResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionTriggerPhaseResponseDiscountIntervalsUnion
}

// subscriptionTriggerPhaseResponseDiscountIntervalJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionTriggerPhaseResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionTriggerPhaseResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionTriggerPhaseResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionTriggerPhaseResponseDiscountInterval) AsUnion() SubscriptionTriggerPhaseResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionTriggerPhaseResponseDiscountIntervalsUnion interface {
	implementsSubscriptionTriggerPhaseResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionTriggerPhaseResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                            `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionTriggerPhaseResponseDiscountInterval() {
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionTriggerPhaseResponseDiscountInterval() {
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                    `json:"usage_discount,required"`
	JSON          subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionTriggerPhaseResponseDiscountInterval() {
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType string

const (
	SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeAmount     SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypePercentage SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeUsage      SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeAmount, SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypePercentage, SubscriptionTriggerPhaseResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                       `json:"price_id,required"`
	Quantity  float64                                                      `json:"quantity,required"`
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct
// [SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule]
type subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseMaximumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseMaximumInterval]
type subscriptionTriggerPhaseResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseMinimumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseMinimumInterval]
type subscriptionTriggerPhaseResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionTriggerPhaseResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponsePriceIntervalJSON `json:"-"`
}

// subscriptionTriggerPhaseResponsePriceIntervalJSON contains the JSON metadata for
// the struct [SubscriptionTriggerPhaseResponsePriceInterval]
type subscriptionTriggerPhaseResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                    `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                       `json:"price_id,required"`
	Quantity      int64                                                                        `json:"quantity,required"`
	JSON          subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseRedeemedCoupon struct {
	CouponID  string                                             `json:"coupon_id,required"`
	EndDate   time.Time                                          `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionTriggerPhaseResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseRedeemedCouponJSON contains the JSON metadata
// for the struct [SubscriptionTriggerPhaseResponseRedeemedCoupon]
type subscriptionTriggerPhaseResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionTriggerPhaseResponseStatus string

const (
	SubscriptionTriggerPhaseResponseStatusActive   SubscriptionTriggerPhaseResponseStatus = "active"
	SubscriptionTriggerPhaseResponseStatusEnded    SubscriptionTriggerPhaseResponseStatus = "ended"
	SubscriptionTriggerPhaseResponseStatusUpcoming SubscriptionTriggerPhaseResponseStatus = "upcoming"
)

func (r SubscriptionTriggerPhaseResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionTriggerPhaseResponseStatusActive, SubscriptionTriggerPhaseResponseStatusEnded, SubscriptionTriggerPhaseResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseResponseTrialInfo struct {
	EndDate time.Time                                     `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionTriggerPhaseResponseTrialInfoJSON `json:"-"`
}

// subscriptionTriggerPhaseResponseTrialInfoJSON contains the JSON metadata for the
// struct [SubscriptionTriggerPhaseResponseTrialInfo]
type subscriptionTriggerPhaseResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionTriggerPhaseResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionTriggerPhaseResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUnscheduleCancellationResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                      `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUnscheduleCancellationResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                            `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                               `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUnscheduleCancellationResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUnscheduleCancellationResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUnscheduleCancellationResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUnscheduleCancellationResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUnscheduleCancellationResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUnscheduleCancellationResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUnscheduleCancellationResponseJSON      `json:"-"`
}

// subscriptionUnscheduleCancellationResponseJSON contains the JSON metadata for
// the struct [SubscriptionUnscheduleCancellationResponse]
type subscriptionUnscheduleCancellationResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseAdjustmentInterval struct {
	ID         string                                                                  `json:"id,required"`
	Adjustment SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentInterval]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                     `json:"usage_discount"`
	JSON          subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                                        `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                              `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                            `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUnscheduleCancellationResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                         `json:"year,nullable"`
	JSON subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration]
type subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                        `json:"usage_discount"`
	JSON          subscriptionUnscheduleCancellationResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleCancellationResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUnscheduleCancellationResponseDiscountInterval) AsUnion() SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUnscheduleCancellationResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleCancellationResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUnscheduleCancellationResponseDiscountInterval() {
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUnscheduleCancellationResponseDiscountInterval() {
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                              `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUnscheduleCancellationResponseDiscountInterval() {
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypePercentage SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUnscheduleCancellationResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                              `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                 `json:"price_id,required"`
	Quantity  float64                                                                `json:"quantity,required"`
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON contains
// the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule]
type subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseMaximumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseMaximumInterval]
type subscriptionUnscheduleCancellationResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseMinimumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseMinimumInterval]
type subscriptionUnscheduleCancellationResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUnscheduleCancellationResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponsePriceIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponsePriceInterval]
type subscriptionUnscheduleCancellationResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                              `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                 `json:"price_id,required"`
	Quantity      int64                                                                                  `json:"quantity,required"`
	JSON          subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseRedeemedCoupon struct {
	CouponID  string                                                       `json:"coupon_id,required"`
	EndDate   time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleCancellationResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseRedeemedCouponJSON contains the JSON
// metadata for the struct
// [SubscriptionUnscheduleCancellationResponseRedeemedCoupon]
type subscriptionUnscheduleCancellationResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleCancellationResponseStatus string

const (
	SubscriptionUnscheduleCancellationResponseStatusActive   SubscriptionUnscheduleCancellationResponseStatus = "active"
	SubscriptionUnscheduleCancellationResponseStatusEnded    SubscriptionUnscheduleCancellationResponseStatus = "ended"
	SubscriptionUnscheduleCancellationResponseStatusUpcoming SubscriptionUnscheduleCancellationResponseStatus = "upcoming"
)

func (r SubscriptionUnscheduleCancellationResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleCancellationResponseStatusActive, SubscriptionUnscheduleCancellationResponseStatusEnded, SubscriptionUnscheduleCancellationResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUnscheduleCancellationResponseTrialInfo struct {
	EndDate time.Time                                               `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUnscheduleCancellationResponseTrialInfoJSON `json:"-"`
}

// subscriptionUnscheduleCancellationResponseTrialInfoJSON contains the JSON
// metadata for the struct [SubscriptionUnscheduleCancellationResponseTrialInfo]
type subscriptionUnscheduleCancellationResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleCancellationResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleCancellationResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                                 `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                                       `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                                          `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                                      `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON      `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON contains the JSON
// metadata for the struct [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval struct {
	ID         string                                                                             `json:"id,required"`
	Adjustment SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                           `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                `json:"usage_discount"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                                                   `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                         `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                       `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                                    `json:"year,nullable"`
	JSON subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                                        `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                   `json:"usage_discount"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval) AsUnion() SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                 `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                            `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                                         `json:"usage_discount,required"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountInterval() {
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypePercentage SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                                         `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                            `json:"price_id,required"`
	Quantity  float64                                                                           `json:"quantity,required"`
	StartDate time.Time                                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                                `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                                         `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                            `json:"price_id,required"`
	Quantity      int64                                                                                             `json:"quantity,required"`
	JSON          subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon struct {
	CouponID  string                                                                  `json:"coupon_id,required"`
	EndDate   time.Time                                                               `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                               `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON contains
// the JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus string

const (
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusActive   SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus = "active"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusEnded    SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus = "ended"
	SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusUpcoming SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus = "upcoming"
)

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusActive, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusEnded, SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo struct {
	EndDate time.Time                                                          `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON `json:"-"`
}

// subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON contains the
// JSON metadata for the struct
// [SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo]
type subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnscheduleFixedFeeQuantityUpdatesResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                            `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                                  `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                                     `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUnschedulePendingPlanChangesResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                                 `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUnschedulePendingPlanChangesResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUnschedulePendingPlanChangesResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseJSON      `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseJSON contains the JSON metadata
// for the struct [SubscriptionUnschedulePendingPlanChangesResponse]
type subscriptionUnschedulePendingPlanChangesResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval struct {
	ID         string                                                                        `json:"id,required"`
	Adjustment SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                           `json:"usage_discount"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                                              `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                    `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                                  `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                        `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                                  `json:"usage_discount,required"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                             `json:"reason,required,nullable"`
	JSON   subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUnschedulePendingPlanChangesResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                               `json:"year,nullable"`
	JSON subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration]
type subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                                   `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                              `json:"usage_discount"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON contains
// the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountInterval) AsUnion() SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                            `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval() {
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                                `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                       `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval() {
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                                    `json:"usage_discount,required"`
	JSON          subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUnschedulePendingPlanChangesResponseDiscountInterval() {
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypePercentage SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUnschedulePendingPlanChangesResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                                    `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                       `json:"price_id,required"`
	Quantity  float64                                                                      `json:"quantity,required"`
	StartDate time.Time                                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule]
type subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval]
type subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                           `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval]
type subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUnschedulePendingPlanChangesResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponsePriceInterval]
type subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                                    `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                       `json:"price_id,required"`
	Quantity      int64                                                                                        `json:"quantity,required"`
	JSON          subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon struct {
	CouponID  string                                                             `json:"coupon_id,required"`
	EndDate   time.Time                                                          `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON contains the
// JSON metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon]
type subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUnschedulePendingPlanChangesResponseStatus string

const (
	SubscriptionUnschedulePendingPlanChangesResponseStatusActive   SubscriptionUnschedulePendingPlanChangesResponseStatus = "active"
	SubscriptionUnschedulePendingPlanChangesResponseStatusEnded    SubscriptionUnschedulePendingPlanChangesResponseStatus = "ended"
	SubscriptionUnschedulePendingPlanChangesResponseStatusUpcoming SubscriptionUnschedulePendingPlanChangesResponseStatus = "upcoming"
)

func (r SubscriptionUnschedulePendingPlanChangesResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUnschedulePendingPlanChangesResponseStatusActive, SubscriptionUnschedulePendingPlanChangesResponseStatusEnded, SubscriptionUnschedulePendingPlanChangesResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUnschedulePendingPlanChangesResponseTrialInfo struct {
	EndDate time.Time                                                     `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON `json:"-"`
}

// subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON contains the JSON
// metadata for the struct
// [SubscriptionUnschedulePendingPlanChangesResponseTrialInfo]
type subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUnschedulePendingPlanChangesResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUnschedulePendingPlanChangesResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                                      `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                            `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                               `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUpdateFixedFeeQuantityResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                           `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUpdateFixedFeeQuantityResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUpdateFixedFeeQuantityResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseJSON      `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseJSON contains the JSON metadata for
// the struct [SubscriptionUpdateFixedFeeQuantityResponse]
type subscriptionUpdateFixedFeeQuantityResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval struct {
	ID         string                                                                  `json:"id,required"`
	Adjustment SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON contains the
// JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                                `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                     `json:"usage_discount"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                                        `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                              `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                                  `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                                       `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                            `json:"usage_discount,required"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUpdateFixedFeeQuantityResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                                         `json:"year,nullable"`
	JSON subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration]
type subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                             `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                        `json:"usage_discount"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountInterval) AsUnion() SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval]
// or
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                      `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval() {
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                                 `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval() {
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                                     `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                              `json:"usage_discount,required"`
	JSON          subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUpdateFixedFeeQuantityResponseDiscountInterval() {
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypePercentage SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUpdateFixedFeeQuantityResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                              `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                                 `json:"price_id,required"`
	Quantity  float64                                                                `json:"quantity,required"`
	StartDate time.Time                                                              `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON contains
// the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule]
type subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval]
type subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                                     `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval]
type subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUpdateFixedFeeQuantityResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponsePriceInterval]
type subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                              `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                                 `json:"price_id,required"`
	Quantity      int64                                                                                  `json:"quantity,required"`
	JSON          subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon struct {
	CouponID  string                                                       `json:"coupon_id,required"`
	EndDate   time.Time                                                    `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                                    `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon]
type subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateFixedFeeQuantityResponseStatus string

const (
	SubscriptionUpdateFixedFeeQuantityResponseStatusActive   SubscriptionUpdateFixedFeeQuantityResponseStatus = "active"
	SubscriptionUpdateFixedFeeQuantityResponseStatusEnded    SubscriptionUpdateFixedFeeQuantityResponseStatus = "ended"
	SubscriptionUpdateFixedFeeQuantityResponseStatusUpcoming SubscriptionUpdateFixedFeeQuantityResponseStatus = "upcoming"
)

func (r SubscriptionUpdateFixedFeeQuantityResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityResponseStatusActive, SubscriptionUpdateFixedFeeQuantityResponseStatusEnded, SubscriptionUpdateFixedFeeQuantityResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUpdateFixedFeeQuantityResponseTrialInfo struct {
	EndDate time.Time                                               `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON `json:"-"`
}

// subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON contains the JSON
// metadata for the struct [SubscriptionUpdateFixedFeeQuantityResponseTrialInfo]
type subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateFixedFeeQuantityResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateFixedFeeQuantityResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponse struct {
	ID string `json:"id,required"`
	// The current plan phase that is active, only if the subscription's plan has
	// phases.
	ActivePlanPhaseOrder int64 `json:"active_plan_phase_order,required,nullable"`
	// The adjustment intervals for this subscription.
	AdjustmentIntervals []SubscriptionUpdateTrialResponseAdjustmentInterval `json:"adjustment_intervals,required"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior. If null, defaults to the customer's setting.
	AutoCollection                  bool                                                           `json:"auto_collection,required,nullable"`
	BillingCycleAnchorConfiguration SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration `json:"billing_cycle_anchor_configuration,required"`
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	BillingCycleDay int64     `json:"billing_cycle_day,required"`
	CreatedAt       time.Time `json:"created_at,required" format:"date-time"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is not part of the billing period. Set to null for
	// subscriptions that are not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if the subscription is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// A customer is a buyer of your products, and the other party to the billing
	// relationship.
	//
	// In Orb, customers are assigned system generated identifiers automatically, but
	// it's often desirable to have these match existing identifiers in your system. To
	// avoid having to denormalize Orb ID information, you can pass in an
	// `external_customer_id` with your own identifier. See
	// [Customer ID Aliases](../guides/events-and-metrics/customer-aliases) for further
	// information about how these aliases work in Orb.
	//
	// In addition to having an identifier in your system, a customer may exist in a
	// payment provider solution like Stripe. Use the `payment_provider_id` and the
	// `payment_provider` enum field to express this mapping.
	//
	// A customer also has a timezone (from the standard
	// [IANA timezone database](https://www.iana.org/time-zones)), which defaults to
	// your account's timezone. See
	// [Timezone localization](../guides/product-catalog/timezones.md) for information
	// on what this timezone parameter influences within Orb.
	Customer Customer `json:"customer,required"`
	// Determines the default memo on this subscriptions' invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo string `json:"default_invoice_memo,required,nullable"`
	// The discount intervals for this subscription.
	DiscountIntervals []SubscriptionUpdateTrialResponseDiscountInterval `json:"discount_intervals,required"`
	// The date Orb stops billing for this subscription.
	EndDate                  time.Time                                                 `json:"end_date,required,nullable" format:"date-time"`
	FixedFeeQuantitySchedule []SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule `json:"fixed_fee_quantity_schedule,required"`
	InvoicingThreshold       string                                                    `json:"invoicing_threshold,required,nullable"`
	// The maximum intervals for this subscription.
	MaximumIntervals []SubscriptionUpdateTrialResponseMaximumInterval `json:"maximum_intervals,required"`
	// User specified key-value pairs for the resource. If not present, this defaults
	// to an empty dictionary. Individual keys can be removed by setting the value to
	// `null`, and the entire metadata mapping can be cleared by setting `metadata` to
	// `null`.
	Metadata map[string]string `json:"metadata,required"`
	// The minimum intervals for this subscription.
	MinimumIntervals []SubscriptionUpdateTrialResponseMinimumInterval `json:"minimum_intervals,required"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms int64 `json:"net_terms,required"`
	// The [Plan](../guides/core-concepts.mdx#plan-and-price) resource represents a
	// plan that can be subscribed to by a customer. Plans define the billing behavior
	// of the subscription. You can see more about how to configure prices in the
	// [Price resource](/reference/price).
	Plan Plan `json:"plan,required"`
	// The price intervals for this subscription.
	PriceIntervals []SubscriptionUpdateTrialResponsePriceInterval `json:"price_intervals,required"`
	RedeemedCoupon SubscriptionUpdateTrialResponseRedeemedCoupon  `json:"redeemed_coupon,required,nullable"`
	// The date Orb starts billing for this subscription.
	StartDate time.Time                                `json:"start_date,required" format:"date-time"`
	Status    SubscriptionUpdateTrialResponseStatus    `json:"status,required"`
	TrialInfo SubscriptionUpdateTrialResponseTrialInfo `json:"trial_info,required"`
	JSON      subscriptionUpdateTrialResponseJSON      `json:"-"`
}

// subscriptionUpdateTrialResponseJSON contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponse]
type subscriptionUpdateTrialResponseJSON struct {
	ID                              apijson.Field
	ActivePlanPhaseOrder            apijson.Field
	AdjustmentIntervals             apijson.Field
	AutoCollection                  apijson.Field
	BillingCycleAnchorConfiguration apijson.Field
	BillingCycleDay                 apijson.Field
	CreatedAt                       apijson.Field
	CurrentBillingPeriodEndDate     apijson.Field
	CurrentBillingPeriodStartDate   apijson.Field
	Customer                        apijson.Field
	DefaultInvoiceMemo              apijson.Field
	DiscountIntervals               apijson.Field
	EndDate                         apijson.Field
	FixedFeeQuantitySchedule        apijson.Field
	InvoicingThreshold              apijson.Field
	MaximumIntervals                apijson.Field
	Metadata                        apijson.Field
	MinimumIntervals                apijson.Field
	NetTerms                        apijson.Field
	Plan                            apijson.Field
	PriceIntervals                  apijson.Field
	RedeemedCoupon                  apijson.Field
	StartDate                       apijson.Field
	Status                          apijson.Field
	TrialInfo                       apijson.Field
	raw                             string
	ExtraFields                     map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponse) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseAdjustmentInterval struct {
	ID         string                                                       `json:"id,required"`
	Adjustment SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment `json:"adjustment,required"`
	// The price interval IDs that this adjustment applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the adjustment interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the adjustment interval.
	StartDate time.Time                                             `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseAdjustmentIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseAdjustmentInterval]
type subscriptionUpdateTrialResponseAdjustmentIntervalJSON struct {
	ID                        apijson.Field
	Adjustment                apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment struct {
	ID             string                                                                     `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                          `json:"usage_discount"`
	JSON          subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON `json:"-"`
	union         SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON contains the
// JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	AmountDiscount     apijson.Field
	ItemID             apijson.Field
	MaximumAmount      apijson.Field
	MinimumAmount      apijson.Field
	PercentageDiscount apijson.Field
	UsageDiscount      apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion] interface
// which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment) AsUnion() SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment],
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
// or
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment].
type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion interface {
	implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUnion)(nil)).Elem(),
		"adjustment_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment{}),
			DiscriminatorValue: "amount_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment{}),
			DiscriminatorValue: "percentage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment{}),
			DiscriminatorValue: "usage_discount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment{}),
			DiscriminatorValue: "minimum",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment{}),
			DiscriminatorValue: "maximum",
		},
	)
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment struct {
	ID             string                                                                                             `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The amount by which to discount the prices this adjustment applies to in a given
	// billing period.
	AmountDiscount string `json:"amount_discount,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                   `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AmountDiscount    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType = "amount_discount"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAmountDiscountAdjustmentAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment struct {
	ID             string                                                                                                 `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The percentage (as a value between 0 and 1) by which to discount the price
	// intervals this adjustment applies to in a given billing period.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                                       `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON struct {
	ID                 apijson.Field
	AdjustmentType     apijson.Field
	AppliesToPriceIDs  apijson.Field
	IsInvoiceLevel     apijson.Field
	PercentageDiscount apijson.Field
	PlanPhaseOrder     apijson.Field
	Reason             apijson.Field
	raw                string
	ExtraFields        map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType = "percentage_discount"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentPercentageDiscountAdjustmentAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment struct {
	ID             string                                                                                            `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string `json:"reason,required,nullable"`
	// The number of usage units by which to discount the price this adjustment applies
	// to in a given billing period.
	UsageDiscount float64                                                                                 `json:"usage_discount,required"`
	JSON          subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	UsageDiscount     apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType = "usage_discount"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentUsageDiscountAdjustmentAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment struct {
	ID             string                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID string `json:"item_id,required"`
	// The minimum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                            `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	ItemID            apijson.Field
	MinimumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType = "minimum"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMinimumAdjustmentAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment struct {
	ID             string                                                                                      `json:"id,required"`
	AdjustmentType SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType `json:"adjustment_type,required"`
	// The price IDs that this adjustment applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// True for adjustments that apply to an entire invocice, false for adjustments
	// that apply to only one price.
	IsInvoiceLevel bool `json:"is_invoice_level,required"`
	// The maximum amount to charge in a given billing period for the prices this
	// adjustment applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The plan phase in which this adjustment is active.
	PlanPhaseOrder int64 `json:"plan_phase_order,required,nullable"`
	// The reason for the adjustment.
	Reason string                                                                            `json:"reason,required,nullable"`
	JSON   subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON `json:"-"`
}

// subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment]
type subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON struct {
	ID                apijson.Field
	AdjustmentType    apijson.Field
	AppliesToPriceIDs apijson.Field
	IsInvoiceLevel    apijson.Field
	MaximumAmount     apijson.Field
	PlanPhaseOrder    apijson.Field
	Reason            apijson.Field
	raw               string
	ExtraFields       map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustment) implementsSubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustment() {
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentMaximumAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType string

const (
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum            SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "minimum"
	SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum            SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMinimum, SubscriptionUpdateTrialResponseAdjustmentIntervalsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day int64 `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month int64 `json:"month,nullable"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year int64                                                              `json:"year,nullable"`
	JSON subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON `json:"-"`
}

// subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON contains the
// JSON metadata for the struct
// [SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration]
type subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON struct {
	Day         apijson.Field
	Month       apijson.Field
	Year        apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseBillingCycleAnchorConfiguration) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseBillingCycleAnchorConfigurationJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseDiscountInterval struct {
	// This field can have the runtime type of [[]string].
	AppliesToPriceIDs interface{} `json:"applies_to_price_ids,required"`
	// This field can have the runtime type of [[]string].
	AppliesToPriceIntervalIDs interface{}                                                  `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                             `json:"usage_discount"`
	JSON          subscriptionUpdateTrialResponseDiscountIntervalJSON `json:"-"`
	union         SubscriptionUpdateTrialResponseDiscountIntervalsUnion
}

// subscriptionUpdateTrialResponseDiscountIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	AmountDiscount            apijson.Field
	PercentageDiscount        apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r subscriptionUpdateTrialResponseDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r *SubscriptionUpdateTrialResponseDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	*r = SubscriptionUpdateTrialResponseDiscountInterval{}
	err = apijson.UnmarshalRoot(data, &r.union)
	if err != nil {
		return err
	}
	return apijson.Port(r.union, &r)
}

// AsUnion returns a [SubscriptionUpdateTrialResponseDiscountIntervalsUnion]
// interface which you can cast to the specific types for more type safety.
//
// Possible runtime types of the union are
// [SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval],
// [SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval].
func (r SubscriptionUpdateTrialResponseDiscountInterval) AsUnion() SubscriptionUpdateTrialResponseDiscountIntervalsUnion {
	return r.union
}

// Union satisfied by
// [SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval],
// [SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval] or
// [SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval].
type SubscriptionUpdateTrialResponseDiscountIntervalsUnion interface {
	implementsSubscriptionUpdateTrialResponseDiscountInterval()
}

func init() {
	apijson.RegisterUnion(
		reflect.TypeOf((*SubscriptionUpdateTrialResponseDiscountIntervalsUnion)(nil)).Elem(),
		"discount_type",
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval{}),
			DiscriminatorValue: "amount",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval{}),
			DiscriminatorValue: "percentage",
		},
		apijson.UnionVariant{
			TypeFilter:         gjson.JSON,
			Type:               reflect.TypeOf(SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval{}),
			DiscriminatorValue: "usage",
		},
	)
}

type SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval struct {
	// Only available if discount_type is `amount`.
	AmountDiscount string `json:"amount_discount,required"`
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                           `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time                                                                  `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON struct {
	AmountDiscount            apijson.Field
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountInterval) implementsSubscriptionUpdateTrialResponseDiscountInterval() {
}

type SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType = "amount"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsAmountDiscountIntervalDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                               `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// Only available if discount_type is `percentage`.This is a number between 0
	// and 1.
	PercentageDiscount float64 `json:"percentage_discount,required"`
	// The start date of the discount interval.
	StartDate time.Time                                                                      `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	PercentageDiscount        apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountInterval) implementsSubscriptionUpdateTrialResponseDiscountInterval() {
}

type SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType = "percentage"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsPercentageDiscountIntervalDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval struct {
	// The price ids that this discount interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this discount interval applies to.
	AppliesToPriceIntervalIDs []string                                                                          `json:"applies_to_price_interval_ids,required"`
	DiscountType              SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType `json:"discount_type,required"`
	// The end date of the discount interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The start date of the discount interval.
	StartDate time.Time `json:"start_date,required" format:"date-time"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount float64                                                                   `json:"usage_discount,required"`
	JSON          subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval]
type subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	DiscountType              apijson.Field
	EndDate                   apijson.Field
	StartDate                 apijson.Field
	UsageDiscount             apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalJSON) RawJSON() string {
	return r.raw
}

func (r SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountInterval) implementsSubscriptionUpdateTrialResponseDiscountInterval() {
}

type SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType = "usage"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsUsageDiscountIntervalDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType string

const (
	SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeAmount     SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType = "amount"
	SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypePercentage SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType = "percentage"
	SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeUsage      SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType = "usage"
)

func (r SubscriptionUpdateTrialResponseDiscountIntervalsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeAmount, SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypePercentage, SubscriptionUpdateTrialResponseDiscountIntervalsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule struct {
	EndDate   time.Time                                                   `json:"end_date,required,nullable" format:"date-time"`
	PriceID   string                                                      `json:"price_id,required"`
	Quantity  float64                                                     `json:"quantity,required"`
	StartDate time.Time                                                   `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON `json:"-"`
}

// subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON contains the JSON
// metadata for the struct
// [SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule]
type subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON struct {
	EndDate     apijson.Field
	PriceID     apijson.Field
	Quantity    apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseFixedFeeQuantitySchedule) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseFixedFeeQuantityScheduleJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseMaximumInterval struct {
	// The price ids that this maximum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this maximum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the maximum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The maximum amount to charge in a given billing period for the price intervals
	// this transform applies to.
	MaximumAmount string `json:"maximum_amount,required"`
	// The start date of the maximum interval.
	StartDate time.Time                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseMaximumIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseMaximumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseMaximumInterval]
type subscriptionUpdateTrialResponseMaximumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MaximumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseMaximumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseMaximumIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseMinimumInterval struct {
	// The price ids that this minimum interval applies to.
	AppliesToPriceIDs []string `json:"applies_to_price_ids,required"`
	// The price interval ids that this minimum interval applies to.
	AppliesToPriceIntervalIDs []string `json:"applies_to_price_interval_ids,required"`
	// The end date of the minimum interval.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The minimum amount to charge in a given billing period for the price intervals
	// this minimum applies to.
	MinimumAmount string `json:"minimum_amount,required"`
	// The start date of the minimum interval.
	StartDate time.Time                                          `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseMinimumIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponseMinimumIntervalJSON contains the JSON metadata
// for the struct [SubscriptionUpdateTrialResponseMinimumInterval]
type subscriptionUpdateTrialResponseMinimumIntervalJSON struct {
	AppliesToPriceIDs         apijson.Field
	AppliesToPriceIntervalIDs apijson.Field
	EndDate                   apijson.Field
	MinimumAmount             apijson.Field
	StartDate                 apijson.Field
	raw                       string
	ExtraFields               map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseMinimumInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseMinimumIntervalJSON) RawJSON() string {
	return r.raw
}

// The Price Interval resource represents a period of time for which a price will
// bill on a subscription. A subscription’s price intervals define its billing
// behavior.
type SubscriptionUpdateTrialResponsePriceInterval struct {
	ID string `json:"id,required"`
	// The day of the month that Orb bills for this price
	BillingCycleDay int64 `json:"billing_cycle_day,required"`
	// The end of the current billing period. This is an exclusive timestamp, such that
	// the instant returned is exactly the end of the billing period. Set to null if
	// this price interval is not currently active.
	CurrentBillingPeriodEndDate time.Time `json:"current_billing_period_end_date,required,nullable" format:"date-time"`
	// The start date of the current billing period. This is an inclusive timestamp;
	// the instant returned is exactly the beginning of the billing period. Set to null
	// if this price interval is not currently active.
	CurrentBillingPeriodStartDate time.Time `json:"current_billing_period_start_date,required,nullable" format:"date-time"`
	// The end date of the price interval. This is the date that Orb stops billing for
	// this price.
	EndDate time.Time `json:"end_date,required,nullable" format:"date-time"`
	// The fixed fee quantity transitions for this price interval. This is only
	// relevant for fixed fees.
	FixedFeeQuantityTransitions []SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition `json:"fixed_fee_quantity_transitions,required,nullable"`
	// The Price resource represents a price that can be billed on a subscription,
	// resulting in a charge on an invoice in the form of an invoice line item. Prices
	// take a quantity and determine an amount to bill.
	//
	// Orb supports a few different pricing models out of the box. Each of these models
	// is serialized differently in a given Price object. The model_type field
	// determines the key for the configuration object that is present.
	//
	// ## Unit pricing
	//
	// With unit pricing, each unit costs a fixed amount.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	        "unit_amount": "0.50"
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered pricing
	//
	// In tiered pricing, the cost of a given unit depends on the tier range that it
	// falls into, where each tier range is defined by an upper and lower bound. For
	// example, the first ten units may cost $0.50 each and all units thereafter may
	// cost $0.10 each.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "tiered",
	//	    "tiered_config": {
	//	        "tiers": [
	//	            {
	//	                "first_unit": 1,
	//	                "last_unit": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "first_unit": 11,
	//	                "last_unit": null,
	//	                "unit_amount": "0.10"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//
	// ```
	//
	// ## Bulk pricing
	//
	// Bulk pricing applies when the number of units determine the cost of all units.
	// For example, if you've bought less than 10 units, they may each be $0.50 for a
	// total of $5.00. Once you've bought more than 10 units, all units may now be
	// priced at $0.40 (i.e. 101 units total would be $40.40).
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bulk",
	//	    "bulk_config": {
	//	        "tiers": [
	//	            {
	//	                "maximum_units": 10,
	//	                "unit_amount": "0.50"
	//	            },
	//	            {
	//	                "maximum_units": 1000,
	//	                "unit_amount": "0.40"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Package pricing
	//
	// Package pricing defines the size or granularity of a unit for billing purposes.
	// For example, if the package size is set to 5, then 4 units will be billed as 5
	// and 6 units will be billed at 10.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "package",
	//	    "package_config": {
	//	        "package_amount": "0.80",
	//	        "package_size": 10
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## BPS pricing
	//
	// BPS pricing specifies a per-event (e.g. per-payment) rate in one hundredth of a
	// percent (the number of basis points to charge), as well as a cap per event to
	// assess. For example, this would allow you to assess a fee of 0.25% on every
	// payment you process, with a maximum charge of $25 per payment.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "model_type": "bps",
	//	    "bps_config": {
	//	       "bps": 125,
	//	       "per_unit_maximum": "11.00"
	//	    }
	//	    ...
	//	 }
	//
	// ```
	//
	// ## Bulk BPS pricing
	//
	// Bulk BPS pricing specifies BPS parameters in a tiered manner, dependent on the
	// total quantity across all events. Similar to bulk pricing, the BPS parameters of
	// a given event depends on the tier range that the billing period falls into. Each
	// tier range is defined by an upper bound. For example, after $1.5M of payment
	// volume is reached, each individual payment may have a lower cap or a smaller
	// take-rate.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "bulk_bps",
	//	    "bulk_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Tiered BPS pricing
	//
	// Tiered BPS pricing specifies BPS parameters in a graduated manner, where an
	// event's applicable parameter is a function of its marginal addition to the
	// period total. Similar to tiered pricing, the BPS parameters of a given event
	// depends on the tier range that it falls into, where each tier range is defined
	// by an upper and lower bound. For example, the first few payments may have a 0.8
	// BPS take-rate and all payments after a specific volume may incur a take-rate of
	// 0.5 BPS each.
	//
	// ```json
	//
	//	    ...
	//	    "model_type": "tiered_bps",
	//	    "tiered_bps_config": {
	//	        "tiers": [
	//	           {
	//	                "minimum_amount": "0",
	//	                "maximum_amount": "1000000.00",
	//	                "bps": 125,
	//	                "per_unit_maximum": "19.00"
	//	           },
	//	          {
	//	                "minimum_amount": "1000000.00",
	//	                "maximum_amount": null,
	//	                "bps": 115,
	//	                "per_unit_maximum": "4.00"
	//	            }
	//	        ]
	//	    }
	//	    ...
	//	}
	//
	// ```
	//
	// ## Matrix pricing
	//
	// Matrix pricing defines a set of unit prices in a one or two-dimensional matrix.
	// `dimensions` defines the two event property values evaluated in this pricing
	// model. In a one-dimensional matrix, the second value is `null`. Every
	// configuration has a list of `matrix_values` which give the unit prices for
	// specified property values. In a one-dimensional matrix, the matrix values will
	// have `dimension_values` where the second value of the pair is null. If an event
	// does not match any of the dimension values in the matrix, it will resort to the
	// `default_unit_amount`.
	//
	// ```json
	//
	//	{
	//	    "model_type": "matrix"
	//	    "matrix_config": {
	//	        "default_unit_amount": "3.00",
	//	        "dimensions": [
	//	            "cluster_name",
	//	            "region"
	//	        ],
	//	        "matrix_values": [
	//	            {
	//	                "dimension_values": [
	//	                    "alpha",
	//	                    "west"
	//	                ],
	//	                "unit_amount": "2.00"
	//	            },
	//	            ...
	//	        ]
	//	    }
	//	}
	//
	// ```
	//
	// ## Fixed fees
	//
	// Fixed fees are prices that are applied independent of usage quantities, and
	// follow unit pricing. They also have an additional parameter
	// `fixed_price_quantity`. If the Price represents a fixed cost, this represents
	// the quantity of units applied.
	//
	// ```json
	//
	//	{
	//	    ...
	//	    "id": "price_id",
	//	    "model_type": "unit",
	//	    "unit_config": {
	//	       "unit_amount": "2.00"
	//	    },
	//	    "fixed_price_quantity": 3.0
	//	    ...
	//	}
	//
	// ```
	Price Price `json:"price,required"`
	// The start date of the price interval. This is the date that Orb starts billing
	// for this price.
	StartDate time.Time                                        `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponsePriceIntervalJSON `json:"-"`
}

// subscriptionUpdateTrialResponsePriceIntervalJSON contains the JSON metadata for
// the struct [SubscriptionUpdateTrialResponsePriceInterval]
type subscriptionUpdateTrialResponsePriceIntervalJSON struct {
	ID                            apijson.Field
	BillingCycleDay               apijson.Field
	CurrentBillingPeriodEndDate   apijson.Field
	CurrentBillingPeriodStartDate apijson.Field
	EndDate                       apijson.Field
	FixedFeeQuantityTransitions   apijson.Field
	Price                         apijson.Field
	StartDate                     apijson.Field
	raw                           string
	ExtraFields                   map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponsePriceInterval) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponsePriceIntervalJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition struct {
	EffectiveDate time.Time                                                                   `json:"effective_date,required" format:"date-time"`
	PriceID       string                                                                      `json:"price_id,required"`
	Quantity      int64                                                                       `json:"quantity,required"`
	JSON          subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON `json:"-"`
}

// subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON
// contains the JSON metadata for the struct
// [SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition]
type subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON struct {
	EffectiveDate apijson.Field
	PriceID       apijson.Field
	Quantity      apijson.Field
	raw           string
	ExtraFields   map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransition) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponsePriceIntervalsFixedFeeQuantityTransitionJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseRedeemedCoupon struct {
	CouponID  string                                            `json:"coupon_id,required"`
	EndDate   time.Time                                         `json:"end_date,required,nullable" format:"date-time"`
	StartDate time.Time                                         `json:"start_date,required" format:"date-time"`
	JSON      subscriptionUpdateTrialResponseRedeemedCouponJSON `json:"-"`
}

// subscriptionUpdateTrialResponseRedeemedCouponJSON contains the JSON metadata for
// the struct [SubscriptionUpdateTrialResponseRedeemedCoupon]
type subscriptionUpdateTrialResponseRedeemedCouponJSON struct {
	CouponID    apijson.Field
	EndDate     apijson.Field
	StartDate   apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseRedeemedCoupon) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseRedeemedCouponJSON) RawJSON() string {
	return r.raw
}

type SubscriptionUpdateTrialResponseStatus string

const (
	SubscriptionUpdateTrialResponseStatusActive   SubscriptionUpdateTrialResponseStatus = "active"
	SubscriptionUpdateTrialResponseStatusEnded    SubscriptionUpdateTrialResponseStatus = "ended"
	SubscriptionUpdateTrialResponseStatusUpcoming SubscriptionUpdateTrialResponseStatus = "upcoming"
)

func (r SubscriptionUpdateTrialResponseStatus) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialResponseStatusActive, SubscriptionUpdateTrialResponseStatusEnded, SubscriptionUpdateTrialResponseStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionUpdateTrialResponseTrialInfo struct {
	EndDate time.Time                                    `json:"end_date,required,nullable" format:"date-time"`
	JSON    subscriptionUpdateTrialResponseTrialInfoJSON `json:"-"`
}

// subscriptionUpdateTrialResponseTrialInfoJSON contains the JSON metadata for the
// struct [SubscriptionUpdateTrialResponseTrialInfo]
type subscriptionUpdateTrialResponseTrialInfoJSON struct {
	EndDate     apijson.Field
	raw         string
	ExtraFields map[string]apijson.Field
}

func (r *SubscriptionUpdateTrialResponseTrialInfo) UnmarshalJSON(data []byte) (err error) {
	return apijson.UnmarshalRoot(data, r)
}

func (r subscriptionUpdateTrialResponseTrialInfoJSON) RawJSON() string {
	return r.raw
}

type SubscriptionNewParams struct {
	// Additional adjustments to be added to the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	AddAdjustments param.Field[[]SubscriptionNewParamsAddAdjustment] `json:"add_adjustments"`
	// Additional prices to be added to the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	AddPrices                             param.Field[[]SubscriptionNewParamsAddPrice] `json:"add_prices"`
	AlignBillingWithSubscriptionStartDate param.Field[bool]                            `json:"align_billing_with_subscription_start_date"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. If not specified, this
	// defaults to the behavior configured for this customer.
	AutoCollection                  param.Field[bool]                                                 `json:"auto_collection"`
	AwsRegion                       param.Field[string]                                               `json:"aws_region"`
	BillingCycleAnchorConfiguration param.Field[SubscriptionNewParamsBillingCycleAnchorConfiguration] `json:"billing_cycle_anchor_configuration"`
	// Redemption code to be used for this subscription. If the coupon cannot be found
	// by its redemption code, or cannot be redeemed, an error response will be
	// returned and the subscription creation or plan change will not be scheduled.
	CouponRedemptionCode param.Field[string]  `json:"coupon_redemption_code"`
	CreditsOverageRate   param.Field[float64] `json:"credits_overage_rate"`
	CustomerID           param.Field[string]  `json:"customer_id"`
	// Determines the default memo on this subscription's invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo             param.Field[string]                                   `json:"default_invoice_memo"`
	EndDate                        param.Field[time.Time]                                `json:"end_date" format:"date-time"`
	ExternalCustomerID             param.Field[string]                                   `json:"external_customer_id"`
	ExternalMarketplace            param.Field[SubscriptionNewParamsExternalMarketplace] `json:"external_marketplace"`
	ExternalMarketplaceReportingID param.Field[string]                                   `json:"external_marketplace_reporting_id"`
	// The external_plan_id of the plan that the given subscription should be switched
	// to. Note that either this property or `plan_id` must be specified.
	ExternalPlanID param.Field[string] `json:"external_plan_id"`
	// An additional filter to apply to usage queries. This filter must be expressed as
	// a boolean
	// [computed property](../guides/extensibility/advanced-metrics#computed-properties).
	// If null, usage queries will not include any additional filter.
	Filter param.Field[string] `json:"filter"`
	// The phase of the plan to start with
	InitialPhaseOrder param.Field[int64] `json:"initial_phase_order"`
	// When this subscription's accrued usage reaches this threshold, an invoice will
	// be issued for the subscription. If not specified, invoices will only be issued
	// at the end of the billing period.
	InvoicingThreshold param.Field[string] `json:"invoicing_threshold"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// The net terms determines the difference between the invoice date and the issue
	// date for the invoice. If you intend the invoice to be due on issue, set this
	// to 0. If not provided, this defaults to the value specified in the plan.
	NetTerms               param.Field[int64]   `json:"net_terms"`
	PerCreditOverageAmount param.Field[float64] `json:"per_credit_overage_amount"`
	// The plan that the given subscription should be switched to. Note that either
	// this property or `external_plan_id` must be specified.
	PlanID param.Field[string] `json:"plan_id"`
	// Specifies which version of the plan to subscribe to. If null, the default
	// version will be used.
	PlanVersionNumber param.Field[int64] `json:"plan_version_number"`
	// Optionally provide a list of overrides for prices on the plan
	PriceOverrides param.Field[[]interface{}] `json:"price_overrides"`
	// Plan adjustments to be removed from the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	RemoveAdjustments param.Field[[]SubscriptionNewParamsRemoveAdjustment] `json:"remove_adjustments"`
	// Plan prices to be removed from the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	RemovePrices param.Field[[]SubscriptionNewParamsRemovePrice] `json:"remove_prices"`
	// Plan adjustments to be replaced with additional adjustments on the subscription.
	// (Only available for accounts that have migrated off of legacy subscription
	// overrides)
	ReplaceAdjustments param.Field[[]SubscriptionNewParamsReplaceAdjustment] `json:"replace_adjustments"`
	// Plan prices to be replaced with additional prices on the subscription. (Only
	// available for accounts that have migrated off of legacy subscription overrides)
	ReplacePrices param.Field[[]SubscriptionNewParamsReplacePrice] `json:"replace_prices"`
	StartDate     param.Field[time.Time]                           `json:"start_date" format:"date-time"`
	// The duration of the trial period in days. If not provided, this defaults to the
	// value specified in the plan. If `0` is provided, the trial on the plan will be
	// skipped.
	TrialDurationDays param.Field[int64] `json:"trial_duration_days"`
}

func (r SubscriptionNewParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddAdjustment struct {
	// The definition of a new adjustment to create and add to the subscription.
	Adjustment param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentUnion] `json:"adjustment,required"`
	// The end date of the adjustment interval. This is the date that the adjustment
	// will stop affecting prices on the subscription. If null, the adjustment will
	// start when the phase or subscription starts.
	EndDate param.Field[time.Time] `json:"end_date" format:"date-time"`
	// The phase to add this adjustment to.
	PlanPhaseOrder param.Field[int64] `json:"plan_phase_order"`
	// The start date of the adjustment interval. This is the date that the adjustment
	// will start affecting prices on the subscription. If null, the adjustment will
	// start when the phase or subscription starts.
	StartDate param.Field[time.Time] `json:"start_date" format:"date-time"`
}

func (r SubscriptionNewParamsAddAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new adjustment to create and add to the subscription.
type SubscriptionNewParamsAddAdjustmentsAdjustment struct {
	AdjustmentType    param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType] `json:"adjustment_type,required"`
	AppliesToPriceIDs param.Field[interface{}]                                                 `json:"applies_to_price_ids,required"`
	AmountDiscount    param.Field[string]                                                      `json:"amount_discount"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID             param.Field[string]  `json:"item_id"`
	MaximumAmount      param.Field[string]  `json:"maximum_amount"`
	MinimumAmount      param.Field[string]  `json:"minimum_amount"`
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	UsageDiscount      param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustment) implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {
}

// The definition of a new adjustment to create and add to the subscription.
//
// Satisfied by
// [SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscount],
// [SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscount],
// [SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscount],
// [SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimum],
// [SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximum],
// [SubscriptionNewParamsAddAdjustmentsAdjustment].
type SubscriptionNewParamsAddAdjustmentsAdjustmentUnion interface {
	implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion()
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscount struct {
	AdjustmentType param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs  param.Field[[]string] `json:"applies_to_price_ids,required"`
	PercentageDiscount param.Field[float64]  `json:"percentage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscount) implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType string

const (
	SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscount struct {
	AdjustmentType param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	UsageDiscount     param.Field[float64]  `json:"usage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscount) implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType string

const (
	SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType = "usage_discount"
)

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscount struct {
	AdjustmentType param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                                                                       `json:"amount_discount,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscount) implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType string

const (
	SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType = "amount_discount"
)

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimum struct {
	AdjustmentType param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimum) implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType string

const (
	SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType = "minimum"
)

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximum struct {
	AdjustmentType param.Field[SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	MaximumAmount     param.Field[string]   `json:"maximum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximum) implementsSubscriptionNewParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType string

const (
	SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType = "maximum"
)

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType string

const (
	SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum            SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType = "minimum"
	SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum            SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum, SubscriptionNewParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPrice struct {
	// [DEPRECATED] Use add_adjustments instead. The subscription's discounts for this
	// price.
	Discounts param.Field[[]SubscriptionNewParamsAddPricesDiscount] `json:"discounts"`
	// The end date of the price interval. This is the date that the price will stop
	// billing on the subscription. If null, billing will end when the phase or
	// subscription ends.
	EndDate param.Field[time.Time] `json:"end_date" format:"date-time"`
	// The external price id of the price to add to the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's maximum amount for
	// this price.
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's minimum amount for
	// this price.
	MinimumAmount param.Field[string] `json:"minimum_amount"`
	// The phase to add this price to.
	PlanPhaseOrder param.Field[int64] `json:"plan_phase_order"`
	// The definition of a new price to create and add to the subscription.
	Price param.Field[SubscriptionNewParamsAddPricesPriceUnion] `json:"price"`
	// The id of the price to add to the subscription.
	PriceID param.Field[string] `json:"price_id"`
	// The start date of the price interval. This is the date that the price will start
	// billing on the subscription. If null, billing will start when the phase or
	// subscription starts.
	StartDate param.Field[time.Time] `json:"start_date" format:"date-time"`
}

func (r SubscriptionNewParamsAddPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesDiscount struct {
	DiscountType param.Field[SubscriptionNewParamsAddPricesDiscountsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[string] `json:"amount_discount"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionNewParamsAddPricesDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesDiscountsDiscountType string

const (
	SubscriptionNewParamsAddPricesDiscountsDiscountTypePercentage SubscriptionNewParamsAddPricesDiscountsDiscountType = "percentage"
	SubscriptionNewParamsAddPricesDiscountsDiscountTypeUsage      SubscriptionNewParamsAddPricesDiscountsDiscountType = "usage"
	SubscriptionNewParamsAddPricesDiscountsDiscountTypeAmount     SubscriptionNewParamsAddPricesDiscountsDiscountType = "amount"
)

func (r SubscriptionNewParamsAddPricesDiscountsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesDiscountsDiscountTypePercentage, SubscriptionNewParamsAddPricesDiscountsDiscountTypeUsage, SubscriptionNewParamsAddPricesDiscountsDiscountTypeAmount:
		return true
	}
	return false
}

// The definition of a new price to create and add to the subscription.
type SubscriptionNewParamsAddPricesPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                       `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance           param.Field[bool]        `json:"billed_in_advance"`
	BillingCycleConfiguration param.Field[interface{}] `json:"billing_cycle_configuration"`
	BpsConfig                 param.Field[interface{}] `json:"bps_config"`
	BulkBpsConfig             param.Field[interface{}] `json:"bulk_bps_config"`
	BulkConfig                param.Field[interface{}] `json:"bulk_config"`
	BulkWithProrationConfig   param.Field[interface{}] `json:"bulk_with_proration_config"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity               param.Field[float64]     `json:"fixed_price_quantity"`
	GroupedAllocationConfig          param.Field[interface{}] `json:"grouped_allocation_config"`
	GroupedWithProratedMinimumConfig param.Field[interface{}] `json:"grouped_with_prorated_minimum_config"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey          param.Field[string]      `json:"invoice_grouping_key"`
	InvoicingCycleConfiguration param.Field[interface{}] `json:"invoicing_cycle_configuration"`
	MatrixConfig                param.Field[interface{}] `json:"matrix_config"`
	Metadata                    param.Field[interface{}] `json:"metadata"`
	PackageConfig               param.Field[interface{}] `json:"package_config"`
	PackageWithAllocationConfig param.Field[interface{}] `json:"package_with_allocation_config"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID                param.Field[string]      `json:"reference_id"`
	ThresholdTotalAmountConfig param.Field[interface{}] `json:"threshold_total_amount_config"`
	TieredBpsConfig            param.Field[interface{}] `json:"tiered_bps_config"`
	TieredConfig               param.Field[interface{}] `json:"tiered_config"`
	TieredPackageConfig        param.Field[interface{}] `json:"tiered_package_config"`
	TieredWithMinimumConfig    param.Field[interface{}] `json:"tiered_with_minimum_config"`
	TieredWithProrationConfig  param.Field[interface{}] `json:"tiered_with_proration_config"`
	UnitConfig                 param.Field[interface{}] `json:"unit_config"`
	UnitWithPercentConfig      param.Field[interface{}] `json:"unit_with_percent_config"`
	UnitWithProrationConfig    param.Field[interface{}] `json:"unit_with_proration_config"`
}

func (r SubscriptionNewParamsAddPricesPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {}

// The definition of a new price to create and add to the subscription.
//
// Satisfied by [SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice],
// [SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice],
// [SubscriptionNewParamsAddPricesPrice].
type SubscriptionNewParamsAddPricesPriceUnion interface {
	implementsSubscriptionNewParamsAddPricesPriceUnion()
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]                                                                `json:"name,required"`
	UnitConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceUnitConfig] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceModelTypeUnit SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceModelType = "unit"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceUnitConfig struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceUnitConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]                                                                      `json:"name,required"`
	PackageConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePricePackageConfig] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceModelTypePackage SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceModelType = "package"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceModelTypePackage:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePricePackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePricePackageConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID       param.Field[string]                                                                    `json:"item_id,required"`
	MatrixConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfig] `json:"matrix_config,required"`
	ModelType    param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceModelType]    `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceModelTypeMatrix SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceModelType = "matrix"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]                                                                    `json:"name,required"`
	TieredConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfig] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceModelTypeTiered SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceModelType = "tiered"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfigTier struct {
	// Inclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Exclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                    `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]                                                                          `json:"name,required"`
	TieredBpsConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType = "tiered_bps"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier struct {
	// Per-event basis point rate
	Bps param.Field[float64] `json:"bps,required"`
	// Inclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Exclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPrice struct {
	BpsConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBpsConfig] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                              `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBpsConfig struct {
	// Basis point take rate per event
	Bps param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceModelTypeBps SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceModelType = "bps"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceModelTypeBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPrice struct {
	BulkBpsConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier struct {
	// Basis points to rate on
	Bps param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType = "bulk_bps"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPrice struct {
	BulkConfig param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfig] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfigTier struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceModelTypeBulk SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceModelType = "bulk"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                        `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType = "tiered_package"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                          `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType = "tiered_with_proration"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence                 param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence] `json:"cadence,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}]                                                          `json:"grouped_allocation_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence                          param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}]                                                                   `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice) implementsSubscriptionNewParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// The cadence to bill for this price on.
type SubscriptionNewParamsAddPricesPriceCadence string

const (
	SubscriptionNewParamsAddPricesPriceCadenceAnnual     SubscriptionNewParamsAddPricesPriceCadence = "annual"
	SubscriptionNewParamsAddPricesPriceCadenceSemiAnnual SubscriptionNewParamsAddPricesPriceCadence = "semi_annual"
	SubscriptionNewParamsAddPricesPriceCadenceMonthly    SubscriptionNewParamsAddPricesPriceCadence = "monthly"
	SubscriptionNewParamsAddPricesPriceCadenceQuarterly  SubscriptionNewParamsAddPricesPriceCadence = "quarterly"
	SubscriptionNewParamsAddPricesPriceCadenceOneTime    SubscriptionNewParamsAddPricesPriceCadence = "one_time"
	SubscriptionNewParamsAddPricesPriceCadenceCustom     SubscriptionNewParamsAddPricesPriceCadence = "custom"
)

func (r SubscriptionNewParamsAddPricesPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceCadenceAnnual, SubscriptionNewParamsAddPricesPriceCadenceSemiAnnual, SubscriptionNewParamsAddPricesPriceCadenceMonthly, SubscriptionNewParamsAddPricesPriceCadenceQuarterly, SubscriptionNewParamsAddPricesPriceCadenceOneTime, SubscriptionNewParamsAddPricesPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsAddPricesPriceModelType string

const (
	SubscriptionNewParamsAddPricesPriceModelTypeUnit                       SubscriptionNewParamsAddPricesPriceModelType = "unit"
	SubscriptionNewParamsAddPricesPriceModelTypePackage                    SubscriptionNewParamsAddPricesPriceModelType = "package"
	SubscriptionNewParamsAddPricesPriceModelTypeMatrix                     SubscriptionNewParamsAddPricesPriceModelType = "matrix"
	SubscriptionNewParamsAddPricesPriceModelTypeTiered                     SubscriptionNewParamsAddPricesPriceModelType = "tiered"
	SubscriptionNewParamsAddPricesPriceModelTypeTieredBps                  SubscriptionNewParamsAddPricesPriceModelType = "tiered_bps"
	SubscriptionNewParamsAddPricesPriceModelTypeBps                        SubscriptionNewParamsAddPricesPriceModelType = "bps"
	SubscriptionNewParamsAddPricesPriceModelTypeBulkBps                    SubscriptionNewParamsAddPricesPriceModelType = "bulk_bps"
	SubscriptionNewParamsAddPricesPriceModelTypeBulk                       SubscriptionNewParamsAddPricesPriceModelType = "bulk"
	SubscriptionNewParamsAddPricesPriceModelTypeThresholdTotalAmount       SubscriptionNewParamsAddPricesPriceModelType = "threshold_total_amount"
	SubscriptionNewParamsAddPricesPriceModelTypeTieredPackage              SubscriptionNewParamsAddPricesPriceModelType = "tiered_package"
	SubscriptionNewParamsAddPricesPriceModelTypeTieredWithMinimum          SubscriptionNewParamsAddPricesPriceModelType = "tiered_with_minimum"
	SubscriptionNewParamsAddPricesPriceModelTypeUnitWithPercent            SubscriptionNewParamsAddPricesPriceModelType = "unit_with_percent"
	SubscriptionNewParamsAddPricesPriceModelTypePackageWithAllocation      SubscriptionNewParamsAddPricesPriceModelType = "package_with_allocation"
	SubscriptionNewParamsAddPricesPriceModelTypeTieredWithProration        SubscriptionNewParamsAddPricesPriceModelType = "tiered_with_proration"
	SubscriptionNewParamsAddPricesPriceModelTypeUnitWithProration          SubscriptionNewParamsAddPricesPriceModelType = "unit_with_proration"
	SubscriptionNewParamsAddPricesPriceModelTypeGroupedAllocation          SubscriptionNewParamsAddPricesPriceModelType = "grouped_allocation"
	SubscriptionNewParamsAddPricesPriceModelTypeGroupedWithProratedMinimum SubscriptionNewParamsAddPricesPriceModelType = "grouped_with_prorated_minimum"
	SubscriptionNewParamsAddPricesPriceModelTypeBulkWithProration          SubscriptionNewParamsAddPricesPriceModelType = "bulk_with_proration"
)

func (r SubscriptionNewParamsAddPricesPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsAddPricesPriceModelTypeUnit, SubscriptionNewParamsAddPricesPriceModelTypePackage, SubscriptionNewParamsAddPricesPriceModelTypeMatrix, SubscriptionNewParamsAddPricesPriceModelTypeTiered, SubscriptionNewParamsAddPricesPriceModelTypeTieredBps, SubscriptionNewParamsAddPricesPriceModelTypeBps, SubscriptionNewParamsAddPricesPriceModelTypeBulkBps, SubscriptionNewParamsAddPricesPriceModelTypeBulk, SubscriptionNewParamsAddPricesPriceModelTypeThresholdTotalAmount, SubscriptionNewParamsAddPricesPriceModelTypeTieredPackage, SubscriptionNewParamsAddPricesPriceModelTypeTieredWithMinimum, SubscriptionNewParamsAddPricesPriceModelTypeUnitWithPercent, SubscriptionNewParamsAddPricesPriceModelTypePackageWithAllocation, SubscriptionNewParamsAddPricesPriceModelTypeTieredWithProration, SubscriptionNewParamsAddPricesPriceModelTypeUnitWithProration, SubscriptionNewParamsAddPricesPriceModelTypeGroupedAllocation, SubscriptionNewParamsAddPricesPriceModelTypeGroupedWithProratedMinimum, SubscriptionNewParamsAddPricesPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

type SubscriptionNewParamsBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day param.Field[int64] `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month param.Field[int64] `json:"month"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year param.Field[int64] `json:"year"`
}

func (r SubscriptionNewParamsBillingCycleAnchorConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsExternalMarketplace string

const (
	SubscriptionNewParamsExternalMarketplaceGoogle SubscriptionNewParamsExternalMarketplace = "google"
	SubscriptionNewParamsExternalMarketplaceAws    SubscriptionNewParamsExternalMarketplace = "aws"
	SubscriptionNewParamsExternalMarketplaceAzure  SubscriptionNewParamsExternalMarketplace = "azure"
)

func (r SubscriptionNewParamsExternalMarketplace) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsExternalMarketplaceGoogle, SubscriptionNewParamsExternalMarketplaceAws, SubscriptionNewParamsExternalMarketplaceAzure:
		return true
	}
	return false
}

type SubscriptionNewParamsRemoveAdjustment struct {
	// The id of the adjustment to remove on the subscription.
	AdjustmentID param.Field[string] `json:"adjustment_id,required"`
}

func (r SubscriptionNewParamsRemoveAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsRemovePrice struct {
	// The external price id of the price to remove on the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// The id of the price to remove on the subscription.
	PriceID param.Field[string] `json:"price_id"`
}

func (r SubscriptionNewParamsRemovePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplaceAdjustment struct {
	// The definition of a new adjustment to create and add to the subscription.
	Adjustment param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion] `json:"adjustment,required"`
	// The id of the adjustment on the plan to replace in the subscription.
	ReplacesAdjustmentID param.Field[string] `json:"replaces_adjustment_id,required"`
}

func (r SubscriptionNewParamsReplaceAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new adjustment to create and add to the subscription.
type SubscriptionNewParamsReplaceAdjustmentsAdjustment struct {
	AdjustmentType    param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType] `json:"adjustment_type,required"`
	AppliesToPriceIDs param.Field[interface{}]                                                     `json:"applies_to_price_ids,required"`
	AmountDiscount    param.Field[string]                                                          `json:"amount_discount"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID             param.Field[string]  `json:"item_id"`
	MaximumAmount      param.Field[string]  `json:"maximum_amount"`
	MinimumAmount      param.Field[string]  `json:"minimum_amount"`
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	UsageDiscount      param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustment) implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

// The definition of a new adjustment to create and add to the subscription.
//
// Satisfied by
// [SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount],
// [SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscount],
// [SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscount],
// [SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimum],
// [SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximum],
// [SubscriptionNewParamsReplaceAdjustmentsAdjustment].
type SubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion interface {
	implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion()
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount struct {
	AdjustmentType param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs  param.Field[[]string] `json:"applies_to_price_ids,required"`
	PercentageDiscount param.Field[float64]  `json:"percentage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount) implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType string

const (
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscount struct {
	AdjustmentType param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	UsageDiscount     param.Field[float64]  `json:"usage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscount) implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType string

const (
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType = "usage_discount"
)

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscount struct {
	AdjustmentType param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                                                                           `json:"amount_discount,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscount) implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType string

const (
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType = "amount_discount"
)

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimum struct {
	AdjustmentType param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimum) implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType string

const (
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType = "minimum"
)

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximum struct {
	AdjustmentType param.Field[SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	MaximumAmount     param.Field[string]   `json:"maximum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximum) implementsSubscriptionNewParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType string

const (
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType = "maximum"
)

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType string

const (
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypePercentageDiscount SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMinimum            SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType = "minimum"
	SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMaximum            SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMinimum, SubscriptionNewParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePrice struct {
	// The id of the price on the plan to replace in the subscription.
	ReplacesPriceID param.Field[string] `json:"replaces_price_id,required"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's discounts for the
	// replacement price.
	Discounts param.Field[[]SubscriptionNewParamsReplacePricesDiscount] `json:"discounts"`
	// The external price id of the price to add to the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// The new quantity of the price, if the price is a fixed price.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's maximum amount for
	// the replacement price.
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's minimum amount for
	// the replacement price.
	MinimumAmount param.Field[string] `json:"minimum_amount"`
	// The definition of a new price to create and add to the subscription.
	Price param.Field[SubscriptionNewParamsReplacePricesPriceUnion] `json:"price"`
	// The id of the price to add to the subscription.
	PriceID param.Field[string] `json:"price_id"`
}

func (r SubscriptionNewParamsReplacePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesDiscount struct {
	DiscountType param.Field[SubscriptionNewParamsReplacePricesDiscountsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[string] `json:"amount_discount"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionNewParamsReplacePricesDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesDiscountsDiscountType string

const (
	SubscriptionNewParamsReplacePricesDiscountsDiscountTypePercentage SubscriptionNewParamsReplacePricesDiscountsDiscountType = "percentage"
	SubscriptionNewParamsReplacePricesDiscountsDiscountTypeUsage      SubscriptionNewParamsReplacePricesDiscountsDiscountType = "usage"
	SubscriptionNewParamsReplacePricesDiscountsDiscountTypeAmount     SubscriptionNewParamsReplacePricesDiscountsDiscountType = "amount"
)

func (r SubscriptionNewParamsReplacePricesDiscountsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesDiscountsDiscountTypePercentage, SubscriptionNewParamsReplacePricesDiscountsDiscountTypeUsage, SubscriptionNewParamsReplacePricesDiscountsDiscountTypeAmount:
		return true
	}
	return false
}

// The definition of a new price to create and add to the subscription.
type SubscriptionNewParamsReplacePricesPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance           param.Field[bool]        `json:"billed_in_advance"`
	BillingCycleConfiguration param.Field[interface{}] `json:"billing_cycle_configuration"`
	BpsConfig                 param.Field[interface{}] `json:"bps_config"`
	BulkBpsConfig             param.Field[interface{}] `json:"bulk_bps_config"`
	BulkConfig                param.Field[interface{}] `json:"bulk_config"`
	BulkWithProrationConfig   param.Field[interface{}] `json:"bulk_with_proration_config"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity               param.Field[float64]     `json:"fixed_price_quantity"`
	GroupedAllocationConfig          param.Field[interface{}] `json:"grouped_allocation_config"`
	GroupedWithProratedMinimumConfig param.Field[interface{}] `json:"grouped_with_prorated_minimum_config"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey          param.Field[string]      `json:"invoice_grouping_key"`
	InvoicingCycleConfiguration param.Field[interface{}] `json:"invoicing_cycle_configuration"`
	MatrixConfig                param.Field[interface{}] `json:"matrix_config"`
	Metadata                    param.Field[interface{}] `json:"metadata"`
	PackageConfig               param.Field[interface{}] `json:"package_config"`
	PackageWithAllocationConfig param.Field[interface{}] `json:"package_with_allocation_config"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID                param.Field[string]      `json:"reference_id"`
	ThresholdTotalAmountConfig param.Field[interface{}] `json:"threshold_total_amount_config"`
	TieredBpsConfig            param.Field[interface{}] `json:"tiered_bps_config"`
	TieredConfig               param.Field[interface{}] `json:"tiered_config"`
	TieredPackageConfig        param.Field[interface{}] `json:"tiered_package_config"`
	TieredWithMinimumConfig    param.Field[interface{}] `json:"tiered_with_minimum_config"`
	TieredWithProrationConfig  param.Field[interface{}] `json:"tiered_with_proration_config"`
	UnitConfig                 param.Field[interface{}] `json:"unit_config"`
	UnitWithPercentConfig      param.Field[interface{}] `json:"unit_with_percent_config"`
	UnitWithProrationConfig    param.Field[interface{}] `json:"unit_with_proration_config"`
}

func (r SubscriptionNewParamsReplacePricesPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The definition of a new price to create and add to the subscription.
//
// Satisfied by [SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice],
// [SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice],
// [SubscriptionNewParamsReplacePricesPrice].
type SubscriptionNewParamsReplacePricesPriceUnion interface {
	implementsSubscriptionNewParamsReplacePricesPriceUnion()
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]                                                                    `json:"name,required"`
	UnitConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceUnitConfig] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceModelTypeUnit SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceModelType = "unit"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceUnitConfig struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceUnitConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                      `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]                                                                          `json:"name,required"`
	PackageConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePricePackageConfig] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceModelTypePackage SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceModelType = "package"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceModelTypePackage:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePricePackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePricePackageConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID       param.Field[string]                                                                        `json:"item_id,required"`
	MatrixConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfig] `json:"matrix_config,required"`
	ModelType    param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType]    `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceModelTypeMatrix SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType = "matrix"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]                                                                        `json:"name,required"`
	TieredConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfig] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceModelTypeTiered SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceModelType = "tiered"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfigTier struct {
	// Inclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Exclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                        `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]                                                                              `json:"name,required"`
	TieredBpsConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType = "tiered_bps"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier struct {
	// Per-event basis point rate
	Bps param.Field[float64] `json:"bps,required"`
	// Inclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Exclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPrice struct {
	BpsConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBpsConfig] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBpsConfig struct {
	// Basis point take rate per event
	Bps param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceModelTypeBps SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceModelType = "bps"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceModelTypeBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPrice struct {
	BulkBpsConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                      `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier struct {
	// Basis points to rate on
	Bps param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType = "bulk_bps"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPrice struct {
	BulkConfig param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfig] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfigTier] `json:"tiers,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfigTier struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceModelTypeBulk SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceModelType = "bulk"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType = "tiered_package"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                              `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                    `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType = "tiered_with_proration"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence                 param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence] `json:"cadence,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}]                                                              `json:"grouped_allocation_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence                          param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}]                                                                       `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice) implementsSubscriptionNewParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionNewParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// The cadence to bill for this price on.
type SubscriptionNewParamsReplacePricesPriceCadence string

const (
	SubscriptionNewParamsReplacePricesPriceCadenceAnnual     SubscriptionNewParamsReplacePricesPriceCadence = "annual"
	SubscriptionNewParamsReplacePricesPriceCadenceSemiAnnual SubscriptionNewParamsReplacePricesPriceCadence = "semi_annual"
	SubscriptionNewParamsReplacePricesPriceCadenceMonthly    SubscriptionNewParamsReplacePricesPriceCadence = "monthly"
	SubscriptionNewParamsReplacePricesPriceCadenceQuarterly  SubscriptionNewParamsReplacePricesPriceCadence = "quarterly"
	SubscriptionNewParamsReplacePricesPriceCadenceOneTime    SubscriptionNewParamsReplacePricesPriceCadence = "one_time"
	SubscriptionNewParamsReplacePricesPriceCadenceCustom     SubscriptionNewParamsReplacePricesPriceCadence = "custom"
)

func (r SubscriptionNewParamsReplacePricesPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceCadenceAnnual, SubscriptionNewParamsReplacePricesPriceCadenceSemiAnnual, SubscriptionNewParamsReplacePricesPriceCadenceMonthly, SubscriptionNewParamsReplacePricesPriceCadenceQuarterly, SubscriptionNewParamsReplacePricesPriceCadenceOneTime, SubscriptionNewParamsReplacePricesPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionNewParamsReplacePricesPriceModelType string

const (
	SubscriptionNewParamsReplacePricesPriceModelTypeUnit                       SubscriptionNewParamsReplacePricesPriceModelType = "unit"
	SubscriptionNewParamsReplacePricesPriceModelTypePackage                    SubscriptionNewParamsReplacePricesPriceModelType = "package"
	SubscriptionNewParamsReplacePricesPriceModelTypeMatrix                     SubscriptionNewParamsReplacePricesPriceModelType = "matrix"
	SubscriptionNewParamsReplacePricesPriceModelTypeTiered                     SubscriptionNewParamsReplacePricesPriceModelType = "tiered"
	SubscriptionNewParamsReplacePricesPriceModelTypeTieredBps                  SubscriptionNewParamsReplacePricesPriceModelType = "tiered_bps"
	SubscriptionNewParamsReplacePricesPriceModelTypeBps                        SubscriptionNewParamsReplacePricesPriceModelType = "bps"
	SubscriptionNewParamsReplacePricesPriceModelTypeBulkBps                    SubscriptionNewParamsReplacePricesPriceModelType = "bulk_bps"
	SubscriptionNewParamsReplacePricesPriceModelTypeBulk                       SubscriptionNewParamsReplacePricesPriceModelType = "bulk"
	SubscriptionNewParamsReplacePricesPriceModelTypeThresholdTotalAmount       SubscriptionNewParamsReplacePricesPriceModelType = "threshold_total_amount"
	SubscriptionNewParamsReplacePricesPriceModelTypeTieredPackage              SubscriptionNewParamsReplacePricesPriceModelType = "tiered_package"
	SubscriptionNewParamsReplacePricesPriceModelTypeTieredWithMinimum          SubscriptionNewParamsReplacePricesPriceModelType = "tiered_with_minimum"
	SubscriptionNewParamsReplacePricesPriceModelTypeUnitWithPercent            SubscriptionNewParamsReplacePricesPriceModelType = "unit_with_percent"
	SubscriptionNewParamsReplacePricesPriceModelTypePackageWithAllocation      SubscriptionNewParamsReplacePricesPriceModelType = "package_with_allocation"
	SubscriptionNewParamsReplacePricesPriceModelTypeTieredWithProration        SubscriptionNewParamsReplacePricesPriceModelType = "tiered_with_proration"
	SubscriptionNewParamsReplacePricesPriceModelTypeUnitWithProration          SubscriptionNewParamsReplacePricesPriceModelType = "unit_with_proration"
	SubscriptionNewParamsReplacePricesPriceModelTypeGroupedAllocation          SubscriptionNewParamsReplacePricesPriceModelType = "grouped_allocation"
	SubscriptionNewParamsReplacePricesPriceModelTypeGroupedWithProratedMinimum SubscriptionNewParamsReplacePricesPriceModelType = "grouped_with_prorated_minimum"
	SubscriptionNewParamsReplacePricesPriceModelTypeBulkWithProration          SubscriptionNewParamsReplacePricesPriceModelType = "bulk_with_proration"
)

func (r SubscriptionNewParamsReplacePricesPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionNewParamsReplacePricesPriceModelTypeUnit, SubscriptionNewParamsReplacePricesPriceModelTypePackage, SubscriptionNewParamsReplacePricesPriceModelTypeMatrix, SubscriptionNewParamsReplacePricesPriceModelTypeTiered, SubscriptionNewParamsReplacePricesPriceModelTypeTieredBps, SubscriptionNewParamsReplacePricesPriceModelTypeBps, SubscriptionNewParamsReplacePricesPriceModelTypeBulkBps, SubscriptionNewParamsReplacePricesPriceModelTypeBulk, SubscriptionNewParamsReplacePricesPriceModelTypeThresholdTotalAmount, SubscriptionNewParamsReplacePricesPriceModelTypeTieredPackage, SubscriptionNewParamsReplacePricesPriceModelTypeTieredWithMinimum, SubscriptionNewParamsReplacePricesPriceModelTypeUnitWithPercent, SubscriptionNewParamsReplacePricesPriceModelTypePackageWithAllocation, SubscriptionNewParamsReplacePricesPriceModelTypeTieredWithProration, SubscriptionNewParamsReplacePricesPriceModelTypeUnitWithProration, SubscriptionNewParamsReplacePricesPriceModelTypeGroupedAllocation, SubscriptionNewParamsReplacePricesPriceModelTypeGroupedWithProratedMinimum, SubscriptionNewParamsReplacePricesPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

type SubscriptionUpdateParams struct {
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. This property defaults to
	// the plan's behavior.
	AutoCollection param.Field[bool] `json:"auto_collection"`
	// Determines the default memo on this subscription's invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo param.Field[string] `json:"default_invoice_memo"`
	// When this subscription's accrued usage reaches this threshold, an invoice will
	// be issued for the subscription. If not specified, invoices will only be issued
	// at the end of the billing period.
	InvoicingThreshold param.Field[string] `json:"invoicing_threshold"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// Determines the difference between the invoice issue date for subscription
	// invoices as the date that they are due. A value of `0` here represents that the
	// invoice is due on issue, whereas a value of `30` represents that the customer
	// has a month to pay the invoice.
	NetTerms param.Field[int64] `json:"net_terms"`
}

func (r SubscriptionUpdateParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionListParams struct {
	CreatedAtGt  param.Field[time.Time] `query:"created_at[gt]" format:"date-time"`
	CreatedAtGte param.Field[time.Time] `query:"created_at[gte]" format:"date-time"`
	CreatedAtLt  param.Field[time.Time] `query:"created_at[lt]" format:"date-time"`
	CreatedAtLte param.Field[time.Time] `query:"created_at[lte]" format:"date-time"`
	// Cursor for pagination. This can be populated by the `next_cursor` value returned
	// from the initial request.
	Cursor             param.Field[string]   `query:"cursor"`
	CustomerID         param.Field[[]string] `query:"customer_id"`
	ExternalCustomerID param.Field[string]   `query:"external_customer_id"`
	// The number of items to fetch. Defaults to 20.
	Limit  param.Field[int64]                        `query:"limit"`
	Status param.Field[SubscriptionListParamsStatus] `query:"status"`
}

// URLQuery serializes [SubscriptionListParams]'s query parameters as `url.Values`.
func (r SubscriptionListParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

type SubscriptionListParamsStatus string

const (
	SubscriptionListParamsStatusActive   SubscriptionListParamsStatus = "active"
	SubscriptionListParamsStatusEnded    SubscriptionListParamsStatus = "ended"
	SubscriptionListParamsStatusUpcoming SubscriptionListParamsStatus = "upcoming"
)

func (r SubscriptionListParamsStatus) IsKnown() bool {
	switch r {
	case SubscriptionListParamsStatusActive, SubscriptionListParamsStatusEnded, SubscriptionListParamsStatusUpcoming:
		return true
	}
	return false
}

type SubscriptionCancelParams struct {
	// Determines the timing of subscription cancellation
	CancelOption param.Field[SubscriptionCancelParamsCancelOption] `json:"cancel_option,required"`
	// The date that the cancellation should take effect. This parameter can only be
	// passed if the `cancel_option` is `requested_date`.
	CancellationDate param.Field[time.Time] `json:"cancellation_date" format:"date-time"`
}

func (r SubscriptionCancelParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// Determines the timing of subscription cancellation
type SubscriptionCancelParamsCancelOption string

const (
	SubscriptionCancelParamsCancelOptionEndOfSubscriptionTerm SubscriptionCancelParamsCancelOption = "end_of_subscription_term"
	SubscriptionCancelParamsCancelOptionImmediate             SubscriptionCancelParamsCancelOption = "immediate"
	SubscriptionCancelParamsCancelOptionRequestedDate         SubscriptionCancelParamsCancelOption = "requested_date"
)

func (r SubscriptionCancelParamsCancelOption) IsKnown() bool {
	switch r {
	case SubscriptionCancelParamsCancelOptionEndOfSubscriptionTerm, SubscriptionCancelParamsCancelOptionImmediate, SubscriptionCancelParamsCancelOptionRequestedDate:
		return true
	}
	return false
}

type SubscriptionFetchCostsParams struct {
	// The currency or custom pricing unit to use.
	Currency param.Field[string] `query:"currency"`
	// Costs returned are exclusive of `timeframe_end`.
	TimeframeEnd param.Field[time.Time] `query:"timeframe_end" format:"date-time"`
	// Costs returned are inclusive of `timeframe_start`.
	TimeframeStart param.Field[time.Time] `query:"timeframe_start" format:"date-time"`
	// Controls whether Orb returns cumulative costs since the start of the billing
	// period, or incremental day-by-day costs. If your customer has minimums or
	// discounts, it's strongly recommended that you use the default cumulative
	// behavior.
	ViewMode param.Field[SubscriptionFetchCostsParamsViewMode] `query:"view_mode"`
}

// URLQuery serializes [SubscriptionFetchCostsParams]'s query parameters as
// `url.Values`.
func (r SubscriptionFetchCostsParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

// Controls whether Orb returns cumulative costs since the start of the billing
// period, or incremental day-by-day costs. If your customer has minimums or
// discounts, it's strongly recommended that you use the default cumulative
// behavior.
type SubscriptionFetchCostsParamsViewMode string

const (
	SubscriptionFetchCostsParamsViewModePeriodic   SubscriptionFetchCostsParamsViewMode = "periodic"
	SubscriptionFetchCostsParamsViewModeCumulative SubscriptionFetchCostsParamsViewMode = "cumulative"
)

func (r SubscriptionFetchCostsParamsViewMode) IsKnown() bool {
	switch r {
	case SubscriptionFetchCostsParamsViewModePeriodic, SubscriptionFetchCostsParamsViewModeCumulative:
		return true
	}
	return false
}

type SubscriptionFetchScheduleParams struct {
	// Cursor for pagination. This can be populated by the `next_cursor` value returned
	// from the initial request.
	Cursor param.Field[string] `query:"cursor"`
	// The number of items to fetch. Defaults to 20.
	Limit        param.Field[int64]     `query:"limit"`
	StartDateGt  param.Field[time.Time] `query:"start_date[gt]" format:"date-time"`
	StartDateGte param.Field[time.Time] `query:"start_date[gte]" format:"date-time"`
	StartDateLt  param.Field[time.Time] `query:"start_date[lt]" format:"date-time"`
	StartDateLte param.Field[time.Time] `query:"start_date[lte]" format:"date-time"`
}

// URLQuery serializes [SubscriptionFetchScheduleParams]'s query parameters as
// `url.Values`.
func (r SubscriptionFetchScheduleParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

type SubscriptionFetchUsageParams struct {
	// When specified in conjunction with `group_by`, this parameter filters usage to a
	// single billable metric. Note that both `group_by` and `billable_metric_id` must
	// be specified together.
	BillableMetricID    param.Field[string] `query:"billable_metric_id"`
	FirstDimensionKey   param.Field[string] `query:"first_dimension_key"`
	FirstDimensionValue param.Field[string] `query:"first_dimension_value"`
	// This determines the windowing of usage reporting.
	Granularity param.Field[SubscriptionFetchUsageParamsGranularity] `query:"granularity"`
	// Groups per-price usage by the key provided.
	GroupBy              param.Field[string] `query:"group_by"`
	SecondDimensionKey   param.Field[string] `query:"second_dimension_key"`
	SecondDimensionValue param.Field[string] `query:"second_dimension_value"`
	// Usage returned is exclusive of `timeframe_end`.
	TimeframeEnd param.Field[time.Time] `query:"timeframe_end" format:"date-time"`
	// Usage returned is inclusive of `timeframe_start`.
	TimeframeStart param.Field[time.Time] `query:"timeframe_start" format:"date-time"`
	// Controls whether Orb returns cumulative usage since the start of the billing
	// period, or incremental day-by-day usage. If your customer has minimums or
	// discounts, it's strongly recommended that you use the default cumulative
	// behavior.
	ViewMode param.Field[SubscriptionFetchUsageParamsViewMode] `query:"view_mode"`
}

// URLQuery serializes [SubscriptionFetchUsageParams]'s query parameters as
// `url.Values`.
func (r SubscriptionFetchUsageParams) URLQuery() (v url.Values) {
	return apiquery.MarshalWithSettings(r, apiquery.QuerySettings{
		ArrayFormat:  apiquery.ArrayQueryFormatBrackets,
		NestedFormat: apiquery.NestedQueryFormatBrackets,
	})
}

// This determines the windowing of usage reporting.
type SubscriptionFetchUsageParamsGranularity string

const (
	SubscriptionFetchUsageParamsGranularityDay SubscriptionFetchUsageParamsGranularity = "day"
)

func (r SubscriptionFetchUsageParamsGranularity) IsKnown() bool {
	switch r {
	case SubscriptionFetchUsageParamsGranularityDay:
		return true
	}
	return false
}

// Controls whether Orb returns cumulative usage since the start of the billing
// period, or incremental day-by-day usage. If your customer has minimums or
// discounts, it's strongly recommended that you use the default cumulative
// behavior.
type SubscriptionFetchUsageParamsViewMode string

const (
	SubscriptionFetchUsageParamsViewModePeriodic   SubscriptionFetchUsageParamsViewMode = "periodic"
	SubscriptionFetchUsageParamsViewModeCumulative SubscriptionFetchUsageParamsViewMode = "cumulative"
)

func (r SubscriptionFetchUsageParamsViewMode) IsKnown() bool {
	switch r {
	case SubscriptionFetchUsageParamsViewModePeriodic, SubscriptionFetchUsageParamsViewModeCumulative:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParams struct {
	// A list of price intervals to add to the subscription.
	Add param.Field[[]SubscriptionPriceIntervalsParamsAdd] `json:"add"`
	// A list of adjustments to add to the subscription.
	AddAdjustments param.Field[[]SubscriptionPriceIntervalsParamsAddAdjustment] `json:"add_adjustments"`
	// A list of price intervals to edit on the subscription.
	Edit param.Field[[]SubscriptionPriceIntervalsParamsEdit] `json:"edit"`
	// A list of adjustments to edit on the subscription.
	EditAdjustments param.Field[[]SubscriptionPriceIntervalsParamsEditAdjustment] `json:"edit_adjustments"`
}

func (r SubscriptionPriceIntervalsParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAdd struct {
	// The start date of the price interval. This is the date that the price will start
	// billing on the subscription.
	StartDate param.Field[SubscriptionPriceIntervalsParamsAddStartDateUnion] `json:"start_date,required" format:"date-time"`
	// The definition of a new allocation price to create and add to the subscription.
	AllocationPrice param.Field[SubscriptionPriceIntervalsParamsAddAllocationPrice] `json:"allocation_price"`
	// A list of discounts to initialize on the price interval.
	Discounts param.Field[[]SubscriptionPriceIntervalsParamsAddDiscountUnion] `json:"discounts"`
	// The end date of the price interval. This is the date that the price will stop
	// billing on the subscription.
	EndDate param.Field[SubscriptionPriceIntervalsParamsAddEndDateUnion] `json:"end_date" format:"date-time"`
	// The external price id of the price to add to the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// A list of fixed fee quantity transitions to initialize on the price interval.
	FixedFeeQuantityTransitions param.Field[[]SubscriptionPriceIntervalsParamsAddFixedFeeQuantityTransition] `json:"fixed_fee_quantity_transitions"`
	// The maximum amount that will be billed for this price interval for a given
	// billing period.
	MaximumAmount param.Field[float64] `json:"maximum_amount"`
	// The minimum amount that will be billed for this price interval for a given
	// billing period.
	MinimumAmount param.Field[float64] `json:"minimum_amount"`
	// The definition of a new price to create and add to the subscription.
	Price param.Field[SubscriptionPriceIntervalsParamsAddPriceUnion] `json:"price"`
	// The id of the price to add to the subscription.
	PriceID param.Field[string] `json:"price_id"`
}

func (r SubscriptionPriceIntervalsParamsAdd) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The start date of the price interval. This is the date that the price will start
// billing on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddStartDateUnion()
}

// The definition of a new allocation price to create and add to the subscription.
type SubscriptionPriceIntervalsParamsAddAllocationPrice struct {
	// An amount of the currency to allocate to the customer at the specified cadence.
	Amount param.Field[string] `json:"amount,required"`
	// The cadence at which to allocate the amount to the customer.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string or a custom pricing unit identifier in which to bill
	// this price.
	Currency param.Field[string] `json:"currency,required"`
	// Whether the allocated amount should expire at the end of the cadence or roll
	// over to the next period.
	ExpiresAtEndOfCadence param.Field[bool] `json:"expires_at_end_of_cadence,required"`
}

func (r SubscriptionPriceIntervalsParamsAddAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence at which to allocate the amount to the customer.
type SubscriptionPriceIntervalsParamsAddAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscount struct {
	DiscountType param.Field[SubscriptionPriceIntervalsParamsAddDiscountsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[float64] `json:"amount_discount"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for.
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscount) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

// Satisfied by
// [SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams],
// [SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams],
// [SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams],
// [SubscriptionPriceIntervalsParamsAddDiscount].
type SubscriptionPriceIntervalsParamsAddDiscountUnion interface {
	implementsSubscriptionPriceIntervalsParamsAddDiscountUnion()
}

type SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams struct {
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[float64]                                                                              `json:"amount_discount,required"`
	DiscountType   param.Field[SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType] `json:"discount_type,required"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParams) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

type SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountTypeAmount SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType = "amount"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsAmountDiscountCreationParamsDiscountTypeAmount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams struct {
	DiscountType param.Field[SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParams) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

type SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountTypePercentage SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType = "percentage"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsPercentageDiscountCreationParamsDiscountTypePercentage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams struct {
	DiscountType param.Field[SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for.
	UsageDiscount param.Field[float64] `json:"usage_discount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParams) implementsSubscriptionPriceIntervalsParamsAddDiscountUnion() {
}

type SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountTypeUsage SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsUsageDiscountCreationParamsDiscountTypeUsage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddDiscountsDiscountType string

const (
	SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeAmount     SubscriptionPriceIntervalsParamsAddDiscountsDiscountType = "amount"
	SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypePercentage SubscriptionPriceIntervalsParamsAddDiscountsDiscountType = "percentage"
	SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeUsage      SubscriptionPriceIntervalsParamsAddDiscountsDiscountType = "usage"
)

func (r SubscriptionPriceIntervalsParamsAddDiscountsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeAmount, SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypePercentage, SubscriptionPriceIntervalsParamsAddDiscountsDiscountTypeUsage:
		return true
	}
	return false
}

// The end date of the price interval. This is the date that the price will stop
// billing on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddEndDateUnion()
}

type SubscriptionPriceIntervalsParamsAddFixedFeeQuantityTransition struct {
	// The date that the fixed fee quantity transition should take effect.
	EffectiveDate param.Field[time.Time] `json:"effective_date,required" format:"date-time"`
	// The quantity of the fixed fee quantity transition.
	Quantity param.Field[int64] `json:"quantity,required"`
}

func (r SubscriptionPriceIntervalsParamsAddFixedFeeQuantityTransition) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new price to create and add to the subscription.
type SubscriptionPriceIntervalsParamsAddPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                            `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance           param.Field[bool]        `json:"billed_in_advance"`
	BillingCycleConfiguration param.Field[interface{}] `json:"billing_cycle_configuration"`
	BpsConfig                 param.Field[interface{}] `json:"bps_config"`
	BulkBpsConfig             param.Field[interface{}] `json:"bulk_bps_config"`
	BulkConfig                param.Field[interface{}] `json:"bulk_config"`
	BulkWithProrationConfig   param.Field[interface{}] `json:"bulk_with_proration_config"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity               param.Field[float64]     `json:"fixed_price_quantity"`
	GroupedAllocationConfig          param.Field[interface{}] `json:"grouped_allocation_config"`
	GroupedTieredConfig              param.Field[interface{}] `json:"grouped_tiered_config"`
	GroupedTieredPackageConfig       param.Field[interface{}] `json:"grouped_tiered_package_config"`
	GroupedWithMeteredMinimumConfig  param.Field[interface{}] `json:"grouped_with_metered_minimum_config"`
	GroupedWithProratedMinimumConfig param.Field[interface{}] `json:"grouped_with_prorated_minimum_config"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey             param.Field[string]      `json:"invoice_grouping_key"`
	InvoicingCycleConfiguration    param.Field[interface{}] `json:"invoicing_cycle_configuration"`
	MatrixConfig                   param.Field[interface{}] `json:"matrix_config"`
	MatrixWithAllocationConfig     param.Field[interface{}] `json:"matrix_with_allocation_config"`
	MatrixWithDisplayNameConfig    param.Field[interface{}] `json:"matrix_with_display_name_config"`
	Metadata                       param.Field[interface{}] `json:"metadata"`
	PackageConfig                  param.Field[interface{}] `json:"package_config"`
	PackageWithAllocationConfig    param.Field[interface{}] `json:"package_with_allocation_config"`
	ThresholdTotalAmountConfig     param.Field[interface{}] `json:"threshold_total_amount_config"`
	TieredBpsConfig                param.Field[interface{}] `json:"tiered_bps_config"`
	TieredConfig                   param.Field[interface{}] `json:"tiered_config"`
	TieredPackageConfig            param.Field[interface{}] `json:"tiered_package_config"`
	TieredPackageWithMinimumConfig param.Field[interface{}] `json:"tiered_package_with_minimum_config"`
	TieredWithMinimumConfig        param.Field[interface{}] `json:"tiered_with_minimum_config"`
	TieredWithProrationConfig      param.Field[interface{}] `json:"tiered_with_proration_config"`
	UnitConfig                     param.Field[interface{}] `json:"unit_config"`
	UnitWithPercentConfig          param.Field[interface{}] `json:"unit_with_percent_config"`
	UnitWithProrationConfig        param.Field[interface{}] `json:"unit_with_proration_config"`
}

func (r SubscriptionPriceIntervalsParamsAddPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The definition of a new price to create and add to the subscription.
//
// Satisfied by [SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice],
// [SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice],
// [SubscriptionPriceIntervalsParamsAddPrice].
type SubscriptionPriceIntervalsParamsAddPriceUnion interface {
	implementsSubscriptionPriceIntervalsParamsAddPriceUnion()
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]                                                                 `json:"name,required"`
	UnitConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceUnitConfig] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelTypeUnit SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType = "unit"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceUnitConfig struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceUnitConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]                                                                       `json:"name,required"`
	PackageConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePricePackageConfig] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelTypePackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType = "package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceModelTypePackage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePricePackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePricePackageConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID       param.Field[string]                                                                     `json:"item_id,required"`
	MatrixConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfig] `json:"matrix_config,required"`
	ModelType    param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType]    `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceMatrixConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelTypeMatrix SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType = "matrix"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID                     param.Field[string]                                                                                                 `json:"item_id,required"`
	MatrixWithAllocationConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfig] `json:"matrix_with_allocation_config,required"`
	ModelType                  param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType]                  `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfig struct {
	// Allocation to be used to calculate the price
	Allocation param.Field[float64] `json:"allocation,required"`
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceMatrixWithAllocationConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelTypeMatrixWithAllocation SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType = "matrix_with_allocation"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceModelTypeMatrixWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]                                                                     `json:"name,required"`
	TieredConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfig] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelTypeTiered SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType = "tiered"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfigTier struct {
	// Inclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Exclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceTieredConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]                                                                           `json:"name,required"`
	TieredBpsConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfig] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelTypeTieredBps SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType = "tiered_bps"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceModelTypeTieredBps:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfigTier struct {
	// Per-event basis point rate
	Bps param.Field[float64] `json:"bps,required"`
	// Inclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Exclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceTieredBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice struct {
	BpsConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBpsConfig] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBpsConfig struct {
	// Basis point take rate per event
	Bps param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelTypeBps SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType = "bps"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceModelTypeBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice struct {
	BulkBpsConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfig] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfigTier struct {
	// Basis points to rate on
	Bps param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBulkBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelTypeBulkBps SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType = "bulk_bps"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceModelTypeBulkBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice struct {
	BulkConfig param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfig] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfigTier] `json:"tiers,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfigTier struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBulkConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelTypeBulk SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType = "bulk"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelTypeThresholdTotalAmount SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelTypeTieredPackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType = "tiered_package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency            param.Field[string]                 `json:"currency,required"`
	GroupedTieredConfig param.Field[map[string]interface{}] `json:"grouped_tiered_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelTypeGroupedTiered SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType = "grouped_tiered"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceModelTypeGroupedTiered:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelTypeTieredWithMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelTypePackageWithAllocation SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                    `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                           param.Field[string]                 `json:"name,required"`
	TieredPackageWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_package_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType = "tiered_package_with_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceModelTypeTieredPackageWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredPackageWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelTypeUnitWithPercent SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelTypeTieredWithProration SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType = "tiered_with_proration"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingTieredWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelTypeUnitWithProration SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                param.Field[string]                 `json:"currency,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}] `json:"grouped_allocation_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelTypeGroupedAllocation SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                         param.Field[string]                 `json:"currency,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}] `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                      `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                        param.Field[string]                 `json:"currency,required"`
	GroupedWithMeteredMinimumConfig param.Field[map[string]interface{}] `json:"grouped_with_metered_minimum_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType = "grouped_with_metered_minimum"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceModelTypeGroupedWithMeteredMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedWithMeteredMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID                      param.Field[string]                                                                                 `json:"item_id,required"`
	MatrixWithDisplayNameConfig param.Field[map[string]interface{}]                                                                 `json:"matrix_with_display_name_config,required"`
	ModelType                   param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType = "matrix_with_display_name"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceModelTypeMatrixWithDisplayName:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingMatrixWithDisplayNamePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency param.Field[string] `json:"currency,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelTypeBulkWithProration SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence] `json:"cadence,required"`
	// An ISO 4217 currency string for which this price is billed in.
	Currency                   param.Field[string]                 `json:"currency,required"`
	GroupedTieredPackageConfig param.Field[map[string]interface{}] `json:"grouped_tiered_package_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePrice) implementsSubscriptionPriceIntervalsParamsAddPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelTypeGroupedTieredPackage SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType = "grouped_tiered_package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceModelTypeGroupedTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionPriceIntervalsParamsAddPriceNewFloatingGroupedTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// The cadence to bill for this price on.
type SubscriptionPriceIntervalsParamsAddPriceCadence string

const (
	SubscriptionPriceIntervalsParamsAddPriceCadenceAnnual     SubscriptionPriceIntervalsParamsAddPriceCadence = "annual"
	SubscriptionPriceIntervalsParamsAddPriceCadenceSemiAnnual SubscriptionPriceIntervalsParamsAddPriceCadence = "semi_annual"
	SubscriptionPriceIntervalsParamsAddPriceCadenceMonthly    SubscriptionPriceIntervalsParamsAddPriceCadence = "monthly"
	SubscriptionPriceIntervalsParamsAddPriceCadenceQuarterly  SubscriptionPriceIntervalsParamsAddPriceCadence = "quarterly"
	SubscriptionPriceIntervalsParamsAddPriceCadenceOneTime    SubscriptionPriceIntervalsParamsAddPriceCadence = "one_time"
	SubscriptionPriceIntervalsParamsAddPriceCadenceCustom     SubscriptionPriceIntervalsParamsAddPriceCadence = "custom"
)

func (r SubscriptionPriceIntervalsParamsAddPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceCadenceAnnual, SubscriptionPriceIntervalsParamsAddPriceCadenceSemiAnnual, SubscriptionPriceIntervalsParamsAddPriceCadenceMonthly, SubscriptionPriceIntervalsParamsAddPriceCadenceQuarterly, SubscriptionPriceIntervalsParamsAddPriceCadenceOneTime, SubscriptionPriceIntervalsParamsAddPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddPriceModelType string

const (
	SubscriptionPriceIntervalsParamsAddPriceModelTypeUnit                       SubscriptionPriceIntervalsParamsAddPriceModelType = "unit"
	SubscriptionPriceIntervalsParamsAddPriceModelTypePackage                    SubscriptionPriceIntervalsParamsAddPriceModelType = "package"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrix                     SubscriptionPriceIntervalsParamsAddPriceModelType = "matrix"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithAllocation       SubscriptionPriceIntervalsParamsAddPriceModelType = "matrix_with_allocation"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTiered                     SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredBps                  SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_bps"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBps                        SubscriptionPriceIntervalsParamsAddPriceModelType = "bps"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkBps                    SubscriptionPriceIntervalsParamsAddPriceModelType = "bulk_bps"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBulk                       SubscriptionPriceIntervalsParamsAddPriceModelType = "bulk"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeThresholdTotalAmount       SubscriptionPriceIntervalsParamsAddPriceModelType = "threshold_total_amount"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackage              SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_package"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTiered              SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_tiered"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithMinimum          SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_with_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypePackageWithAllocation      SubscriptionPriceIntervalsParamsAddPriceModelType = "package_with_allocation"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackageWithMinimum   SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_package_with_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithPercent            SubscriptionPriceIntervalsParamsAddPriceModelType = "unit_with_percent"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithProration        SubscriptionPriceIntervalsParamsAddPriceModelType = "tiered_with_proration"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithProration          SubscriptionPriceIntervalsParamsAddPriceModelType = "unit_with_proration"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedAllocation          SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_allocation"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithProratedMinimum SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_with_prorated_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithMeteredMinimum  SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_with_metered_minimum"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithDisplayName      SubscriptionPriceIntervalsParamsAddPriceModelType = "matrix_with_display_name"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkWithProration          SubscriptionPriceIntervalsParamsAddPriceModelType = "bulk_with_proration"
	SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTieredPackage       SubscriptionPriceIntervalsParamsAddPriceModelType = "grouped_tiered_package"
)

func (r SubscriptionPriceIntervalsParamsAddPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddPriceModelTypeUnit, SubscriptionPriceIntervalsParamsAddPriceModelTypePackage, SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrix, SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithAllocation, SubscriptionPriceIntervalsParamsAddPriceModelTypeTiered, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredBps, SubscriptionPriceIntervalsParamsAddPriceModelTypeBps, SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkBps, SubscriptionPriceIntervalsParamsAddPriceModelTypeBulk, SubscriptionPriceIntervalsParamsAddPriceModelTypeThresholdTotalAmount, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackage, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTiered, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypePackageWithAllocation, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredPackageWithMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithPercent, SubscriptionPriceIntervalsParamsAddPriceModelTypeTieredWithProration, SubscriptionPriceIntervalsParamsAddPriceModelTypeUnitWithProration, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedAllocation, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithProratedMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedWithMeteredMinimum, SubscriptionPriceIntervalsParamsAddPriceModelTypeMatrixWithDisplayName, SubscriptionPriceIntervalsParamsAddPriceModelTypeBulkWithProration, SubscriptionPriceIntervalsParamsAddPriceModelTypeGroupedTieredPackage:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustment struct {
	// The definition of a new adjustment to create and add to the subscription.
	Adjustment param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion] `json:"adjustment,required"`
	// The start date of the adjustment interval. This is the date that the adjustment
	// will start affecting prices on the subscription.
	StartDate param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion] `json:"start_date,required" format:"date-time"`
	// The end date of the adjustment interval. This is the date that the adjustment
	// will stop affecting prices on the subscription.
	EndDate param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion] `json:"end_date" format:"date-time"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new adjustment to create and add to the subscription.
type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment struct {
	AdjustmentType    param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType] `json:"adjustment_type,required"`
	AppliesToPriceIDs param.Field[interface{}]                                                            `json:"applies_to_price_ids,required"`
	AmountDiscount    param.Field[string]                                                                 `json:"amount_discount"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID             param.Field[string]  `json:"item_id"`
	MaximumAmount      param.Field[string]  `json:"maximum_amount"`
	MinimumAmount      param.Field[string]  `json:"minimum_amount"`
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	UsageDiscount      param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

// The definition of a new adjustment to create and add to the subscription.
//
// Satisfied by
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum],
// [SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustment].
type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion interface {
	implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion()
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs  param.Field[[]string] `json:"applies_to_price_ids,required"`
	PercentageDiscount param.Field[float64]  `json:"percentage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscount) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	UsageDiscount     param.Field[float64]  `json:"usage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscount) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType = "usage_discount"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                                                                                  `json:"amount_discount,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscount) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType = "amount_discount"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimum) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType = "minimum"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum struct {
	AdjustmentType param.Field[SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	MaximumAmount     param.Field[string]   `json:"maximum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximum) implementsSubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType string

const (
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum            SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "minimum"
	SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum            SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum, SubscriptionPriceIntervalsParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

// The start date of the adjustment interval. This is the date that the adjustment
// will start affecting prices on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsStartDateUnion()
}

// The end date of the adjustment interval. This is the date that the adjustment
// will stop affecting prices on the subscription.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsAddAdjustmentsEndDateUnion()
}

type SubscriptionPriceIntervalsParamsEdit struct {
	// The id of the price interval to edit.
	PriceIntervalID param.Field[string] `json:"price_interval_id,required"`
	// The updated billing cycle day for this price interval. If not specified, the
	// billing cycle day will not be updated. Note that overlapping price intervals
	// must have the same billing cycle day.
	BillingCycleDay param.Field[int64] `json:"billing_cycle_day"`
	// The updated end date of this price interval. If not specified, the start date
	// will not be updated.
	EndDate param.Field[SubscriptionPriceIntervalsParamsEditEndDateUnion] `json:"end_date" format:"date-time"`
	// A list of fixed fee quantity transitions to use for this price interval. Note
	// that this list will overwrite all existing fixed fee quantity transitions on the
	// price interval.
	FixedFeeQuantityTransitions param.Field[[]SubscriptionPriceIntervalsParamsEditFixedFeeQuantityTransition] `json:"fixed_fee_quantity_transitions"`
	// The updated start date of this price interval. If not specified, the start date
	// will not be updated.
	StartDate param.Field[SubscriptionPriceIntervalsParamsEditStartDateUnion] `json:"start_date" format:"date-time"`
}

func (r SubscriptionPriceIntervalsParamsEdit) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The updated end date of this price interval. If not specified, the start date
// will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditEndDateUnion()
}

type SubscriptionPriceIntervalsParamsEditFixedFeeQuantityTransition struct {
	// The date that the fixed fee quantity transition should take effect.
	EffectiveDate param.Field[time.Time] `json:"effective_date,required" format:"date-time"`
	// The quantity of the fixed fee quantity transition.
	Quantity param.Field[int64] `json:"quantity,required"`
}

func (r SubscriptionPriceIntervalsParamsEditFixedFeeQuantityTransition) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The updated start date of this price interval. If not specified, the start date
// will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditStartDateUnion()
}

type SubscriptionPriceIntervalsParamsEditAdjustment struct {
	// The id of the adjustment interval to edit.
	AdjustmentIntervalID param.Field[string] `json:"adjustment_interval_id,required"`
	// The updated end date of this adjustment interval. If not specified, the start
	// date will not be updated.
	EndDate param.Field[SubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion] `json:"end_date" format:"date-time"`
	// The updated start date of this adjustment interval. If not specified, the start
	// date will not be updated.
	StartDate param.Field[SubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion] `json:"start_date" format:"date-time"`
}

func (r SubscriptionPriceIntervalsParamsEditAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The updated end date of this adjustment interval. If not specified, the start
// date will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditAdjustmentsEndDateUnion()
}

// The updated start date of this adjustment interval. If not specified, the start
// date will not be updated.
//
// Satisfied by [shared.UnionTime], [shared.BillingCycleRelativeDate].
type SubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion interface {
	ImplementsSubscriptionPriceIntervalsParamsEditAdjustmentsStartDateUnion()
}

type SubscriptionSchedulePlanChangeParams struct {
	ChangeOption param.Field[SubscriptionSchedulePlanChangeParamsChangeOption] `json:"change_option,required"`
	// Additional adjustments to be added to the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	AddAdjustments param.Field[[]SubscriptionSchedulePlanChangeParamsAddAdjustment] `json:"add_adjustments"`
	// Additional prices to be added to the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	AddPrices param.Field[[]SubscriptionSchedulePlanChangeParamsAddPrice] `json:"add_prices"`
	// [DEPRECATED] Use billing_cycle_alignment instead. Reset billing periods to be
	// aligned with the plan change's effective date.
	AlignBillingWithPlanChangeDate param.Field[bool] `json:"align_billing_with_plan_change_date"`
	// Determines whether issued invoices for this subscription will automatically be
	// charged with the saved payment method on the due date. If not specified, this
	// defaults to the behavior configured for this customer.
	AutoCollection param.Field[bool] `json:"auto_collection"`
	// Reset billing periods to be aligned with the plan change's effective date or
	// start of the month. Defaults to `unchanged` which keeps subscription's existing
	// billing cycle alignment.
	BillingCycleAlignment           param.Field[SubscriptionSchedulePlanChangeParamsBillingCycleAlignment]           `json:"billing_cycle_alignment"`
	BillingCycleAnchorConfiguration param.Field[SubscriptionSchedulePlanChangeParamsBillingCycleAnchorConfiguration] `json:"billing_cycle_anchor_configuration"`
	// The date that the plan change should take effect. This parameter can only be
	// passed if the `change_option` is `requested_date`.
	ChangeDate param.Field[time.Time] `json:"change_date" format:"date-time"`
	// Redemption code to be used for this subscription. If the coupon cannot be found
	// by its redemption code, or cannot be redeemed, an error response will be
	// returned and the subscription creation or plan change will not be scheduled.
	CouponRedemptionCode param.Field[string]  `json:"coupon_redemption_code"`
	CreditsOverageRate   param.Field[float64] `json:"credits_overage_rate"`
	// Determines the default memo on this subscription's invoices. Note that if this
	// is not provided, it is determined by the plan configuration.
	DefaultInvoiceMemo param.Field[string] `json:"default_invoice_memo"`
	// The external_plan_id of the plan that the given subscription should be switched
	// to. Note that either this property or `plan_id` must be specified.
	ExternalPlanID param.Field[string] `json:"external_plan_id"`
	// An additional filter to apply to usage queries. This filter must be expressed as
	// a boolean
	// [computed property](../guides/extensibility/advanced-metrics#computed-properties).
	// If null, usage queries will not include any additional filter.
	Filter param.Field[string] `json:"filter"`
	// The phase of the plan to start with
	InitialPhaseOrder param.Field[int64] `json:"initial_phase_order"`
	// When this subscription's accrued usage reaches this threshold, an invoice will
	// be issued for the subscription. If not specified, invoices will only be issued
	// at the end of the billing period.
	InvoicingThreshold param.Field[string] `json:"invoicing_threshold"`
	// The net terms determines the difference between the invoice date and the issue
	// date for the invoice. If you intend the invoice to be due on issue, set this
	// to 0. If not provided, this defaults to the value specified in the plan.
	NetTerms               param.Field[int64]   `json:"net_terms"`
	PerCreditOverageAmount param.Field[float64] `json:"per_credit_overage_amount"`
	// The plan that the given subscription should be switched to. Note that either
	// this property or `external_plan_id` must be specified.
	PlanID param.Field[string] `json:"plan_id"`
	// Specifies which version of the plan to change to. If null, the default version
	// will be used.
	PlanVersionNumber param.Field[int64] `json:"plan_version_number"`
	// Optionally provide a list of overrides for prices on the plan
	PriceOverrides param.Field[[]interface{}] `json:"price_overrides"`
	// Plan adjustments to be removed from the subscription. (Only available for
	// accounts that have migrated off of legacy subscription overrides)
	RemoveAdjustments param.Field[[]SubscriptionSchedulePlanChangeParamsRemoveAdjustment] `json:"remove_adjustments"`
	// Plan prices to be removed from the subscription. (Only available for accounts
	// that have migrated off of legacy subscription overrides)
	RemovePrices param.Field[[]SubscriptionSchedulePlanChangeParamsRemovePrice] `json:"remove_prices"`
	// Plan adjustments to be replaced with additional adjustments on the subscription.
	// (Only available for accounts that have migrated off of legacy subscription
	// overrides)
	ReplaceAdjustments param.Field[[]SubscriptionSchedulePlanChangeParamsReplaceAdjustment] `json:"replace_adjustments"`
	// Plan prices to be replaced with additional prices on the subscription. (Only
	// available for accounts that have migrated off of legacy subscription overrides)
	ReplacePrices param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePrice] `json:"replace_prices"`
	// The duration of the trial period in days. If not provided, this defaults to the
	// value specified in the plan. If `0` is provided, the trial on the plan will be
	// skipped.
	TrialDurationDays param.Field[int64] `json:"trial_duration_days"`
}

func (r SubscriptionSchedulePlanChangeParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsChangeOption string

const (
	SubscriptionSchedulePlanChangeParamsChangeOptionRequestedDate         SubscriptionSchedulePlanChangeParamsChangeOption = "requested_date"
	SubscriptionSchedulePlanChangeParamsChangeOptionEndOfSubscriptionTerm SubscriptionSchedulePlanChangeParamsChangeOption = "end_of_subscription_term"
	SubscriptionSchedulePlanChangeParamsChangeOptionImmediate             SubscriptionSchedulePlanChangeParamsChangeOption = "immediate"
)

func (r SubscriptionSchedulePlanChangeParamsChangeOption) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsChangeOptionRequestedDate, SubscriptionSchedulePlanChangeParamsChangeOptionEndOfSubscriptionTerm, SubscriptionSchedulePlanChangeParamsChangeOptionImmediate:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddAdjustment struct {
	// The definition of a new adjustment to create and add to the subscription.
	Adjustment param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion] `json:"adjustment,required"`
	// The end date of the adjustment interval. This is the date that the adjustment
	// will stop affecting prices on the subscription. If null, the adjustment will
	// start when the phase or subscription starts.
	EndDate param.Field[time.Time] `json:"end_date" format:"date-time"`
	// The phase to add this adjustment to.
	PlanPhaseOrder param.Field[int64] `json:"plan_phase_order"`
	// The start date of the adjustment interval. This is the date that the adjustment
	// will start affecting prices on the subscription. If null, the adjustment will
	// start when the phase or subscription starts.
	StartDate param.Field[time.Time] `json:"start_date" format:"date-time"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new adjustment to create and add to the subscription.
type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustment struct {
	AdjustmentType    param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType] `json:"adjustment_type,required"`
	AppliesToPriceIDs param.Field[interface{}]                                                                `json:"applies_to_price_ids,required"`
	AmountDiscount    param.Field[string]                                                                     `json:"amount_discount"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID             param.Field[string]  `json:"item_id"`
	MaximumAmount      param.Field[string]  `json:"maximum_amount"`
	MinimumAmount      param.Field[string]  `json:"minimum_amount"`
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	UsageDiscount      param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustment) implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

// The definition of a new adjustment to create and add to the subscription.
//
// Satisfied by
// [SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscount],
// [SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscount],
// [SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscount],
// [SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimum],
// [SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximum],
// [SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustment].
type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion interface {
	implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion()
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscount struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs  param.Field[[]string] `json:"applies_to_price_ids,required"`
	PercentageDiscount param.Field[float64]  `json:"percentage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscount) implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscount struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	UsageDiscount     param.Field[float64]  `json:"usage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscount) implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType = "usage_discount"
)

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscount struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                                                                                      `json:"amount_discount,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscount) implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType = "amount_discount"
)

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimum struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimum) implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType = "minimum"
)

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximum struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	MaximumAmount     param.Field[string]   `json:"maximum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximum) implementsSubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum            SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType = "minimum"
	SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum            SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeMinimum, SubscriptionSchedulePlanChangeParamsAddAdjustmentsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPrice struct {
	// [DEPRECATED] Use add_adjustments instead. The subscription's discounts for this
	// price.
	Discounts param.Field[[]SubscriptionSchedulePlanChangeParamsAddPricesDiscount] `json:"discounts"`
	// The end date of the price interval. This is the date that the price will stop
	// billing on the subscription. If null, billing will end when the phase or
	// subscription ends.
	EndDate param.Field[time.Time] `json:"end_date" format:"date-time"`
	// The external price id of the price to add to the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's maximum amount for
	// this price.
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's minimum amount for
	// this price.
	MinimumAmount param.Field[string] `json:"minimum_amount"`
	// The phase to add this price to.
	PlanPhaseOrder param.Field[int64] `json:"plan_phase_order"`
	// The definition of a new price to create and add to the subscription.
	Price param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceUnion] `json:"price"`
	// The id of the price to add to the subscription.
	PriceID param.Field[string] `json:"price_id"`
	// The start date of the price interval. This is the date that the price will start
	// billing on the subscription. If null, billing will start when the phase or
	// subscription starts.
	StartDate param.Field[time.Time] `json:"start_date" format:"date-time"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesDiscount struct {
	DiscountType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[string] `json:"amount_discount"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountTypePercentage SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountType = "percentage"
	SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountTypeUsage      SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountType = "usage"
	SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountTypeAmount     SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountType = "amount"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountTypePercentage, SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountTypeUsage, SubscriptionSchedulePlanChangeParamsAddPricesDiscountsDiscountTypeAmount:
		return true
	}
	return false
}

// The definition of a new price to create and add to the subscription.
type SubscriptionSchedulePlanChangeParamsAddPricesPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                      `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance           param.Field[bool]        `json:"billed_in_advance"`
	BillingCycleConfiguration param.Field[interface{}] `json:"billing_cycle_configuration"`
	BpsConfig                 param.Field[interface{}] `json:"bps_config"`
	BulkBpsConfig             param.Field[interface{}] `json:"bulk_bps_config"`
	BulkConfig                param.Field[interface{}] `json:"bulk_config"`
	BulkWithProrationConfig   param.Field[interface{}] `json:"bulk_with_proration_config"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity               param.Field[float64]     `json:"fixed_price_quantity"`
	GroupedAllocationConfig          param.Field[interface{}] `json:"grouped_allocation_config"`
	GroupedWithProratedMinimumConfig param.Field[interface{}] `json:"grouped_with_prorated_minimum_config"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey          param.Field[string]      `json:"invoice_grouping_key"`
	InvoicingCycleConfiguration param.Field[interface{}] `json:"invoicing_cycle_configuration"`
	MatrixConfig                param.Field[interface{}] `json:"matrix_config"`
	Metadata                    param.Field[interface{}] `json:"metadata"`
	PackageConfig               param.Field[interface{}] `json:"package_config"`
	PackageWithAllocationConfig param.Field[interface{}] `json:"package_with_allocation_config"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID                param.Field[string]      `json:"reference_id"`
	ThresholdTotalAmountConfig param.Field[interface{}] `json:"threshold_total_amount_config"`
	TieredBpsConfig            param.Field[interface{}] `json:"tiered_bps_config"`
	TieredConfig               param.Field[interface{}] `json:"tiered_config"`
	TieredPackageConfig        param.Field[interface{}] `json:"tiered_package_config"`
	TieredWithMinimumConfig    param.Field[interface{}] `json:"tiered_with_minimum_config"`
	TieredWithProrationConfig  param.Field[interface{}] `json:"tiered_with_proration_config"`
	UnitConfig                 param.Field[interface{}] `json:"unit_config"`
	UnitWithPercentConfig      param.Field[interface{}] `json:"unit_with_percent_config"`
	UnitWithProrationConfig    param.Field[interface{}] `json:"unit_with_proration_config"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The definition of a new price to create and add to the subscription.
//
// Satisfied by
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice],
// [SubscriptionSchedulePlanChangeParamsAddPricesPrice].
type SubscriptionSchedulePlanChangeParamsAddPricesPriceUnion interface {
	implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion()
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                              `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]                                                                               `json:"name,required"`
	UnitConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceUnitConfig] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceModelTypeUnit SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceModelType = "unit"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceUnitConfig struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceUnitConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]                                                                                     `json:"name,required"`
	PackageConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePricePackageConfig] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceModelTypePackage SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceModelType = "package"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceModelTypePackage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePricePackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePricePackageConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID       param.Field[string]                                                                                   `json:"item_id,required"`
	MatrixConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfig] `json:"matrix_config,required"`
	ModelType    param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceModelType]    `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceModelTypeMatrix SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceModelType = "matrix"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]                                                                                   `json:"name,required"`
	TieredConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfig] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceModelTypeTiered SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceModelType = "tiered"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfigTier struct {
	// Inclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Exclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceTieredConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]                                                                                         `json:"name,required"`
	TieredBpsConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType = "tiered_bps"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier struct {
	// Per-event basis point rate
	Bps param.Field[float64] `json:"bps,required"`
	// Inclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Exclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPrice struct {
	BpsConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBpsConfig] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBpsConfig struct {
	// Basis point take rate per event
	Bps param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceModelTypeBps SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceModelType = "bps"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceModelTypeBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPrice struct {
	BulkBpsConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier struct {
	// Basis points to rate on
	Bps param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType = "bulk_bps"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPrice struct {
	BulkConfig param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfig] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                              `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfigTier struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBulkConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceModelTypeBulk SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceModelType = "bulk"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                              `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                       `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType = "tiered_package"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                         `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType = "tiered_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence                 param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence] `json:"cadence,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}]                                                                         `json:"grouped_allocation_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence                          param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}]                                                                                  `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                                    `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPrice) implementsSubscriptionSchedulePlanChangeParamsAddPricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsAddPricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsAddPricesPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeUnit                       SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "unit"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypePackage                    SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "package"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeMatrix                     SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "matrix"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTiered                     SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "tiered"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredBps                  SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "tiered_bps"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBps                        SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "bps"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBulkBps                    SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "bulk_bps"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBulk                       SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "bulk"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeThresholdTotalAmount       SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "threshold_total_amount"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredPackage              SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "tiered_package"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredWithMinimum          SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "tiered_with_minimum"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeUnitWithPercent            SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "unit_with_percent"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypePackageWithAllocation      SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "package_with_allocation"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredWithProration        SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "tiered_with_proration"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeUnitWithProration          SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "unit_with_proration"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeGroupedAllocation          SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "grouped_allocation"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeGroupedWithProratedMinimum SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "grouped_with_prorated_minimum"
	SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBulkWithProration          SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType = "bulk_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsAddPricesPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeUnit, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypePackage, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeMatrix, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTiered, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredBps, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBps, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBulkBps, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBulk, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeThresholdTotalAmount, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredPackage, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredWithMinimum, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeUnitWithPercent, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypePackageWithAllocation, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeTieredWithProration, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeUnitWithProration, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeGroupedAllocation, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeGroupedWithProratedMinimum, SubscriptionSchedulePlanChangeParamsAddPricesPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// Reset billing periods to be aligned with the plan change's effective date or
// start of the month. Defaults to `unchanged` which keeps subscription's existing
// billing cycle alignment.
type SubscriptionSchedulePlanChangeParamsBillingCycleAlignment string

const (
	SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentUnchanged      SubscriptionSchedulePlanChangeParamsBillingCycleAlignment = "unchanged"
	SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentPlanChangeDate SubscriptionSchedulePlanChangeParamsBillingCycleAlignment = "plan_change_date"
	SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentStartOfMonth   SubscriptionSchedulePlanChangeParamsBillingCycleAlignment = "start_of_month"
)

func (r SubscriptionSchedulePlanChangeParamsBillingCycleAlignment) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentUnchanged, SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentPlanChangeDate, SubscriptionSchedulePlanChangeParamsBillingCycleAlignmentStartOfMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsBillingCycleAnchorConfiguration struct {
	// The day of the month on which the billing cycle is anchored. If the maximum
	// number of days in a month is greater than this value, the last day of the month
	// is the billing cycle day (e.g. billing_cycle_day=31 for April means the billing
	// period begins on the 30th.
	Day param.Field[int64] `json:"day,required"`
	// The month on which the billing cycle is anchored (e.g. a quarterly price
	// anchored in February would have cycles starting February, May, August, and
	// November).
	Month param.Field[int64] `json:"month"`
	// The year on which the billing cycle is anchored (e.g. a 2 year billing cycle
	// anchored on 2021 would have cycles starting on 2021, 2023, 2025, etc.).
	Year param.Field[int64] `json:"year"`
}

func (r SubscriptionSchedulePlanChangeParamsBillingCycleAnchorConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsRemoveAdjustment struct {
	// The id of the adjustment to remove on the subscription.
	AdjustmentID param.Field[string] `json:"adjustment_id,required"`
}

func (r SubscriptionSchedulePlanChangeParamsRemoveAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsRemovePrice struct {
	// The external price id of the price to remove on the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// The id of the price to remove on the subscription.
	PriceID param.Field[string] `json:"price_id"`
}

func (r SubscriptionSchedulePlanChangeParamsRemovePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustment struct {
	// The definition of a new adjustment to create and add to the subscription.
	Adjustment param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion] `json:"adjustment,required"`
	// The id of the adjustment on the plan to replace in the subscription.
	ReplacesAdjustmentID param.Field[string] `json:"replaces_adjustment_id,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The definition of a new adjustment to create and add to the subscription.
type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustment struct {
	AdjustmentType    param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType] `json:"adjustment_type,required"`
	AppliesToPriceIDs param.Field[interface{}]                                                                    `json:"applies_to_price_ids,required"`
	AmountDiscount    param.Field[string]                                                                         `json:"amount_discount"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID             param.Field[string]  `json:"item_id"`
	MaximumAmount      param.Field[string]  `json:"maximum_amount"`
	MinimumAmount      param.Field[string]  `json:"minimum_amount"`
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	UsageDiscount      param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustment) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustment) implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

// The definition of a new adjustment to create and add to the subscription.
//
// Satisfied by
// [SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount],
// [SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscount],
// [SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscount],
// [SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimum],
// [SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximum],
// [SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustment].
type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion interface {
	implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion()
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs  param.Field[[]string] `json:"applies_to_price_ids,required"`
	PercentageDiscount param.Field[float64]  `json:"percentage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscount) implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType = "percentage_discount"
)

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewPercentageDiscountAdjustmentTypePercentageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscount struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	UsageDiscount     param.Field[float64]  `json:"usage_discount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscount) implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType = "usage_discount"
)

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewUsageDiscountAdjustmentTypeUsageDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscount struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType] `json:"adjustment_type,required"`
	AmountDiscount param.Field[string]                                                                                          `json:"amount_discount,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscount) implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType = "amount_discount"
)

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewAmountDiscountAdjustmentTypeAmountDiscount:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimum struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	// The item ID that revenue from this minimum will be attributed to.
	ItemID        param.Field[string] `json:"item_id,required"`
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimum) implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType = "minimum"
)

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMinimumAdjustmentTypeMinimum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximum struct {
	AdjustmentType param.Field[SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType] `json:"adjustment_type,required"`
	// The set of price IDs to which this adjustment applies.
	AppliesToPriceIDs param.Field[[]string] `json:"applies_to_price_ids,required"`
	MaximumAmount     param.Field[string]   `json:"maximum_amount,required"`
	// When false, this adjustment will be applied to a single price. Otherwise, it
	// will be applied at the invoice level, possibly to multiple prices.
	IsInvoiceLevel param.Field[bool] `json:"is_invoice_level"`
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximum) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximum) implementsSubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentNewMaximumAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType string

const (
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypePercentageDiscount SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType = "percentage_discount"
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeUsageDiscount      SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType = "usage_discount"
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeAmountDiscount     SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType = "amount_discount"
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMinimum            SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType = "minimum"
	SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMaximum            SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType = "maximum"
)

func (r SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypePercentageDiscount, SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeUsageDiscount, SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeAmountDiscount, SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMinimum, SubscriptionSchedulePlanChangeParamsReplaceAdjustmentsAdjustmentAdjustmentTypeMaximum:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePrice struct {
	// The id of the price on the plan to replace in the subscription.
	ReplacesPriceID param.Field[string] `json:"replaces_price_id,required"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's discounts for the
	// replacement price.
	Discounts param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePricesDiscount] `json:"discounts"`
	// The external price id of the price to add to the subscription.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// The new quantity of the price, if the price is a fixed price.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's maximum amount for
	// the replacement price.
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// [DEPRECATED] Use add_adjustments instead. The subscription's minimum amount for
	// the replacement price.
	MinimumAmount param.Field[string] `json:"minimum_amount"`
	// The definition of a new price to create and add to the subscription.
	Price param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion] `json:"price"`
	// The id of the price to add to the subscription.
	PriceID param.Field[string] `json:"price_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesDiscount struct {
	DiscountType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountType] `json:"discount_type,required"`
	// Only available if discount_type is `amount`.
	AmountDiscount param.Field[string] `json:"amount_discount"`
	// Only available if discount_type is `percentage`. This is a number between 0
	// and 1.
	PercentageDiscount param.Field[float64] `json:"percentage_discount"`
	// Only available if discount_type is `usage`. Number of usage units that this
	// discount is for
	UsageDiscount param.Field[float64] `json:"usage_discount"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesDiscount) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountTypePercentage SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountType = "percentage"
	SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountTypeUsage      SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountType = "usage"
	SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountTypeAmount     SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountType = "amount"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountTypePercentage, SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountTypeUsage, SubscriptionSchedulePlanChangeParamsReplacePricesDiscountsDiscountTypeAmount:
		return true
	}
	return false
}

// The definition of a new price to create and add to the subscription.
type SubscriptionSchedulePlanChangeParamsReplacePricesPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                          `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance           param.Field[bool]        `json:"billed_in_advance"`
	BillingCycleConfiguration param.Field[interface{}] `json:"billing_cycle_configuration"`
	BpsConfig                 param.Field[interface{}] `json:"bps_config"`
	BulkBpsConfig             param.Field[interface{}] `json:"bulk_bps_config"`
	BulkConfig                param.Field[interface{}] `json:"bulk_config"`
	BulkWithProrationConfig   param.Field[interface{}] `json:"bulk_with_proration_config"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity               param.Field[float64]     `json:"fixed_price_quantity"`
	GroupedAllocationConfig          param.Field[interface{}] `json:"grouped_allocation_config"`
	GroupedWithProratedMinimumConfig param.Field[interface{}] `json:"grouped_with_prorated_minimum_config"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey          param.Field[string]      `json:"invoice_grouping_key"`
	InvoicingCycleConfiguration param.Field[interface{}] `json:"invoicing_cycle_configuration"`
	MatrixConfig                param.Field[interface{}] `json:"matrix_config"`
	Metadata                    param.Field[interface{}] `json:"metadata"`
	PackageConfig               param.Field[interface{}] `json:"package_config"`
	PackageWithAllocationConfig param.Field[interface{}] `json:"package_with_allocation_config"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID                param.Field[string]      `json:"reference_id"`
	ThresholdTotalAmountConfig param.Field[interface{}] `json:"threshold_total_amount_config"`
	TieredBpsConfig            param.Field[interface{}] `json:"tiered_bps_config"`
	TieredConfig               param.Field[interface{}] `json:"tiered_config"`
	TieredPackageConfig        param.Field[interface{}] `json:"tiered_package_config"`
	TieredWithMinimumConfig    param.Field[interface{}] `json:"tiered_with_minimum_config"`
	TieredWithProrationConfig  param.Field[interface{}] `json:"tiered_with_proration_config"`
	UnitConfig                 param.Field[interface{}] `json:"unit_config"`
	UnitWithPercentConfig      param.Field[interface{}] `json:"unit_with_percent_config"`
	UnitWithProrationConfig    param.Field[interface{}] `json:"unit_with_proration_config"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The definition of a new price to create and add to the subscription.
//
// Satisfied by
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice],
// [SubscriptionSchedulePlanChangeParamsReplacePricesPrice].
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion interface {
	implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion()
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name       param.Field[string]                                                                                   `json:"name,required"`
	UnitConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceUnitConfig] `json:"unit_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceModelTypeUnit SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceModelType = "unit"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceModelTypeUnit:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceUnitConfig struct {
	// Rate per unit of usage
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceUnitConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name          param.Field[string]                                                                                         `json:"name,required"`
	PackageConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePricePackageConfig] `json:"package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceModelTypePackage SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceModelType = "package"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceModelTypePackage:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePricePackageConfig struct {
	// A currency amount to rate usage by
	PackageAmount param.Field[string] `json:"package_amount,required"`
	// An integer amount to represent package size. For example, 1000 here would divide
	// usage by 1000 before multiplying by package_amount in rating
	PackageSize param.Field[int64] `json:"package_size,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePricePackageConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID       param.Field[string]                                                                                       `json:"item_id,required"`
	MatrixConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfig] `json:"matrix_config,required"`
	ModelType    param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType]    `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfig struct {
	// Default per unit rate for any usage not bucketed into a specified matrix_value
	DefaultUnitAmount param.Field[string] `json:"default_unit_amount,required"`
	// One or two event property values to evaluate matrix groups by
	Dimensions param.Field[[]string] `json:"dimensions,required"`
	// Matrix values for specified matrix grouping keys
	MatrixValues param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue] `json:"matrix_values,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue struct {
	// One or two matrix keys to filter usage to this Matrix value by. For example,
	// ["region", "tier"] could be used to filter cloud usage by a cloud region and an
	// instance tier.
	DimensionValues param.Field[[]string] `json:"dimension_values,required"`
	// Unit price for the specified dimension_values
	UnitAmount param.Field[string] `json:"unit_amount,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceMatrixConfigMatrixValue) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceModelTypeMatrix SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType = "matrix"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceModelTypeMatrix:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionMatrixPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                    `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name         param.Field[string]                                                                                       `json:"name,required"`
	TieredConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfig] `json:"tiered_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceModelTypeTiered SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceModelType = "tiered"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceModelTypeTiered:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfig struct {
	// Tiers for rating based on total usage quantities into the specified tier
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfigTier struct {
	// Inclusive tier starting value
	FirstUnit param.Field[float64] `json:"first_unit,required"`
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Exclusive tier ending value. If null, this is treated as the last tier
	LastUnit param.Field[float64] `json:"last_unit"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceTieredConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                       `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name            param.Field[string]                                                                                             `json:"name,required"`
	TieredBpsConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig] `json:"tiered_bps_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType = "tiered_bps"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceModelTypeTieredBps:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig struct {
	// Tiers for a Graduated BPS pricing model, where usage is bucketed into specified
	// tiers
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier struct {
	// Per-event basis point rate
	Bps param.Field[float64] `json:"bps,required"`
	// Inclusive tier starting value
	MinimumAmount param.Field[string] `json:"minimum_amount,required"`
	// Exclusive tier ending value
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// Per unit maximum to charge
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceTieredBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPrice struct {
	BpsConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBpsConfig] `json:"bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                 `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBpsConfig struct {
	// Basis point take rate per event
	Bps param.Field[float64] `json:"bps,required"`
	// Optional currency amount maximum to cap spend per event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceModelTypeBps SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceModelType = "bps"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceModelTypeBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPrice struct {
	BulkBpsConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig] `json:"bulk_bps_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                     `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig struct {
	// Tiers for a bulk BPS pricing model where all usage is aggregated to a single
	// tier based on total volume
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier struct {
	// Basis points to rate on
	Bps param.Field[float64] `json:"bps,required"`
	// Upper bound for tier
	MaximumAmount param.Field[string] `json:"maximum_amount"`
	// The maximum amount to charge for any one event
	PerUnitMaximum param.Field[string] `json:"per_unit_maximum"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBulkBpsConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType = "bulk_bps"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceModelTypeBulkBps:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkBpsPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPrice struct {
	BulkConfig param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfig] `json:"bulk_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfig struct {
	// Bulk tiers for rating based on total usage volume
	Tiers param.Field[[]SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfigTier] `json:"tiers,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfig) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfigTier struct {
	// Amount per unit
	UnitAmount param.Field[string] `json:"unit_amount,required"`
	// Upper bound for this tier
	MaximumUnits param.Field[float64] `json:"maximum_units"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBulkConfigTier) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceModelTypeBulk SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceModelType = "bulk"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceModelTypeBulk:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                                  `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                       param.Field[string]                 `json:"name,required"`
	ThresholdTotalAmountConfig param.Field[map[string]interface{}] `json:"threshold_total_amount_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType = "threshold_total_amount"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceModelTypeThresholdTotalAmount:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionThresholdTotalAmountPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                           `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                param.Field[string]                 `json:"name,required"`
	TieredPackageConfig param.Field[map[string]interface{}] `json:"tiered_package_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType = "tiered_package"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceModelTypeTieredPackage:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredPackagePriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	TieredWithMinimumConfig param.Field[map[string]interface{}] `json:"tiered_with_minimum_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType = "tiered_with_minimum"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceModelTypeTieredWithMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTieredWithMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                             `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                  param.Field[string]                 `json:"name,required"`
	UnitWithPercentConfig param.Field[map[string]interface{}] `json:"unit_with_percent_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType = "unit_with_percent"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceModelTypeUnitWithPercent:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithPercentPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                                   `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                        param.Field[string]                 `json:"name,required"`
	PackageWithAllocationConfig param.Field[map[string]interface{}] `json:"package_with_allocation_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType = "package_with_allocation"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceModelTypePackageWithAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionPackageWithAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                      param.Field[string]                 `json:"name,required"`
	TieredWithProrationConfig param.Field[map[string]interface{}] `json:"tiered_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType = "tiered_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceModelTypeTieredWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionTierWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice struct {
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name                    param.Field[string]                 `json:"name,required"`
	UnitWithProrationConfig param.Field[map[string]interface{}] `json:"unit_with_proration_config,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType = "unit_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceModelTypeUnitWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionUnitWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice struct {
	// The cadence to bill for this price on.
	Cadence                 param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence] `json:"cadence,required"`
	GroupedAllocationConfig param.Field[map[string]interface{}]                                                                             `json:"grouped_allocation_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType = "grouped_allocation"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceModelTypeGroupedAllocation:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedAllocationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice struct {
	// The cadence to bill for this price on.
	Cadence                          param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence] `json:"cadence,required"`
	GroupedWithProratedMinimumConfig param.Field[map[string]interface{}]                                                                                      `json:"grouped_with_prorated_minimum_config,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                                        `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType = "grouped_with_prorated_minimum"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceModelTypeGroupedWithProratedMinimum:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionGroupedWithProratedMinimumPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice struct {
	BulkWithProrationConfig param.Field[map[string]interface{}] `json:"bulk_with_proration_config,required"`
	// The cadence to bill for this price on.
	Cadence param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence] `json:"cadence,required"`
	// The id of the item the plan will be associated with.
	ItemID    param.Field[string]                                                                                               `json:"item_id,required"`
	ModelType param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType] `json:"model_type,required"`
	// The name of the price.
	Name param.Field[string] `json:"name,required"`
	// The id of the billable metric for the price. Only needed if the price is
	// usage-based.
	BillableMetricID param.Field[string] `json:"billable_metric_id"`
	// If the Price represents a fixed cost, the price will be billed in-advance if
	// this is true, and in-arrears if this is false.
	BilledInAdvance param.Field[bool] `json:"billed_in_advance"`
	// For custom cadence: specifies the duration of the billing period in days or
	// months.
	BillingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration] `json:"billing_cycle_configuration"`
	// The per unit conversion rate of the price currency to the invoicing currency.
	ConversionRate param.Field[float64] `json:"conversion_rate"`
	// An ISO 4217 currency string, or custom pricing unit identifier, in which this
	// price is billed.
	Currency param.Field[string] `json:"currency"`
	// An alias for the price.
	ExternalPriceID param.Field[string] `json:"external_price_id"`
	// If the Price represents a fixed cost, this represents the quantity of units
	// applied.
	FixedPriceQuantity param.Field[float64] `json:"fixed_price_quantity"`
	// The property used to group this price on an invoice
	InvoiceGroupingKey param.Field[string] `json:"invoice_grouping_key"`
	// Within each billing cycle, specifies the cadence at which invoices are produced.
	// If unspecified, a single invoice is produced per billing cycle.
	InvoicingCycleConfiguration param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration] `json:"invoicing_cycle_configuration"`
	// User-specified key/value pairs for the resource. Individual keys can be removed
	// by setting the value to `null`, and the entire metadata mapping can be cleared
	// by setting `metadata` to `null`.
	Metadata param.Field[map[string]string] `json:"metadata"`
	// A transient ID that can be used to reference this price when adding adjustments
	// in the same API call.
	ReferenceID param.Field[string] `json:"reference_id"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPrice) implementsSubscriptionSchedulePlanChangeParamsReplacePricesPriceUnion() {
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType = "bulk_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

// For custom cadence: specifies the duration of the billing period in days or
// months.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceBillingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// Within each billing cycle, specifies the cadence at which invoices are produced.
// If unspecified, a single invoice is produced per billing cycle.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration struct {
	// The duration of the billing period.
	Duration param.Field[int64] `json:"duration,required"`
	// The unit of billing period duration.
	DurationUnit param.Field[SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit] `json:"duration_unit,required"`
}

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfiguration) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The unit of billing period duration.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay   SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "day"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit = "month"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnit) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitDay, SubscriptionSchedulePlanChangeParamsReplacePricesPriceNewSubscriptionBulkWithProrationPriceInvoicingCycleConfigurationDurationUnitMonth:
		return true
	}
	return false
}

// The cadence to bill for this price on.
type SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceAnnual     SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence = "annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceSemiAnnual SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence = "semi_annual"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceMonthly    SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence = "monthly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceQuarterly  SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence = "quarterly"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceOneTime    SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence = "one_time"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceCustom     SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence = "custom"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadence) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceSemiAnnual, SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceMonthly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceQuarterly, SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceOneTime, SubscriptionSchedulePlanChangeParamsReplacePricesPriceCadenceCustom:
		return true
	}
	return false
}

type SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType string

const (
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeUnit                       SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "unit"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypePackage                    SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "package"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeMatrix                     SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "matrix"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTiered                     SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "tiered"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredBps                  SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "tiered_bps"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBps                        SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "bps"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBulkBps                    SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "bulk_bps"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBulk                       SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "bulk"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeThresholdTotalAmount       SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "threshold_total_amount"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredPackage              SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "tiered_package"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredWithMinimum          SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "tiered_with_minimum"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeUnitWithPercent            SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "unit_with_percent"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypePackageWithAllocation      SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "package_with_allocation"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredWithProration        SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "tiered_with_proration"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeUnitWithProration          SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "unit_with_proration"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeGroupedAllocation          SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "grouped_allocation"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeGroupedWithProratedMinimum SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "grouped_with_prorated_minimum"
	SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBulkWithProration          SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType = "bulk_with_proration"
)

func (r SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelType) IsKnown() bool {
	switch r {
	case SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeUnit, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypePackage, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeMatrix, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTiered, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredBps, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBps, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBulkBps, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBulk, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeThresholdTotalAmount, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredPackage, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredWithMinimum, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeUnitWithPercent, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypePackageWithAllocation, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeTieredWithProration, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeUnitWithProration, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeGroupedAllocation, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeGroupedWithProratedMinimum, SubscriptionSchedulePlanChangeParamsReplacePricesPriceModelTypeBulkWithProration:
		return true
	}
	return false
}

type SubscriptionTriggerPhaseParams struct {
	// The date on which the phase change should take effect. If not provided, defaults
	// to today in the customer's timezone.
	EffectiveDate param.Field[time.Time] `json:"effective_date" format:"date"`
}

func (r SubscriptionTriggerPhaseParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionUnscheduleFixedFeeQuantityUpdatesParams struct {
	// Price for which the updates should be cleared. Must be a fixed fee.
	PriceID param.Field[string] `json:"price_id,required"`
}

func (r SubscriptionUnscheduleFixedFeeQuantityUpdatesParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

type SubscriptionUpdateFixedFeeQuantityParams struct {
	// Price for which the quantity should be updated. Must be a fixed fee.
	PriceID  param.Field[string]  `json:"price_id,required"`
	Quantity param.Field[float64] `json:"quantity,required"`
	// Determines when the change takes effect. Note that if `effective_date` is
	// specified, this defaults to `effective_date`. Otherwise, this defaults to
	// `immediate` unless it's explicitly set to `upcoming_invoice.
	ChangeOption param.Field[SubscriptionUpdateFixedFeeQuantityParamsChangeOption] `json:"change_option"`
	// The date that the quantity change should take effect, localized to the
	// customer's timezone. Ifthis parameter is not passed in, the quantity change is
	// effective according to `change_option`.
	EffectiveDate param.Field[time.Time] `json:"effective_date" format:"date"`
}

func (r SubscriptionUpdateFixedFeeQuantityParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// Determines when the change takes effect. Note that if `effective_date` is
// specified, this defaults to `effective_date`. Otherwise, this defaults to
// `immediate` unless it's explicitly set to `upcoming_invoice.
type SubscriptionUpdateFixedFeeQuantityParamsChangeOption string

const (
	SubscriptionUpdateFixedFeeQuantityParamsChangeOptionImmediate       SubscriptionUpdateFixedFeeQuantityParamsChangeOption = "immediate"
	SubscriptionUpdateFixedFeeQuantityParamsChangeOptionUpcomingInvoice SubscriptionUpdateFixedFeeQuantityParamsChangeOption = "upcoming_invoice"
	SubscriptionUpdateFixedFeeQuantityParamsChangeOptionEffectiveDate   SubscriptionUpdateFixedFeeQuantityParamsChangeOption = "effective_date"
)

func (r SubscriptionUpdateFixedFeeQuantityParamsChangeOption) IsKnown() bool {
	switch r {
	case SubscriptionUpdateFixedFeeQuantityParamsChangeOptionImmediate, SubscriptionUpdateFixedFeeQuantityParamsChangeOptionUpcomingInvoice, SubscriptionUpdateFixedFeeQuantityParamsChangeOptionEffectiveDate:
		return true
	}
	return false
}

type SubscriptionUpdateTrialParams struct {
	// The new date that the trial should end, or the literal string `immediate` to end
	// the trial immediately.
	TrialEndDate param.Field[SubscriptionUpdateTrialParamsTrialEndDateUnion] `json:"trial_end_date,required" format:"date-time"`
	// If true, shifts subsequent price and adjustment intervals (preserving their
	// durations, but adjusting their absolute dates).
	Shift param.Field[bool] `json:"shift"`
}

func (r SubscriptionUpdateTrialParams) MarshalJSON() (data []byte, err error) {
	return apijson.MarshalRoot(r)
}

// The new date that the trial should end, or the literal string `immediate` to end
// the trial immediately.
//
// Satisfied by [shared.UnionTime],
// [SubscriptionUpdateTrialParamsTrialEndDateString].
type SubscriptionUpdateTrialParamsTrialEndDateUnion interface {
	ImplementsSubscriptionUpdateTrialParamsTrialEndDateUnion()
}

type SubscriptionUpdateTrialParamsTrialEndDateString string

const (
	SubscriptionUpdateTrialParamsTrialEndDateStringImmediate SubscriptionUpdateTrialParamsTrialEndDateString = "immediate"
)

func (r SubscriptionUpdateTrialParamsTrialEndDateString) IsKnown() bool {
	switch r {
	case SubscriptionUpdateTrialParamsTrialEndDateStringImmediate:
		return true
	}
	return false
}

func (r SubscriptionUpdateTrialParamsTrialEndDateString) ImplementsSubscriptionUpdateTrialParamsTrialEndDateUnion() {
}
